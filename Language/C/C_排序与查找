<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"><title>C_排序与查找 | Barbecue</title><meta name="keywords" content="C"><meta name="author" content="Barbecue"><meta name="copyright" content="Barbecue"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#f7f9fe"><meta name="mobile-web-app-capable" content="yes"><meta name="apple-touch-fullscreen" content="yes"><meta name="apple-mobile-web-app-title" content="C_排序与查找"><meta name="application-name" content="C_排序与查找"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="#f7f9fe"><meta property="og:type" content="article"><meta property="og:title" content="C_排序与查找"><meta property="og:url" content="https://barbecue-g.github.io/Language/C/C_%E6%8E%92%E5%BA%8F%E4%B8%8E%E6%9F%A5%E6%89%BE"><meta property="og:site_name" content="Barbecue"><meta property="og:description" content="C_排序与查找排序的前提是”比较”，排序的目的往往是”查找”。 排序评估排序算法时间复杂度 最坏时间复杂度：在最不利的情况下，算法执行的时间。通常使用大O符号表示，如O(n²)、O(n log n)等。 平均时间复杂度：算法在随机数据情况下的平均执行时间。通常作为衡量算法效率的主要指标。 最好时间复"><meta property="og:locale" content="zh-CN"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/Barbecue-g/imagehost/Language/C/C-icon.png"><meta property="article:author" content="Barbecue"><meta property="article:tag" content="Barbecue"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/Barbecue-g/imagehost/Language/C/C-icon.png"><meta name="description" content="C_排序与查找排序的前提是”比较”，排序的目的往往是”查找”。 排序评估排序算法时间复杂度 最坏时间复杂度：在最不利的情况下，算法执行的时间。通常使用大O符号表示，如O(n²)、O(n log n)等。 平均时间复杂度：算法在随机数据情况下的平均执行时间。通常作为衡量算法效率的主要指标。 最好时间复"><link rel="shortcut icon" href="https://cdn.jsdelivr.net/gh/Barbecue-g/imagehost/Hexo/avatar.jpg?raw=true"><link rel="canonical" href="https://barbecue-g.github.io/Language/C/C_%E6%8E%92%E5%BA%8F%E4%B8%8E%E6%9F%A5%E6%89%BE"><link rel="preconnect" href="//cdn.cbd.int"/><meta name="google-site-verification" content="xxx"/><meta name="baidu-site-verification" content="code-xxx"/><meta name="msvalidate.01" content="xxx"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.cbd.int/@fortawesome/fontawesome-free@6.4.0/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  linkPageTop: undefined,
  peoplecanvas: {"enable":true,"img":"https://upload-bbs.miyoushe.com/upload/2024/07/27/125766904/ba62475f396df9de3316a08ed9e65d86_5680958632268053399..png"},
  postHeadAiDescription: {"enable":true,"gptName":"AnZhiYu","mode":"local","switchBtn":false,"btnLink":"https://afdian.net/item/886a79d4db6711eda42a52540025c377","randomNum":3,"basicWordCount":1000,"key":"xxxx","Referer":"https://xx.xx/"},
  diytitle: {"enable":true,"leaveTitle":"w(ﾟДﾟ)w 不要走！再看看嘛！","backTitle":"♪(^∇^*)欢迎肥来！"},
  LA51: undefined,
  greetingBox: undefined,
  twikooEnvId: '',
  commentBarrageConfig:undefined,
  music_page_default: "nav_music",
  root: '/',
  preloader: {"source":3},
  friends_vue_info: undefined,
  navMusic: true,
  mainTone: undefined,
  authorStatus: {"skills":["🤖️ 数码科技爱好者","🏃 脚踏实地行动派"]},
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简","rightMenuMsgToTraditionalChinese":"转为繁体","rightMenuMsgToSimplifiedChinese":"转为简体"},
  noticeOutdate: {"limitDay":365,"position":"top","messagePrev":"该文章创建于","messageNext":"天前，请以最新文章为准。"},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":330},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    simplehomepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"copy":true,"copyrightEbable":false,"limitCount":50,"languages":{"author":"作者: Barbecue","link":"链接: ","source":"来源: Barbecue","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","copySuccess":"复制成功，复制和转载请标注本文地址"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#425AEF","bgDark":"#1f1f1f","position":"top-center"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.min.js',
      css: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: true,
  shortcutKey: undefined,
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  configTitle: 'Barbecue',
  title: 'C_排序与查找',
  postAI: '',
  pageFillDescription: 'C_排序与查找, 排序, 评估排序算法, 时间复杂度, 空间复杂度, 稳定性, 插入排序, 直接插入排序, 算法思想, 代码实现, 算法分析, 折半排序, 算法思想, 代码实现, 算法分析, 希尔排序, 算法思想, 代码实现, 算法分析, 交换排序, 冒泡排序, 算法思想, 代码实现, 算法分析, 快速排序, 算法思想, 代码实现, 算法分析, 选择排序, 简单选择排序, 算法思想, 代码实现, 算法分析, 堆排序, 算法思想, 代码实现, 算法分析, 归并排序, 算法思想, 代码实现, 算法分析, 基数排序, 算法思想, 代码实现, 算法分析, 查找, 评估查找算法, 时间复杂度, 空间复杂度, 前提条件, 鲁棒性, 稳定性, 线性查找, 算法思想, 代码实现, 算法分析, 二分查找, 算法思想, 代码实现, 算法分析, 跳表, 算法思想, 代码实现, 算法分析, 哈希查找, 算法思想, 代码实现, 算法分析, 深度优先搜索, 算法思想, 代码实现, 算法分析, 广度优先搜索, 算法思想, 代码实现, 算法分析排序与查找排序的前提是比较排序的目的往往是查找排序评估排序算法时间复杂度最坏时间复杂度在最不利的情况下算法执行的时间通常使用大符号表示如等平均时间复杂度算法在随机数据情况下的平均执行时间通常作为衡量算法效率的主要指标最好时间复杂度在最理想情况下的执行时间例如当数组已排序时算法的复杂度可能更低空间复杂度原地排序算法是否需要额外的空间来完成排序影响空间复杂度辅助空间需要额外的存储空间进行辅助处理稳定性稳定排序两个元素相等它们在排序后的顺序与排序前相同称为稳定排序稳定排序算法冒泡排序插入排序归并排序计数排序基数排序不稳定排序算法选择排序快速排序堆排序插入排序直接插入排序算法思想构建有序序列对于未排序数据在已排序序列中从后向前扫描找到相应位置并插入类似扑克牌具体步骤如下从数组的第二个元素开始第一个元素默认是有序的将当前元素与前面已经排好序的元素进行比较找到适当的位置插入重复以上步骤直到整个数组有序代码实现从数组的第二个元素开始处理当前需要插入的元素将前面已经排好序的元素与比较找到插入位置将大于的元素向后移在找到的位置插入算法分析时间复杂度最优时间复杂度当输入数组已经有序时只需要逐个扫描每次比较一次即可最坏时间复杂度当输入数组是逆序排列时每插入一个元素都需要将已排序部分的所有元素向右移动比较次数和移动次数都达到最大时间复杂度为平均时间复杂度在随机排列的数组中插入排序的平均时间复杂度也是空间复杂度插入排序只需要常量级的额外空间用于临时存储变量稳定性稳定相等元素在排序过程中不会交换顺序折半排序算法思想折半排序算法是插入排序算法的一种改进通常插入排序在插入新元素时需要从头到尾进行线性搜索找到适当的位置而折半插入排序通过在已排序的序列中使用二分查找也称折半查找来确定插入位置从而减少比较次数折半插入排序的基本步骤如下排序过程与插入排序相似依次将每个元素插入到前面已经排好序的子数组中查找插入位置时使用二分查找法来代替逐一比较从而减少查找的时间复杂度代码实现待插入的元素二分查找插入位置移动元素以腾出位置插入元素算法分析时间复杂度最优时间复杂度当输入数组已经有序时只需要找到正确位置而无需移动查找时间为但由于元素移动的过程仍然是线性的所以最好的时间复杂度仍然是虽然折半插入排序减少了比较次数但由于元素插入时需要移动数据其时间复杂度并没有降低太多最坏时间复杂度当输入数组是逆序排列时需要每次都将新元素插入到最前面此时查找的复杂度为但移动元素的复杂度为最坏的时间复杂度仍然是平均时间复杂度查找和移动元素的综合开销不会大幅减少空间复杂度插入排序只需要常量级的额外空间用于临时存储变量稳定性稳定相等元素在排序过程中不会交换顺序希尔排序算法思想希尔排序是插入排序的一种优化版本旨在减少数据移动次数来提高排序效率希尔排序通过引入增量分组的方式对原数组进行分组使每组内部进行插入排序随着增量的不断缩小分组越来越少直到增量缩小为时整个数组变为有序希尔排序的关键是增量序列的选择常用的增量序列是即每次将间隔减半代码实现初始间隔设为数组长度的一半然后每次减半从开始逐步对每个子序列进行插入排序保存当前元素将插入到子序列中将较大的元素后移将当前元素放入正确位置算法分析时间复杂度希尔排序的时间复杂度与增量序列的选择有关常见的增量序列为最优情况实际运行中常显著优于插入排序最坏情况使用更优化的增量序列如增量序列时最坏时间复杂度可以降低到或更低平均时间复杂度具体取决于增量序列的选择空间复杂度希尔排序是原地排序算法不需要额外的存储空间稳定性不稳定相同元素在不同的增量分组时可能会被打乱其相对顺序交换排序冒泡排序算法思想通过多次遍历待排序的数组每一轮比较相邻的两个元素将较大的元素逐步冒泡到数组的末尾整个过程重复进行直到所有元素按从小到大的顺序排列具体步骤如下从第一个元素开始比较相邻的两个元素如果前一个元素比后一个大则交换两者的位置每一轮遍历后最大元素会移动到数组末尾重复上述步骤直到所有元素有序代码实现外层循环控制遍历的轮数标志变量检测本轮是否有元素交换内层循环比较相邻元素并交换如果前一个元素比后一个大则交换标记有元素发生交换如果没有发生交换说明数组已排序提前结束算法分析时间复杂度最优情况已排序的数组数组本身就是有序的冒泡排序只需进行一轮比较无需交换最坏情况逆序数组在数组完全逆序的情况下算法需要进行轮排序每轮排序需要次比较和交换平均时间复杂度大部分排序情况都需要多轮比较和交换在没有特殊信息的情况下平均情况下冒泡排序的时间复杂度仍为空间复杂度冒泡排序是原地排序算法不需要额外的存储空间稳定性稳定相等元素在排序过程中不会交换顺序快速排序算法思想快速排序是一种分治法排序算法其基本思想是选择一个基准元素可以是数组的第一个元素中间元素或随机选择将数组划分成两部分左部分包含所有小于基准元素的数右部分包含所有大于基准元素的数对左右两部分递归地进行快速排序合并结果即可得到一个有序数组关键步骤分区每次根据基准元素将数组分为两部分递归对左右子数组分别进行快速排序代码实现快速排序的分区函数选择最右边元素作为基准是小于的元素的索引若当前元素小于基准增加小于区域的索引交换和将基准元素放到正确的位置返回基准的最终位置快速排序函数获取分区位置递归排序左半部分递归排序右半部分算法分析时间复杂度最优情况每次划分正好将数组一分为二最坏情况每次划分不平衡如每次选择的基准恰好是数组的最大或最小值平均时间复杂度其中是数组的元素个数是递归调用的层数空间复杂度快速排序是原地排序算法递归调用栈的深度为最坏情况下递归深度为最坏空间复杂度为稳定性不稳定在划分过程中可能会交换相同元素的相对位置选择排序简单选择排序算法思想在未排序的序列中找到最小或最大的元素将其放到序列的起始位置然后继续在剩余未排序的序列中重复该操作直到整个序列有序具体步骤如下从未排序的部分中选择最小的元素将该元素与未排序部分的第一个元素交换位置重复上述过程直到所有元素排序完毕代码实现遍历数组中的每一个元素假设当前位置的元素是未排序部分中的最小值在未排序的部分中寻找最小值记录最小值的索引如果找到的最小值不是当前位置的元素则交换交换和算法分析时间复杂度最优情况已排序的数组选择排序每次都需要遍历未排序部分的元素最好情况也需要执行次选择操作每次操作时间为次比较最坏情况逆序数组无论数据原始顺序如何算法都需要遍历每一个元素平均时间复杂度由于选择排序与输入的顺序无关每次都要遍历未排序部分空间复杂度选择排序是原地排序算法只需要常量级的额外空间来存储临时变量用于交换稳定性不稳定选择排序在选择最小元素并交换时可能会破坏原本的相对顺序堆排序算法思想堆排序是一种基于二叉堆的数据结构的排序算法堆是一种特殊的完全二叉树可以分为最大堆和最小堆在最大堆中父节点的值总是大于等于其子节点的值在最小堆中父节点的值总是小于等于其子节点的值堆排序的基本思想是构建最大堆将无序数组调整为最大堆使得堆顶元素即根节点为整个数组的最大值交换堆顶元素和末尾元素将堆顶元素最大值与堆的最后一个元素交换最大元素就位于数组的最后并从堆中移除调整堆对剩余的元素进行堆调整重复上述步骤直到所有元素有序代码实现堆调整函数调整以为根节点的子树使其满足最大堆的性质是数组的长度是当前根节点的索引初始化为根节点左子节点索引右子节点索引如果左子节点存在且大于根节点如果右子节点存在且大于当前如果不是根节点交换根节点和最大值节点递归调整子树堆排序函数对数组进行堆排序构建最大堆逐步将堆顶元素最大值移动到数组末尾将堆顶元素与当前未排序部分的最后一个元素交换调整剩余元素形成新的最大堆算法分析构建堆构建最大堆的过程需要遍历所有非叶子节点对每个节点进行堆调整调整一个节点的时间复杂度为总的构建堆时间复杂度为排序过程在堆排序过程中每次取出堆顶元素最大值然后对剩余的元素进行堆调整整个排序过程需要进行次堆调整每次调整的时间复杂度为总的排序时间复杂度为时间复杂度最坏情况平均情况最好情况空间复杂度堆排序在排序过程中只需要常数级别的额外空间来进行交换操作和递归调用稳定性不稳定在堆调整过程中元素之间的相对顺序可能会被改变当父节点和子节点交换时原本相同的两个元素可能会被打乱顺序归并排序算法思想归并排序是一种分治算法其核心思想是将待排序数组递归地分成两半分别对左右两部分进行排序最后将两部分合并成一个有序数组分治步骤分将数组递归地分成两半直到每个子数组只包含一个元素此时认为子数组是有序的治将两个有序的子数组合并成一个有序数组合并将小问题合并成大问题最终将整个数组合并为一个有序数组归并排序的核心步骤是合并两个有序数组过程是线性时间的代码实现归并函数将两个有序的子数组合并为一个有序数组左边子数组的大小右边子数组的大小创建临时数组存储左右两部分将数据复制到临时数组合并两个临时数组保证稳定性左边元素右边元素如果左边还有剩余元素直接复制如果右边还有剩余元素直接复制归并排序的递归函数计算中间点递归地对左右两部分进行排序合并已排好序的两部分算法分析归并排序在最优最坏和平均情况下的时间复杂度都是其中是数组的长度是由于递归分割数组的过程是合并两个有序子数组的时间时间复杂度分析归并排序的每一次分解步骤都会将数组对半划分整个过程为次在每次划分后的合并步骤中需要花费的时间来合并两个有序子数组总时间复杂度为时间复杂度最坏情况平均情况最好情况空间复杂度归并排序的空间复杂度主要来自递归调用栈以及临时数组每次递归调用会使用的栈空间而临时数组则需要的额外空间来存储子数组稳定性稳定排序时相等元素的相对位置不会改变若两个元素相等会优先将左边的元素放入结果数组基数排序算法思想基数排序是一种非比较排序算法基于位的思想来排序它适合用于对整数或字符串等结构较为固定的对象进行排序该算法的核心思想是将数据拆分成多个部分如个位十位百位等逐步对每一部分进行排序最终得到有序的数据序列基数排序有两种方式从最低位开始排序常用于排序数字从最高位开始排序常用于排序字符串等主要步骤如下将数据按位从最低位到最高位进行分配找出待排序数组中最大元素的位数从最低位开始对数组元素按位排序使用稳定的排序算法如计数排序或桶排序对各个位上的数进行排序重复步骤直到最高位也排序完毕基数排序的特点是每一位上的排序必须是稳定的才能保证排序的正确性代码实现假设整数的范围是到并且使用计数排序作为每一位的排序方法主要包含核心的和辅助的计数排序函数获取数组中的最大值按照当前位数进行计数排序是对应的位数表示个位表示十位依次类推输出数组计数数组用来存储每个桶中的元素个数计算当前位数的出现次数修改计数数组使其包含当前位数的正确位置从后向前遍历数组确保计数排序是稳定的将排序结果复制回原数组基数排序主函数找到数组中的最大数以确定最大位数从个位开始逐位对数组进行排序算法分析设数组中元素的最大值为数组的长度为最大值的位数为每一位使用计数排序其复杂度为其中为计数排序的范围对个数字的计数排序总时间复杂度为当为常数时复杂度为对于整数来说通常较小可以认为为常数基数排序的时间复杂度为元素范围较大例如需要排序非常大的数字会增大算法的时间复杂度也会相应提高时间复杂度最坏情况平均情况最好情况空间复杂度其中是待排序元素的个数是计数排序的桶数量在本算法中计数排序的桶数量是对应十进制数的个位十位百位等即线性空间复杂度稳定性稳定特别是在每一位的排序中使用稳定的排序算法如计数排序时可以保证两个相同元素在排序前后的相对顺序不变查找评估查找算法时间复杂度最坏情况时间复杂度算法在最坏情况下的运行时间例如线性查找在最坏情况下需要而二分查找的最坏情况是平均情况时间复杂度评估算法在不同输入条件下的平均表现平均情况下的算法性能例如哈希查找在没有冲突时平均复杂度为而在发生冲突时复杂度升高最优情况时间复杂度算法在最理想的情况下的性能例如在二分查找中若目标元素恰好是数组的中间值查找时间为空间复杂度额外空间需求是否需要额外空间进行数据存储或处理例如线性查找不需要额外空间复杂度为而哈希查找需要额外的空间来存储哈希表辅助数据结构某些查找算法依赖额外的数据结构比如跳表或哈希表需要额外的内存空间来存储索引或哈希值前提条件有序数据算法是否需要数据有序如二分查找要求数据必须是已排序的数据结构不同查找算法适用于不同的数据结构例如哈希查找适用于哈希表二分查找适用于有序数组广度优先搜索适用于图动态数据集某些查找算法更适合处理动态数据集如跳表和哈希查找而二分查找适用于静态有序数组鲁棒性最坏情况表现算法在最坏情况下的效率例如哈希查找在最坏情况下退化到当哈希冲突严重时而二分查找始终保持容错能力查找算法是否对异常输入如空数组数据不匹配做了合理处理防止崩溃或出错抗数据分布能力部分查找算法对数据分布较为敏感如插值查找对均匀分布数据表现好但对于不均匀分布的数据性能下降明显稳定性动态数据处理能力某些查找算法需要在数据动态变化时仍保持高效例如跳表在数据插入删除时能保持较好的查找性能时间复杂度是重复元素的处理查找算法是否能正确处理重复元素如线性查找可以找到多个匹配项但二分查找需要特殊处理以找到第一个或最后一个匹配元素线性查找算法思想线性查找核心思想是从数组的第一个元素开始依次检查每个元素直到找到目标元素或数组末尾为止线性查找适用于无序数组不需要对数组进行排序代码实现遍历数组中的每一个元素如果找到了目标值返回其索引如果未找到目标值返回算法分析时间复杂度最坏情况在最坏的情况下即目标元素在数组的末尾或者不存在需要检查数组中的每一个元素最好情况在最好的情况下即目标元素是数组的第一个元素只需要一次比较平均情况目标元素可能在数组的任何位置平均需要遍历数组的一半即次操作时间复杂度仍然为空间复杂度该算法只使用了一个额外的整型变量用于循环计数空间复杂度与输入数据的大小无关前提条件无序数组线性查找不要求数组有序适合在任何情况下使用鲁棒性鲁棒性强算法本身不会对数组的内容做任何假设即使数组中包含重复值负数零等线性查找仍然可以正常工作稳定性稳定特别是在每一位的排序中使用稳定的排序算法如计数排序时可以保证两个相同元素在排序前后的相对顺序不变二分查找算法思想二分查找是一种在有序数组中查找目标值的高效算法基本思想是每次将查找范围缩小一半假设有一个有序数组并想在其中查找一个特定元素首先比较目标值与中间元素的大小如果目标值等于中间元素直接返回该元素的索引如果目标值小于中间元素则只需继续在左半部分查找如果目标值大于中间元素则只需继续在右半部分查找不断重复直到找到目标值或者查找范围缩小为空表明目标值不存在代码实现循环实现计算中间索引如果目标值等于中间元素返回索引如果目标值小于中间元素继续在左半部分查找如果目标值大于中间元素继续在右半部分查找未找到目标值返回递归实现递归公式算法分析时间复杂度最坏情况每次查找都会将范围缩小一半需要进行的比较次数为次时间复杂度为最好情况当目标值正好位于数组的中间位置时只需进行一次比较即可找到目标值此时复杂度为平均情况与最坏情况相同平均情况下复杂度为空间复杂度由于只使用了常数级别的额外变量如前提条件数组有序二分查找的前提是数组必须是有序的若数组无序算法无法正常工作静态数组二分查找适合用于静态数组即数组元素在查找过程中不会改变元素发生改变需要先重新排序鲁棒性目标值不存在的情况目标值不在数组中算法最终会将查找范围缩小至无效的区间此时返回表示未找到目标值数组为空在调用函数时数组为空算法会直接返回稳定性不稳定无法保证对于重复出现的元素总是返回第一个出现的索引跳表算法思想跳表是一种基于链表的数据结构其核心思想是是在链表上建立多层跳跃索引每层索引中的元素是下层链表的子集索引层数越高包含的元素越少跳表特点跳表的结构是多级链表最低层是原始链表上面的每一层是索引链表查找插入和删除操作依赖于索引通过逐层查找可以减少比较次数进而提高效率跳表的随机层数决定了效率可以通过随机函数控制索引的生成代码实现定义跳表的最大层数跳表中元素晋升的概率跳表节点定义指向各层的前进指针数组跳表定义当前跳表的最大层数跳表的头节点创建节点创建跳表初始时跳表层数为创建头节点生成随机层数查找操作从最高层往低层查找到达底层后前进到下一个节点找到目标节点未找到插入操作记录更新路径从最高层往低层查找插入位置记录每一层的最后节点生成该节点的随机层数新层初始化更新跳表的层数创建新节点并插入删除操作从最高层往低层查找删除位置到达底层更新每一层的前进指针删除节点检查并更新跳表的层数算法分析时间复杂度查找操作跳表的查找过程是从上层逐级往下查找每一层的节点数期望是上一层的一半查找的平均时间复杂度为最坏情况下退化为所有元素都在最低层插入操作插入操作需要找到插入位置然后插入新节点和查找过程类似平均时间复杂度为删除操作删除操作与查找过程相似找到要删除的节点修改前驱节点的指针平均时间复杂度为空间复杂度跳表需要为每个节点维护多层索引索引的层数是随机生成的平均情况下跳表每一层的节点数量是前一层的前提条件跳表是一种有序的数据结构节点的值必须具有可比较性例如整数浮点数字符串等可排序类型跳表在设计上依赖于随机层数的生成随机数生成器需要良好表现不能总是生成过大的层数或过小的层数鲁棒性跳表的插入和删除操作依赖于随机层数生成跳表的性能在实际运行时会有一定波动虽然最坏情况下跳表的时间复杂度为但平均情况较好能保持跳表的鲁棒性体现在它可以通过随机层数来避免复杂的平衡操作不像红黑树等需要严格的平衡调整稳定性查找的稳定性跳表的查找操作是确定的即使数据随机插入只要结构不发生变化多次查找同一个值的结果一致因此跳表的查找操作是稳定的插入删除的稳定性由于跳表中的元素插入是基于随机层数生成的插入和删除的效率会有所波动但总体是稳定的哈希查找算法思想哈希查找是一种通过键值来直接访问数据的方法其核心思想是将元素的存储位置和键值通过一个哈希函数关联起来将关键字映射到数组中的一个位置然后通过数组的下标直接找到对应的值哈希函数负责将键值转换为数组索引一个好的哈希函数应具有均匀性和简单性避免大量冲突哈希表利用数组实现的存储元素的位置通过哈希函数计算得出冲突处理当两个不同的键值通过哈希函数得到相同的数组索引时称为冲突常用的冲突解决方法有开放地址法和链地址法代码实现哈希表的最大容量定义哈希表初始化哈希表所有位置设置为表示空简单的哈希函数将键值转换为数组索引插入键值计算哈希值线性探测处理冲突向后探测下一个位置插入键值查找键值计算哈希值线性探测查找处理冲突找到键值返回位置向后探测下一个位置未找到返回删除键值查找键值所在位置将对应位置设为空算法分析时间复杂度最坏情况当发生大量冲突时最坏情况下时间复杂度为例如所有键值都映射到相同位置时需要线性探测整个数组最好情况理想情况下通过哈希函数能直接定位平均情况插入查找和删除的平均时间复杂度为理想情况下通过哈希函数能直接定位空间复杂度哈希表的空间复杂度为其中是哈希表的大小前提条件哈希函数应设计合理尽量均匀分布键值避免产生大量冲突表的大小应适当通常选择一个比实际存储量略大的素数以减少冲突鲁棒性目标值不存在的情况对于不存在的元素查找函数能返回表示未找到具有良好的鲁棒性插入函数能自动处理冲突避免覆盖已有数据稳定性不稳定元素的插入和查找顺序不依赖于元素的原始顺序深度优先搜索算法思想深度优先搜索是一种遍历或搜索图或树数据结构的算法其基本思想是沿着一个分支不断向前深入直到找到目标或到达叶子节点每当到达一个节点时如果该节点的所有相邻节点都已经访问过或不可达算法会回溯到上一个节点继续搜索未访问的相邻节点直到所有节点都被访问使用的是栈的思想可以通过递归或显式使用栈结构来实现即先探到最深处然后逐步回溯代码实现图的邻接矩阵表示图的邻接矩阵标记节点是否已访问深度优先搜索算法实现标记当前节点为已访问遍历所有相邻节点如果有相邻节点且未访问继续深入递归调用是图的邻接矩阵表示节点与节点相连用于标记节点是否已经被访问以避免重复遍历函数中通过递归实现了从某个节点开始的深度优先搜索算法分析时间复杂度的时间复杂度取决于图的表示方式总的来说对稀疏图边较少和稠密图边较多都具有良好的性能表现邻接矩阵其中是图中节点数邻接表其中是图中边的数量空间复杂度空间复杂度主要由递归栈占用邻接矩阵其中是图中节点数邻接表其中是图中节点数前提条件图可以是连通或非连通图适用于无向图和有向图对于递归实现要求系统栈空间足够大适合节点数量较小的图如果图的节点非常多递归深度过大可能会导致栈溢出建议改用非递归方式例如使用栈模拟递归鲁棒性需要考虑边界情况例如图为空没有节点或边只有一个节点图不连通等特殊情况需要处理节点数组越界空指针等异常稳定性不稳定不同的执行顺序可能会导致不同的遍历路径取决于邻接节点的访问顺序广度优先搜索算法思想广度优先搜索是一种图遍历算法通常用于无权图最短路径问题连通分量搜索等问题其基本思想是从起始节点开始先访问所有相邻节点然后再逐层向外扩展直到目标节点被访问或所有节点都被遍历完使用队列来维护当前层级的节点并确保节点按层级顺序访问每次从队列中取出一个节点访问其所有未访问的邻节点将它们加入队列代码实现队列结构初始化队列判断队列是否为空入队队列满了出队队列为空广度优先搜索算法标记每个节点是否访问过访问节点遍历当前节点的所有邻接节点标记为已访问将邻接节点加入队列算法分析时间复杂度其中是顶点的数量是边的数量在最坏情况下需要遍历每个顶点和与其相连的每条边空间复杂度存储图的邻接矩阵和队列队列最多存储所有顶点即访问标记数组存储每个顶点的访问状态也是前提条件图的存储方式本实现使用邻接矩阵表示图因此适用于稠密图如果图是稀疏的可以改用邻接表来优化空间复杂度输入合法性输入的图应是连通图探索全图并且顶点的索引应合法鲁棒性队列溢出检测本代码中检查了队列是否满但没有处理队列溢出的错误处理机制如扩展队列容量对于大图来说需要更鲁棒的动态队列实现图遍历的边界处理该算法可以处理连通图和非连通图但要确保输入的顶点索引在有效范围内即之间稳定性稳定按照层级顺序依次访问每个顶点保证在最短路径问题中较早访问的顶点优先处理不会跳跃式访问',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-09-28 18:24:04',
  postMainColor: '',
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#18171d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#f7f9fe')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(e => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.3.0"></head><body data-type="anzhiyu"><div id="web_bg"></div><div id="an_music_bg"></div><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><img class="loading-img nolazyload" alt="加载头像" src="https://cdn.jsdelivr.net/gh/Barbecue-g/imagehost/Hexo/avatar.jpg?raw=true"/><div class="loading-image-dot"></div></div></div><script>const preloader = {
  endLoading: () => {
    document.getElementById('loading-box').classList.add("loaded");
  },
  initLoading: () => {
    document.getElementById('loading-box').classList.remove("loaded")
  }
}
window.addEventListener('load',()=> { preloader.endLoading() })
setTimeout(function(){preloader.endLoading();},10000)

if (true) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.10/progress_bar/progress_bar.css"/><script async="async" src="https://cdn.cbd.int/pace-js@1.2.4/pace.min.js" data-pace-options="{ &quot;restartOnRequestAfter&quot;:false,&quot;eventLag&quot;:false}"></script><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><div id="nav-group"><span id="blog_name"><div class="back-home-button"><i class="anzhiyufont anzhiyu-icon-grip-vertical"></i><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">CPP文档</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://zh.cppreference.com/" title="中文版"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.png&quot;" data-lazy-src="https://github.com/Barbecue-g/Imagehost/blob/master/Hexo/book-icon.png?raw=true" alt="中文版"/><span class="back-menu-item-text">中文版</span></a><a class="back-menu-item" target="_blank" rel="noopener" href="https://cplusplus.com/" title="英文版"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.png&quot;" data-lazy-src="https://github.com/Barbecue-g/Imagehost/blob/master/Hexo/book1-cion.png?raw=true" alt="英文版"/><span class="back-menu-item-text">英文版</span></a></div></div><div class="back-menu-list-group"><div class="back-menu-list-title">CPP规范</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://zh-google-styleguide.readthedocs.io/en/stable/contents.html" title="Google"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.png&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/Barbecue-g/imagehost/Hexo/Google-icon.jpg?raw=true" alt="Google"/><span class="back-menu-item-text">Google</span></a></div></div><div class="back-menu-list-group"><div class="back-menu-list-title">推荐网址</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://github.com/cloudwu/skynet" title="Skynet"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.png&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/Barbecue-g/imagehost/FrameWork/Skynet/Skynet-icon.png?raw=true" alt="Skynet"/><span class="back-menu-item-text">Skynet</span></a><a class="back-menu-item" target="_blank" rel="noopener" href="https://www.unrealengine.com/" title="UE5"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.png&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/Barbecue-g/imagehost/FrameWork/UE5/UE5-icon.png?raw=true" alt="UE5"/><span class="back-menu-item-text">UE5</span></a></div></div></div></div><a id="site-name" href="/" accesskey="h"><div class="title">Barbecue</div><i class="anzhiyufont anzhiyu-icon-house-chimney"></i></a><div id="he-plugin-simple"></div><script>var WIDGET = {
  "CONFIG": {
    "modules": "0124",
    "background": "2",
    "tmpColor": "FFFFFF",
    "tmpSize": "16",
    "cityColor": "FFFFFF",
    "citySize": "16",
    "aqiColor": "E8D87B",
    "aqiSize": "16",
    "weatherIconSize": "24",
    "alertIconSize": "18",
    "padding": "10px 10px 10px 10px",
    "shadow": "0",
    "language": "auto",
    "borderRadius": "20",
    "fixed": "true",
    "vertical": "top",
    "horizontal": "left",
    "left": "20",
    "top": "7.1",
    "key": "df245676fb434a0691ead1c63341cd94"
  }
}
</script><link rel="stylesheet" href="https://widget.qweather.net/simple/static/css/he-simple.css?v=1.4.0"/><script src="https://widget.qweather.net/simple/static/js/he-simple.js?v=1.4.0"></script></span><div class="mask-name-container"><div id="name-container"><a id="page-name" href="javascript:anzhiyu.scrollToDest(0, 500)">PAGE_NAME</a></div></div><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 目录</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/TOC/C"><i class="fa-solid fa-seedling faa-tada"></i><span> C语言</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/TOC/CPP"><i class="fa-solid fa-robot faa-tada"></i><span> CPP</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/TOC/Skynet"><i class="fa-solid fa-cloud faa-tada"></i><span> Skynet</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/TOC/UE5"><i class="fa-solid fa-gamepad faa-tada"></i><span> UE5</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size: 0.9em;"></i><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size: 0.9em;"></i><span> 归档</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 社交</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/link/"><i class="anzhiyufont anzhiyu-icon-link faa-tada" style="font-size: 0.9em;"></i><span> 推荐</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/comments/"><i class="anzhiyufont anzhiyu-icon-envelope faa-tada" style="font-size: 0.9em;"></i><span> 留言板</span></a></li></ul></div></div></div><div id="nav-right"><div class="nav-button" id="randomPost_button"><a class="site-page" onclick="toRandomPost()" title="随机前往一个文章" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-dice"></i></a></div><div class="nav-button" id="search-button"><a class="site-page social-icon search" href="javascript:void(0);" title="搜索🔍" accesskey="s"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span> 搜索</span></a></div><input id="center-console" type="checkbox"/><label class="widget" for="center-console" title="中控台" onclick="anzhiyu.switchConsole();"><i class="left"></i><i class="widget center"></i><i class="widget right"></i></label><div id="console"><div class="console-card-group-reward"><ul class="reward-all console-card"><li class="reward-item"><a href="https://cdn.jsdelivr.net/gh/Barbecue-g/imagehost/Hexo/wechatpay.jpg" target="_blank"><img class="post-qr-code-img" alt="微信" src="https://cdn.jsdelivr.net/gh/Barbecue-g/imagehost/Hexo/wechatpay.jpg"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://cdn.jsdelivr.net/gh/Barbecue-g/imagehost/Hexo/alipay.jpg" target="_blank"><img class="post-qr-code-img" alt="支付宝" src="https://cdn.jsdelivr.net/gh/Barbecue-g/imagehost/Hexo/alipay.jpg"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div><div class="console-card-group"><div class="console-card-group-left"><div class="console-card" id="card-newest-comments"><div class="card-content"><div class="author-content-item-tips">互动</div><span class="author-content-item-title"> 最新评论</span></div><div class="aside-list"><span>正在加载中...</span></div></div></div><div class="console-card-group-right"><div class="console-card tags"><div class="card-content"><div class="author-content-item-tips">兴趣点</div><span class="author-content-item-title">寻找你感兴趣的领域</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/C/" style="font-size: 1.05rem;">C<sup>15</sup></a><a href="/tags/Git/" style="font-size: 1.05rem;">Git<sup>3</sup></a><a href="/tags/Hexo/" style="font-size: 1.05rem;">Hexo<sup>1</sup></a><a href="/tags/MySQL/" style="font-size: 1.05rem;">MySQL<sup>2</sup></a><a href="/tags/Nginx/" style="font-size: 1.05rem;">Nginx<sup>1</sup></a><a href="/tags/PicGo/" style="font-size: 1.05rem;">PicGo<sup>1</sup></a><a href="/tags/Postman/" style="font-size: 1.05rem;">Postman<sup>1</sup></a><a href="/tags/Redis/" style="font-size: 1.05rem;">Redis<sup>1</sup></a><a href="/tags/skynet/" style="font-size: 1.05rem;">skynet<sup>18</sup></a><a href="/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/" style="font-size: 1.05rem;">正则表达式<sup>1</sup></a></div></div><hr/></div></div><div class="console-card history"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-box-archiv"></i><span>文章</span></div><div class="card-archives"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-archive"></i><span>归档</span></div><ul class="card-archive-list"><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/10/"><span class="card-archive-list-date">十月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">18</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/09/"><span class="card-archive-list-date">九月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">16</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/03/"><span class="card-archive-list-date">三月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">5</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/02/"><span class="card-archive-list-date">二月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/01/"><span class="card-archive-list-date">一月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">5</span><span>篇</span></div></a></li></ul></div><hr/></div></div></div><div class="button-group"><div class="console-btn-item"><a class="darkmode_switchbutton" title="显示模式切换" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-moon"></i></a></div><div class="console-btn-item" id="consoleHideAside" onclick="anzhiyu.hideAsideBtn()" title="边栏显示控制"><a class="asideSwitch"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></a></div><div class="console-btn-item" id="consoleMusic" onclick="anzhiyu.musicToggle()" title="音乐开关"><a class="music-switch"><i class="anzhiyufont anzhiyu-icon-music"></i></a></div></div><div class="console-mask" onclick="anzhiyu.hideConsole()" href="javascript:void(0);"></div></div><div class="nav-button" id="nav-totop"><a class="totopbtn" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i><span id="percent" onclick="anzhiyu.scrollToDest(0,500)">0</span></a></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);" title="切换"><i class="anzhiyufont anzhiyu-icon-bars"></i></a></div></div></div></nav><div id="post-info"><div id="post-firstinfo"><div class="meta-firstline"><a class="post-meta-original">原创</a><span class="post-meta-categories"><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-inbox post-meta-icon"></i><a class="post-meta-categories" href="/categories/C/" itemprop="url">C</a></span><span class="article-meta tags"><a class="article-meta__tags" href="/tags/C/" tabindex="-1" itemprop="url"> <span> <i class="anzhiyufont anzhiyu-icon-hashtag"></i>C</span></a></span></div></div><h1 class="post-title" itemprop="name headline">C_排序与查找</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="anzhiyufont anzhiyu-icon-calendar-days post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" itemprop="dateCreated datePublished" datetime="2024-09-28T10:24:04.000Z" title="发表于 2024-09-28 18:24:04">2024-09-28</time><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-history post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" itemprop="dateCreated datePublished" datetime="2024-09-28T10:24:04.000Z" title="更新于 2024-09-28 18:24:04">2024-09-28</time></span></div><div class="meta-secondline"><span class="post-meta-separator"></span><span class="post-meta-wordcount"><i class="anzhiyufont anzhiyu-icon-file-word post-meta-icon" title="文章字数"></i><span class="post-meta-label" title="文章字数">字数总计:</span><span class="word-count" title="文章字数">11.2k</span><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-clock post-meta-icon" title="阅读时长"></i><span class="post-meta-label" title="阅读时长">阅读时长:</span><span>39分钟</span></span><span class="post-meta-separator">       </span><span class="post-meta-position" title="作者IP属地为上海"><i class="anzhiyufont anzhiyu-icon-location-dot"></i>上海</span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section><div id="post-top-cover"><img class="nolazyload" id="post-top-bg" src="https://cdn.jsdelivr.net/gh/Barbecue-g/imagehost/Hexo/0.jpg"></div></header><main id="blog-container"><div class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container" itemscope itemtype="https://barbecue-g.github.io/"><header><a class="post-meta-categories" href="/categories/C/" itemprop="url">C</a><a href="/tags/C/" tabindex="-1" itemprop="url">C</a><h1 id="CrawlerTitle" itemprop="name headline">C_排序与查找</h1><span itemprop="author" itemscope itemtype="http://schema.org/Person">Barbecue</span><time itemprop="dateCreated datePublished" datetime="2024-09-28T10:24:04.000Z" title="发表于 2024-09-28 18:24:04">2024-09-28</time><time itemprop="dateCreated datePublished" datetime="2024-09-28T10:24:04.000Z" title="更新于 2024-09-28 18:24:04">2024-09-28</time></header><h1 id="C-排序与查找"><a href="#C-排序与查找" class="headerlink" title="C_排序与查找"></a>C_排序与查找</h1><p>排序的前提是”比较”，排序的目的往往是”查找”。</p>
<h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><h3 id="评估排序算法"><a href="#评估排序算法" class="headerlink" title="评估排序算法"></a>评估排序算法</h3><h4 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><ul>
<li><strong>最坏时间复杂度</strong>：在最不利的情况下，算法执行的时间。通常使用大O符号表示，如O(n²)、O(n log n)等。</li>
<li><strong>平均时间复杂度</strong>：算法在随机数据情况下的平均执行时间。通常作为衡量算法效率的主要指标。</li>
<li><strong>最好时间复杂度</strong>：在最理想情况下的执行时间，例如，当数组已排序时，算法的复杂度可能更低。</li>
</ul>
<h4 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h4><ul>
<li><strong>原地排序</strong>：算法是否需要额外的空间来完成排序，影响空间复杂度。</li>
<li><strong>辅助空间</strong>：需要额外的存储空间进行辅助处理。</li>
</ul>
<h4 id="稳定性"><a href="#稳定性" class="headerlink" title="稳定性"></a>稳定性</h4><ul>
<li><p><strong>稳定排序</strong>：两个元素相等，它们在排序后的顺序与排序前相同，称为稳定排序。</p>
<p><strong>稳定排序算法</strong>：冒泡排序、插入排序、归并排序、计数排序、基数排序。</p>
<p><strong>不稳定排序算法</strong>：选择排序、快速排序、堆排序。</p>
</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.png&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/Barbecue-g/imagehost/Language/C/C_%E6%8E%92%E5%BA%8F%E4%B8%8E%E6%9F%A5%E6%89%BE/%E6%8E%92%E5%BA%8F.png" alt="排序算法"></p>
<h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><h4 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h4><h5 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h5><p>构建有序序列。对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。（类似扑克牌）</p>
<p>具体步骤如下：</p>
<ul>
<li>从数组的第二个元素开始（第一个元素默认是有序的）。</li>
<li>将当前元素与前面已经排好序的元素进行比较，找到适当的位置插入。</li>
<li>重复以上步骤，直到整个数组有序。</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.png&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/Barbecue-g/imagehost/Language/C/C_%E6%8E%92%E5%BA%8F%E4%B8%8E%E6%9F%A5%E6%89%BE/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F.png" alt="插入排序"></p>
<h5 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">qvoid <span class="title function_">insertionSort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> n)</span> &#123;  </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;		<span class="comment">// 从数组的第二个元素开始处理</span></span><br><span class="line">        <span class="type">int</span> key = arr[i];  <span class="comment">// 当前需要插入的元素</span></span><br><span class="line">        <span class="type">int</span> j = i - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; arr[j] &gt; key) &#123;		<span class="comment">// 将前面已经排好序的元素与key比较，找到插入位置</span></span><br><span class="line">            arr[j + <span class="number">1</span>] = arr[j];  <span class="comment">// 将大于key的元素向后移</span></span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[j + <span class="number">1</span>] = key;  <span class="comment">// 在找到的位置插入key</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h5><ol>
<li><p><strong>时间复杂度</strong></p>
<ul>
<li>最优时间复杂度：**O(n)**。当输入数组已经有序时，只需要逐个扫描，每次比较一次即可。</li>
<li>最坏时间复杂度：**O(n²)**：当输入数组是逆序排列时，每插入一个元素，都需要将已排序部分的所有元素向右移动，比较次数和移动次数都达到最大，时间复杂度为 <code>O(n²)</code> 。</li>
<li>平均时间复杂度：**O(n²)**：在随机排列的数组中，插入排序的平均时间复杂度也是 <code>O(n²)</code> 。</li>
</ul>
</li>
<li><p>空间复杂度：**O(1)**。插入排序只需要常量级的额外空间用于临时存储key变量。</p>
</li>
<li><p>稳定性：<strong>稳定</strong>。相等元素在排序过程中不会交换顺序。</p>
</li>
</ol>
<h4 id="折半排序"><a href="#折半排序" class="headerlink" title="折半排序"></a>折半排序</h4><h5 id="算法思想-1"><a href="#算法思想-1" class="headerlink" title="算法思想"></a>算法思想</h5><p>折半排序算法是<strong>插入排序算法</strong>的一种改进。通常，插入排序在插入新元素时需要从头到尾进行线性搜索，找到适当的位置。而<strong>折半插入排序</strong>通过在已排序的序列中使用<strong>二分查找</strong>（也称折半查找）来确定插入位置，从而减少比较次数。</p>
<p>折半插入排序的基本步骤如下：</p>
<ul>
<li><strong>排序过程</strong>与插入排序相似：依次将每个元素插入到前面已经排好序的子数组中。</li>
<li><strong>查找插入位置</strong>时使用二分查找法来代替逐一比较，从而减少查找的时间复杂度。</li>
</ul>
<h5 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">binaryInsertionSort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="type">int</span> key = arr[i];  <span class="comment">// 待插入的元素</span></span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = i - <span class="number">1</span>;   </span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;		<span class="comment">// 二分查找插入位置</span></span><br><span class="line">            <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (arr[mid] &gt; key)</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i - <span class="number">1</span>; j &gt;= left; j--) &#123;		<span class="comment">// 移动元素以腾出位置</span></span><br><span class="line">            arr[j + <span class="number">1</span>] = arr[j];</span><br><span class="line">        &#125;       </span><br><span class="line">        arr[left] = key;	 <span class="comment">// 插入元素</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="算法分析-1"><a href="#算法分析-1" class="headerlink" title="算法分析"></a>算法分析</h5><ol>
<li><p><strong>时间复杂度</strong></p>
<ul>
<li>最优时间复杂度：**O(n)**。当输入数组已经有序时，只需要找到正确位置而无需移动，查找时间为 <code>O(logn)</code>，但由于元素移动的过程仍然是线性的，所以最好的时间复杂度仍然是 <code>O(n²)</code>。虽然折半插入排序减少了比较次数，但由于元素插入时需要移动数据，其时间复杂度并没有降低太多。</li>
<li>最坏时间复杂度：**O(n²)**：当输入数组是逆序排列时，需要每次都将新元素插入到最前面，此时查找的复杂度为 <code>O(logn)</code>，但移动元素的复杂度为 <code>O(n)</code>，最坏的时间复杂度仍然是 <code>O(n²)</code>。</li>
<li>平均时间复杂度：**O(n²)**：查找和移动元素的综合开销不会大幅减少。</li>
</ul>
</li>
<li><p>空间复杂度：**O(1)**。插入排序只需要常量级的额外空间用于临时存储key变量。</p>
</li>
<li><p>稳定性：<strong>稳定</strong>。相等元素在排序过程中不会交换顺序。</p>
</li>
</ol>
<h4 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h4><h5 id="算法思想-2"><a href="#算法思想-2" class="headerlink" title="算法思想"></a>算法思想</h5><p>希尔排序（Shell Sort）是插入排序的一种优化版本，旨在减少数据移动次数来提高排序效率。希尔排序通过引入“<strong>增量分组</strong>”的方式，对原数组进行分组，使每组内部进行插入排序。随着增量的不断缩小，分组越来越少，直到增量缩小为1时，整个数组变为有序。</p>
<p>希尔排序的关键是<strong>增量序列</strong>的选择，常用的增量序列是<code>n/2, n/4, ..., 1</code>，即每次将间隔减半。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.png&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/Barbecue-g/imagehost/Language/C/C_%E6%8E%92%E5%BA%8F%E4%B8%8E%E6%9F%A5%E6%89%BE/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F.png" alt="希尔排序"></p>
<h5 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">shellSort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> gap = n / <span class="number">2</span>; gap &gt; <span class="number">0</span>; gap /= <span class="number">2</span>) &#123;		<span class="comment">// 初始间隔 gap 设为数组长度的一半，然后每次减半</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = gap; i &lt; n; i++) &#123;		<span class="comment">// 从 gap 开始逐步对每个子序列进行插入排序</span></span><br><span class="line">            <span class="type">int</span> temp = arr[i];  <span class="comment">// 保存当前元素</span></span><br><span class="line">            <span class="type">int</span> j;</span><br><span class="line">            <span class="keyword">for</span> (j = i; j &gt;= gap &amp;&amp; arr[j - gap] &gt; temp; j -= gap) &#123;<span class="comment">//将 arr[i] 插入到子序列中</span></span><br><span class="line">                arr[j] = arr[j - gap];  <span class="comment">// 将较大的元素后移</span></span><br><span class="line">            &#125;</span><br><span class="line">            arr[j] = temp;  <span class="comment">// 将当前元素放入正确位置</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="算法分析-2"><a href="#算法分析-2" class="headerlink" title="算法分析"></a>算法分析</h5><ol>
<li>时间复杂度：希尔排序的时间复杂度与增量序列的选择有关。常见的增量序列为 <code>n/2</code>, <code>n/4</code>, …, <code>1</code>。<ul>
<li><strong>最优情况：</strong> **O(nlogn)**。实际运行中常显著优于插入排序。</li>
<li><strong>最坏情况：</strong> **O(n²)**。使用更优化的增量序列（如Hibbard增量序列）时，最坏时间复杂度可以降低到 <code>O(n^3/2)</code> 或更低。</li>
<li><strong>平均时间复杂度：</strong> **O(n^1.3)**，具体取决于增量序列的选择。</li>
</ul>
</li>
<li>空间复杂度：<strong>O(1)<strong>。希尔排序是</strong>原地排序算法</strong>，不需要额外的存储空间。</li>
<li>稳定性：<strong>不稳定</strong>。相同元素在不同的增量分组时可能会被打乱其相对顺序。</li>
</ol>
<h3 id="交换排序"><a href="#交换排序" class="headerlink" title="交换排序"></a>交换排序</h3><h4 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h4><h5 id="算法思想-3"><a href="#算法思想-3" class="headerlink" title="算法思想"></a>算法思想</h5><p>通过多次遍历待排序的数组，每一轮比较相邻的两个元素，将较大的元素逐步“冒泡”到数组的末尾。整个过程重复进行，直到所有元素按从小到大的顺序排列。</p>
<p>具体步骤如下：</p>
<ul>
<li>从第一个元素开始，比较相邻的两个元素。</li>
<li>如果前一个元素比后一个大，则交换两者的位置。</li>
<li>每一轮遍历后，最大元素会移动到数组末尾。</li>
<li>重复上述步骤，直到所有元素有序。</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.png&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/Barbecue-g/imagehost/Language/C/C_%E6%8E%92%E5%BA%8F%E4%B8%8E%E6%9F%A5%E6%89%BE/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F.png" alt="冒泡排序"></p>
<h5 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">bubbleSort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> n)</span> &#123; </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;		<span class="comment">// 外层循环控制遍历的轮数       </span></span><br><span class="line">        <span class="type">int</span> swapped = <span class="number">0</span>;		<span class="comment">// 标志变量，检测本轮是否有元素交换</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n - i - <span class="number">1</span>; j++) &#123;		<span class="comment">// 内层循环比较相邻元素并交换</span></span><br><span class="line">            <span class="comment">// 如果前一个元素比后一个大，则交换</span></span><br><span class="line">            <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="type">int</span> temp = arr[j];</span><br><span class="line">                arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">                arr[j + <span class="number">1</span>] = temp;     </span><br><span class="line">                swapped = <span class="number">1</span>;		<span class="comment">// 标记有元素发生交换</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (swapped == <span class="number">0</span>) &#123;		<span class="comment">// 如果没有发生交换，说明数组已排序，提前结束</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="算法分析-3"><a href="#算法分析-3" class="headerlink" title="算法分析"></a>算法分析</h5><ol>
<li>时间复杂度：<ul>
<li><strong>最优情况（已排序的数组）：</strong> **O(n)**。数组本身就是有序的，冒泡排序只需进行一轮比较，无需交换。</li>
<li><strong>最坏情况（逆序数组）：</strong> **O(n²)**。在数组完全逆序的情况下，算法需要进行 <code>n-1</code> 轮排序，每轮排序需要 <code>n-1-i</code> 次比较和交换</li>
<li><strong>平均时间复杂度：</strong> **O(n²)**。大部分排序情况都需要多轮比较和交换。在没有特殊信息的情况下，平均情况下冒泡排序的时间复杂度仍为O(n²)。</li>
</ul>
</li>
<li>空间复杂度：<strong>O(1)<strong>。冒泡排序是</strong>原地排序算法</strong>，不需要额外的存储空间。</li>
<li>稳定性：<strong>稳定</strong>。相等元素在排序过程中不会交换顺序。</li>
</ol>
<h4 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h4><h5 id="算法思想-4"><a href="#算法思想-4" class="headerlink" title="算法思想"></a>算法思想</h5><p>快速排序（Quicksort）是一种<strong>分治法</strong>排序算法。其基本思想是：</p>
<ol>
<li>选择一个<strong>基准元素</strong>（Pivot），可以是数组的第一个元素、中间元素或随机选择。</li>
<li>将数组划分成两部分：<ul>
<li><strong>左部分</strong>包含所有小于基准元素的数；</li>
<li><strong>右部分</strong>包含所有大于基准元素的数。</li>
</ul>
</li>
<li>对左、右两部分递归地进行快速排序。</li>
<li>合并结果，即可得到一个有序数组。</li>
</ol>
<p><strong>关键步骤：</strong></p>
<ul>
<li>分区（Partition）：每次根据基准元素将数组分为两部分。</li>
<li>递归（Recursion）：对左右子数组分别进行快速排序。</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.png&quot;" data-lazy-src="https://github.com/Barbecue-g/Imagehost/blob/master/Language/C/C_%E6%8E%92%E5%BA%8F%E4%B8%8E%E6%9F%A5%E6%89%BE/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F.png?raw=true" alt="快速排序"></p>
<h5 id="代码实现-4"><a href="#代码实现-4" class="headerlink" title="代码实现"></a>代码实现</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 快速排序的分区函数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">partition</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> low, <span class="type">int</span> high)</span> &#123;</span><br><span class="line">    <span class="type">int</span> pivot = arr[high];  <span class="comment">// 选择最右边元素作为基准</span></span><br><span class="line">    <span class="type">int</span> i = low - <span class="number">1</span>;  <span class="comment">// i 是小于 pivot 的元素的索引</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = low; j &lt; high; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[j] &lt; pivot) &#123;  <span class="comment">// 若当前元素小于基准</span></span><br><span class="line">            i++;  <span class="comment">// 增加小于 pivot 区域的索引</span></span><br><span class="line">            <span class="comment">// 交换 arr[i] 和 arr[j]</span></span><br><span class="line">            <span class="type">int</span> temp = arr[i];</span><br><span class="line">            arr[i] = arr[j];</span><br><span class="line">            arr[j] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将基准元素放到正确的位置</span></span><br><span class="line">    <span class="type">int</span> temp = arr[i + <span class="number">1</span>];</span><br><span class="line">    arr[i + <span class="number">1</span>] = arr[high];</span><br><span class="line">    arr[high] = temp;</span><br><span class="line">    <span class="keyword">return</span> i + <span class="number">1</span>;  <span class="comment">// 返回基准的最终位置</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 快速排序函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">quickSort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> low, <span class="type">int</span> high)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (low &lt; high) &#123;       </span><br><span class="line">        <span class="type">int</span> pi = partition(arr, low, high);		<span class="comment">// 获取分区位置     </span></span><br><span class="line">        quickSort(arr, low, pi - <span class="number">1</span>);		<span class="comment">// 递归排序左半部分</span></span><br><span class="line">        quickSort(arr, pi + <span class="number">1</span>, high);		<span class="comment">// 递归排序右半部分</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="算法分析-4"><a href="#算法分析-4" class="headerlink" title="算法分析"></a>算法分析</h5><ol>
<li>时间复杂度：<ul>
<li><strong>最优情况：</strong> **O(nlogn)**。每次划分正好将数组一分为二。</li>
<li><strong>最坏情况：</strong> **O(n²)**。每次划分不平衡（如每次选择的基准恰好是数组的最大或最小值）</li>
<li><strong>平均时间复杂度：</strong> **O(nlogn)**。其中 <code>n</code> 是数组的元素个数，<code>logn</code> 是递归调用的层数。</li>
</ul>
</li>
<li>空间复杂度：<strong>O(nlogn)<strong>。快速排序是</strong>原地排序算法</strong>，递归调用栈的深度为 <code>logn</code>。最坏情况下，递归深度为 <code>O(n)</code>，最坏空间复杂度为 **O(n)**。</li>
<li>稳定性：<strong>不稳定</strong>。在划分过程中，可能会交换相同元素的相对位置。</li>
</ol>
<h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><h4 id="简单选择排序"><a href="#简单选择排序" class="headerlink" title="简单选择排序"></a>简单选择排序</h4><h5 id="算法思想-5"><a href="#算法思想-5" class="headerlink" title="算法思想"></a>算法思想</h5><p>在未排序的序列中找到最小（或最大）的元素，将其放到序列的起始位置。然后，继续在剩余未排序的序列中重复该操作，直到整个序列有序。</p>
<p>具体步骤如下：</p>
<p>​	1.	从未排序的部分中选择最小的元素。</p>
<p>​	2.	将该元素与未排序部分的第一个元素交换位置。</p>
<p>​	3.	重复上述过程，直到所有元素排序完毕。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.png&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/Barbecue-g/imagehost/Language/C/C_%E6%8E%92%E5%BA%8F%E4%B8%8E%E6%9F%A5%E6%89%BE/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F.png" alt="选择排序"></p>
<h5 id="代码实现-5"><a href="#代码实现-5" class="headerlink" title="代码实现"></a>代码实现</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">selectionSort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i, j, minIdx, temp;    </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;		<span class="comment">// 遍历数组中的每一个元素</span></span><br><span class="line">        minIdx = i;		<span class="comment">// 假设当前i位置的元素是未排序部分中的最小值   </span></span><br><span class="line">        <span class="keyword">for</span> (j = i + <span class="number">1</span>; j &lt; n; j++) &#123;		<span class="comment">// 在未排序的部分中寻找最小值</span></span><br><span class="line">            <span class="keyword">if</span> (arr[j] &lt; arr[minIdx]) &#123;</span><br><span class="line">                minIdx = j;  <span class="comment">// 记录最小值的索引</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">if</span> (minIdx != i) &#123;		<span class="comment">// 如果找到的最小值不是当前i位置的元素，则交换</span></span><br><span class="line">            <span class="comment">// 交换 arr[i] 和 arr[minIdx]</span></span><br><span class="line">            temp = arr[i];</span><br><span class="line">            arr[i] = arr[minIdx];</span><br><span class="line">            arr[minIdx] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="算法分析-5"><a href="#算法分析-5" class="headerlink" title="算法分析"></a>算法分析</h5><ol>
<li>时间复杂度：<ul>
<li><strong>最优情况（已排序的数组）：</strong> **O(n²)**。选择排序每次都需要遍历未排序部分的元素 ，最好情况也需要执行 <code>n</code> 次选择操作，每次操作时间为 O(n-i) 次比较</li>
<li><strong>最坏情况（逆序数组）：</strong> **O(n²)**。无论数据原始顺序如何，算法都需要遍历每一个元素。</li>
<li><strong>平均时间复杂度：</strong> **O(n²)**。由于选择排序与输入的顺序无关，每次都要遍历未排序部分。</li>
</ul>
</li>
<li>空间复杂度：<strong>O(nlogn)<strong>。选择排序是</strong>原地排序</strong>算法，只需要常量级的额外空间来存储临时变量（用于交换）。</li>
<li>稳定性：<strong>不稳定</strong>。选择排序在选择最小元素并交换时，可能会破坏原本的相对顺序。</li>
</ol>
<h4 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h4><h5 id="算法思想-6"><a href="#算法思想-6" class="headerlink" title="算法思想"></a>算法思想</h5><p>堆排序是一种基于<strong>二叉堆</strong>的数据结构的排序算法。堆是一种特殊的完全二叉树，可以分为<strong>最大堆</strong>和<strong>最小堆</strong>。在最大堆中，父节点的值总是大于等于其子节点的值；在最小堆中，父节点的值总是小于等于其子节点的值。</p>
<p>堆排序的基本思想是：</p>
<p>​	1.	<strong>构建最大堆</strong>：将无序数组调整为最大堆，使得堆顶元素（即根节点）为整个数组的最大值。</p>
<p>​	2.	<strong>交换堆顶元素和末尾元素</strong>：将堆顶元素（最大值）与堆的最后一个元素交换，最大元素就位于数组的最后，并从堆中移除。</p>
<p>​	3.	<strong>调整堆</strong>：对剩余的元素进行堆调整，重复上述步骤，直到所有元素有序。</p>
<h5 id="代码实现-6"><a href="#代码实现-6" class="headerlink" title="代码实现"></a>代码实现</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 堆调整函数：调整以 i 为根节点的子树，使其满足最大堆的性质</span></span><br><span class="line"><span class="comment">// n 是数组的长度，i 是当前根节点的索引</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">heapify</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> n, <span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="type">int</span> largest = i;     <span class="comment">// 初始化 largest 为根节点 i</span></span><br><span class="line">    <span class="type">int</span> left = <span class="number">2</span> * i + <span class="number">1</span>; <span class="comment">// 左子节点索引</span></span><br><span class="line">    <span class="type">int</span> right = <span class="number">2</span> * i + <span class="number">2</span>; <span class="comment">// 右子节点索引</span></span><br><span class="line">    <span class="comment">// 如果左子节点存在且大于根节点</span></span><br><span class="line">    <span class="keyword">if</span> (left &lt; n &amp;&amp; arr[left] &gt; arr[largest])</span><br><span class="line">        largest = left;</span><br><span class="line">    <span class="comment">// 如果右子节点存在且大于当前 largest</span></span><br><span class="line">    <span class="keyword">if</span> (right &lt; n &amp;&amp; arr[right] &gt; arr[largest])</span><br><span class="line">        largest = right;</span><br><span class="line">    <span class="comment">// 如果 largest 不是根节点</span></span><br><span class="line">    <span class="keyword">if</span> (largest != i) &#123;</span><br><span class="line">        <span class="comment">// 交换根节点和最大值节点</span></span><br><span class="line">        <span class="type">int</span> temp = arr[i];</span><br><span class="line">        arr[i] = arr[largest];</span><br><span class="line">        arr[largest] = temp;</span><br><span class="line">        <span class="comment">// 递归调整子树</span></span><br><span class="line">        heapify(arr, n, largest);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 堆排序函数：对数组 arr 进行堆排序</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">heapSort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="comment">// 构建最大堆</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        heapify(arr, n, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 逐步将堆顶元素（最大值）移动到数组末尾</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="comment">// 将堆顶元素与当前未排序部分的最后一个元素交换</span></span><br><span class="line">        <span class="type">int</span> temp = arr[<span class="number">0</span>];</span><br><span class="line">        arr[<span class="number">0</span>] = arr[i];</span><br><span class="line">        arr[i] = temp;</span><br><span class="line">        <span class="comment">// 调整剩余元素形成新的最大堆</span></span><br><span class="line">        heapify(arr, i, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="算法分析-6"><a href="#算法分析-6" class="headerlink" title="算法分析"></a>算法分析</h5><ul>
<li><strong>构建堆</strong>：构建最大堆的过程需要遍历所有非叶子节点，对每个节点进行堆调整。调整一个节点的时间复杂度为 <code>O(logn)</code>，总的构建堆时间复杂度为 <code>O(n)</code>。</li>
<li><strong>排序过程</strong>：在堆排序过程中，每次取出堆顶元素（最大值），然后对剩余的元素进行堆调整，整个排序过程需要进行 <code>n-1</code> 次堆调整，每次调整的时间复杂度为 <code>O(logn)</code>，总的排序时间复杂度为 <code>O(nlogn)</code>。</li>
</ul>
<ol>
<li><p>时间复杂度：</p>
<ul>
<li><p><strong>最坏情况：<code>O(nlogn)</code></strong></p>
</li>
<li><p><strong>平均情况：<code>O(nlogn)</code></strong></p>
</li>
<li><p><strong>最好情况：<code>O(nlogn)</code></strong></p>
</li>
</ul>
</li>
<li><p>空间复杂度：**O(1)**。 堆排序在排序过程中只需要常数级别的额外空间来进行交换操作和递归调用。</p>
</li>
<li><p>稳定性： <strong>不稳定</strong>。在堆调整过程中，元素之间的相对顺序可能会被改变。当父节点和子节点交换时，原本相同的两个元素可能会被打乱顺序。</p>
</li>
</ol>
<h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><h4 id="算法思想-7"><a href="#算法思想-7" class="headerlink" title="算法思想"></a>算法思想</h4><p>归并排序（Merge Sort）是一种<strong>分治算法</strong>。其核心思想是将待排序数组递归地<strong>分成两半</strong>，分别对左右两部分进行排序，最后将两部分<strong>合并</strong>成一个有序数组。</p>
<p><strong>分治步骤</strong>：</p>
<pre><code> 1.	**分**：将数组递归地分成两半，直到每个子数组只包含一个元素（此时认为子数组是有序的）。
 2.	**治**：将两个有序的子数组合并成一个有序数组。
 3.	**合并**：将小问题合并成大问题，最终将整个数组合并为一个有序数组。
</code></pre>
<p>归并排序的核心步骤是合并两个有序数组，过程是线性时间的。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.png&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/Barbecue-g/imagehost/Language/C/C_%E6%8E%92%E5%BA%8F%E4%B8%8E%E6%9F%A5%E6%89%BE/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F.png" alt="归并排序"></p>
<h4 id="代码实现-7"><a href="#代码实现-7" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 归并函数，将两个有序的子数组合并为一个有序数组</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> left, <span class="type">int</span> mid, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">    <span class="type">int</span> n1 = mid - left + <span class="number">1</span>;  <span class="comment">// 左边子数组的大小</span></span><br><span class="line">    <span class="type">int</span> n2 = right - mid;     <span class="comment">// 右边子数组的大小</span></span><br><span class="line">    <span class="comment">// 创建临时数组存储左右两部分</span></span><br><span class="line">    <span class="type">int</span> L[n1], R[n2];</span><br><span class="line">    <span class="comment">// 将数据复制到临时数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n1; i++)</span><br><span class="line">        L[i] = arr[left + i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n2; i++)</span><br><span class="line">        R[i] = arr[mid + <span class="number">1</span> + i];</span><br><span class="line">    <span class="comment">// 合并两个临时数组</span></span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>, k = left;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; n1 &amp;&amp; j &lt; n2) &#123;</span><br><span class="line">        <span class="keyword">if</span> (L[i] &lt;= R[j]) &#123;  <span class="comment">// 保证稳定性：左边元素 &lt;= 右边元素</span></span><br><span class="line">            arr[k] = L[i];</span><br><span class="line">            i++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            arr[k] = R[j];</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        k++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果左边还有剩余元素，直接复制</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt; n1) &#123;</span><br><span class="line">        arr[k] = L[i];</span><br><span class="line">        i++;</span><br><span class="line">        k++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果右边还有剩余元素，直接复制</span></span><br><span class="line">    <span class="keyword">while</span> (j &lt; n2) &#123;</span><br><span class="line">        arr[k] = R[j];</span><br><span class="line">        j++;</span><br><span class="line">        k++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 归并排序的递归函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">mergeSort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;  <span class="comment">// 计算中间点</span></span><br><span class="line">        <span class="comment">// 递归地对左右两部分进行排序</span></span><br><span class="line">        mergeSort(arr, left, mid);</span><br><span class="line">        mergeSort(arr, mid + <span class="number">1</span>, right);</span><br><span class="line">        <span class="comment">// 合并已排好序的两部分</span></span><br><span class="line">        merge(arr, left, mid, right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="算法分析-7"><a href="#算法分析-7" class="headerlink" title="算法分析"></a>算法分析</h4><ul>
<li><p>归并排序在最优、最坏和平均情况下的时间复杂度都是 **<code>O(nlog n)</code>**。其中 <code>n</code> 是数组的长度，<code>logn</code> 是由于递归分割数组的过程，<code>n</code> 是合并两个有序子数组的时间。</p>
<p>时间复杂度分析：</p>
<ul>
<li>归并排序的每一次分解步骤，都会将数组对半划分，整个过程为 <strong><code>O(log n)</code></strong>  次。</li>
<li>在每次划分后的合并步骤中，需要花费 <strong><code>O(n)</code></strong> 的时间来合并两个有序子数组。</li>
<li>总时间复杂度为 <code>O(nlogn)</code>。</li>
</ul>
</li>
</ul>
<ol>
<li><p>时间复杂度：</p>
<ul>
<li><p><strong>最坏情况：<code>O(nlogn)</code></strong></p>
</li>
<li><p><strong>平均情况：<code>O(nlogn)</code></strong></p>
</li>
<li><p><strong>最好情况：<code>O(nlogn)</code></strong></p>
</li>
</ul>
</li>
<li><p>空间复杂度：**O(n)**。归并排序的空间复杂度主要来自递归调用栈以及临时数组。每次递归调用会使用 <code>O(logn)</code> 的栈空间，而临时数组则需要 <code>O(n)</code> 的额外空间来存储子数组。</p>
</li>
<li><p>稳定性：<strong>稳定</strong>。排序时相等元素的相对位置不会改变。若两个元素相等，会优先将左边的元素放入结果数组。</p>
</li>
</ol>
<h3 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h3><h4 id="算法思想-8"><a href="#算法思想-8" class="headerlink" title="算法思想"></a>算法思想</h4><p>基数排序是一种非比较排序算法，基于“位”的思想来排序。它适合用于对整数或字符串等结构较为固定的对象进行排序。该算法的核心思想是将数据拆分成多个部分（如个位、十位、百位等），逐步对每一部分进行排序，最终得到有序的数据序列。基数排序有两种方式：</p>
<ul>
<li><p><strong>LSD（Least Significant Digit）</strong>：从最低位开始排序（常用于排序数字）。</p>
</li>
<li><p><strong>MSD（Most Significant Digit）</strong>：从最高位开始排序（常用于排序字符串等）。</p>
</li>
</ul>
<p>主要步骤如下：</p>
<ol>
<li>将数据按位（从最低位到最高位）进行分配。找出待排序数组中最大元素的位数。</li>
<li>从最低位开始，对数组元素按位排序，使用稳定的排序算法（如计数排序或桶排序）对各个位上的数进行排序。	</li>
<li>重复步骤2，直到最高位也排序完毕。</li>
</ol>
<p>基数排序的特点是，<strong>每一位上的排序必须是稳定的</strong>，才能保证排序的正确性。</p>
<h4 id="代码实现-8"><a href="#代码实现-8" class="headerlink" title="代码实现"></a>代码实现</h4><p>假设整数的范围是0到999，并且使用<strong>计数排序</strong>作为每一位的排序方法。主要包含核心的<code>radixSort</code>和辅助的计数排序<code>countSort</code>函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取数组中的最大值</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">getMax</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> max = arr[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] &gt; max) &#123;</span><br><span class="line">            max = arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 按照当前位数进行计数排序，exp 是对应的位数（1表示个位，10表示十位，依次类推）</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">countingSort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> n, <span class="type">int</span> <span class="built_in">exp</span>)</span> &#123;</span><br><span class="line">    <span class="type">int</span> output[n];  <span class="comment">// 输出数组</span></span><br><span class="line">    <span class="type">int</span> count[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;;  <span class="comment">// 计数数组，用来存储每个桶中的元素个数</span></span><br><span class="line">    <span class="comment">// 计算当前位数的出现次数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="type">int</span> digit = (arr[i] / <span class="built_in">exp</span>) % <span class="number">10</span>;</span><br><span class="line">        count[digit]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 修改计数数组，使其包含当前位数的正确位置</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        count[i] += count[i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 从后向前遍历数组，确保计数排序是稳定的</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="type">int</span> digit = (arr[i] / <span class="built_in">exp</span>) % <span class="number">10</span>;</span><br><span class="line">        output[count[digit] - <span class="number">1</span>] = arr[i];</span><br><span class="line">        count[digit]--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将排序结果复制回原数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        arr[i] = output[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 基数排序主函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">radixSort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="comment">// 找到数组中的最大数，以确定最大位数</span></span><br><span class="line">    <span class="type">int</span> max = getMax(arr, n);</span><br><span class="line">    <span class="comment">// 从个位开始，逐位对数组进行排序</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="built_in">exp</span> = <span class="number">1</span>; max / <span class="built_in">exp</span> &gt; <span class="number">0</span>; <span class="built_in">exp</span> *= <span class="number">10</span>) &#123;</span><br><span class="line">        countingSort(arr, n, <span class="built_in">exp</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="算法分析-8"><a href="#算法分析-8" class="headerlink" title="算法分析"></a>算法分析</h4><p>设数组中元素的最大值为<code>M</code>，数组的长度为<code>n</code>。最大值<code>M</code>的位数为<code>d</code>，每一位使用计数排序，其复杂度为<code>O(n + k)</code>，其中<code>k</code>为计数排序的范围（对10个数字的计数排序，<code>k=10</code>）。总时间复杂度为 <code>O(d*(n + k))</code> ，当<code>k</code>为常数时，复杂度为 <code>O(d*n)</code> 。</p>
<ul>
<li>对于整数来说，<code>d</code>通常较小，可以认为<code>d</code>为常数，基数排序的时间复杂度为**O(n)**。</li>
<li>元素范围较大，例如需要排序非常大的数字， <code>d</code> 会增大，算法的时间复杂度也会相应提高。</li>
</ul>
<ol>
<li><p>时间复杂度：</p>
<ul>
<li><p><strong>最坏情况：<code>O(n)</code></strong></p>
</li>
<li><p><strong>平均情况：<code>O(n)</code></strong></p>
</li>
<li><p><strong>最好情况：<code>O(n)</code></strong></p>
</li>
</ul>
</li>
<li><p>空间复杂度：**O(n+k)**。其中 <code>n</code> 是待排序元素的个数，<code>k</code> 是计数排序的桶数量。在本算法中，计数排序的桶数量是 <code>10</code>（对应十进制数的个位、十位、百位等），即线性空间复杂度。</p>
</li>
<li><p>稳定性：<strong>稳定</strong>。特别是在每一位的排序中使用稳定的排序算法（如计数排序）时，可以保证两个相同元素在排序前后的相对顺序不变。</p>
</li>
</ol>
<h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><h3 id="评估查找算法"><a href="#评估查找算法" class="headerlink" title="评估查找算法"></a>评估查找算法</h3><h4 id="时间复杂度-1"><a href="#时间复杂度-1" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><ul>
<li><strong>最坏情况时间复杂度</strong>：算法在最坏情况下的运行时间。例如，线性查找在最坏情况下需要 O(n)，而二分查找的最坏情况是 O(log n)。</li>
<li><strong>平均情况时间复杂度</strong>：评估算法在不同输入条件下的平均表现。平均情况下的算法性能。例如，哈希查找在没有冲突时，平均复杂度为 O(1)，而在发生冲突时复杂度升高。</li>
<li><strong>最优情况时间复杂度</strong>：算法在最理想的情况下的性能。例如，在二分查找中，若目标元素恰好是数组的中间值，查找时间为 O(1)。</li>
</ul>
<h4 id="空间复杂度-1"><a href="#空间复杂度-1" class="headerlink" title="空间复杂度"></a>空间复杂度</h4><ul>
<li><strong>额外空间需求</strong>：是否需要额外空间进行数据存储或处理。例如，线性查找不需要额外空间，复杂度为 O(1)，而哈希查找需要额外的空间来存储哈希表。</li>
<li><strong>辅助数据结构</strong>：某些查找算法依赖额外的数据结构，比如跳表或哈希表，需要额外的内存空间来存储索引或哈希值。</li>
</ul>
<h4 id="前提条件"><a href="#前提条件" class="headerlink" title="前提条件"></a>前提条件</h4><ul>
<li><strong>有序数据</strong>：算法是否需要数据有序，如二分查找，要求数据必须是已排序的。</li>
<li><strong>数据结构</strong>：不同查找算法适用于不同的数据结构。例如，哈希查找适用于哈希表，二分查找适用于有序数组，广度优先搜索（BFS）适用于图。</li>
<li><strong>动态数据集</strong>：某些查找算法更适合处理动态数据集，如跳表和哈希查找，而二分查找适用于静态有序数组。</li>
</ul>
<h4 id="鲁棒性"><a href="#鲁棒性" class="headerlink" title="鲁棒性"></a>鲁棒性</h4><ul>
<li><strong>最坏情况表现</strong>：算法在最坏情况下的效率。例如，哈希查找在最坏情况下退化到 O(n)（当哈希冲突严重时），而二分查找始终保持 O(log n)。</li>
<li><strong>容错能力</strong>：查找算法是否对异常输入（如空数组、数据不匹配）做了合理处理，防止崩溃或出错。</li>
<li><strong>抗数据分布能力</strong>：部分查找算法对数据分布较为敏感，如插值查找对均匀分布数据表现好，但对于不均匀分布的数据，性能下降明显。</li>
</ul>
<h4 id="稳定性-1"><a href="#稳定性-1" class="headerlink" title="稳定性"></a>稳定性</h4><ul>
<li><strong>动态数据处理能力</strong>：某些查找算法需要在数据动态变化时仍保持高效。例如，跳表在数据插入、删除时能保持较好的查找性能，时间复杂度是 O(log n)。</li>
<li><strong>重复元素的处理</strong>：查找算法是否能正确处理重复元素，如线性查找可以找到多个匹配项，但二分查找需要特殊处理以找到第一个或最后一个匹配元素。</li>
</ul>
<h3 id="线性查找"><a href="#线性查找" class="headerlink" title="线性查找"></a>线性查找</h3><h4 id="算法思想-9"><a href="#算法思想-9" class="headerlink" title="算法思想"></a>算法思想</h4><p>线性查找（Linear Search）核心思想是：从数组的第一个元素开始，依次检查每个元素，直到找到目标元素或数组末尾为止。线性查找适用于<strong>无序数组</strong>，不需要对数组进行排序。</p>
<h4 id="代码实现-9"><a href="#代码实现-9" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">linear_search</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> size, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="comment">// 遍历数组中的每一个元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">        <span class="comment">// 如果找到了目标值，返回其索引</span></span><br><span class="line">        <span class="keyword">if</span> (arr[i] == target) &#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果未找到目标值，返回 -1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="算法分析-9"><a href="#算法分析-9" class="headerlink" title="算法分析"></a>算法分析</h4><ol>
<li><p>时间复杂度：</p>
<ul>
<li>**最坏情况：<code>O(n)</code>**。在最坏的情况下（即目标元素在数组的末尾或者不存在），需要检查数组中的每一个元素。</li>
<li>**最好情况：<code>O(1)</code>**。在最好的情况下（即目标元素是数组的第一个元素），只需要一次比较。</li>
<li>**平均情况：<code>O(n)</code>**。目标元素可能在数组的任何位置，平均需要遍历数组的一半，即 <code>n/2</code> 次操作，时间复杂度仍然为 <code>O(n)</code>。</li>
</ul>
</li>
<li><p>空间复杂度：**O(1)**。该算法只使用了一个额外的整型变量（用于循环计数），空间复杂度与输入数据的大小无关。</p>
</li>
<li><p>前提条件：<strong>无序数组</strong>。线性查找不要求数组有序，适合在任何情况下使用。</p>
</li>
<li><p>鲁棒性：<strong>鲁棒性强</strong>。算法本身不会对数组的内容做任何假设。即使数组中包含重复值、负数、零等，线性查找仍然可以正常工作。</p>
</li>
<li><p>稳定性：<strong>稳定</strong>。特别是在每一位的排序中使用稳定的排序算法（如计数排序）时，可以保证两个相同元素在排序前后的相对顺序不变。</p>
</li>
</ol>
<h3 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h3><h4 id="算法思想-10"><a href="#算法思想-10" class="headerlink" title="算法思想"></a>算法思想</h4><p>二分查找（Binary Search）是一种在<strong>有序数组</strong>中查找目标值的高效算法。基本思想是：</p>
<ul>
<li>每次将查找范围缩小一半。</li>
<li>假设有一个有序数组，并想在其中查找一个特定元素。首先比较目标值与中间元素的大小：<ul>
<li>如果目标值等于中间元素，直接返回该元素的索引。</li>
<li>如果目标值小于中间元素，则只需继续在左半部分查找。</li>
<li>如果目标值大于中间元素，则只需继续在右半部分查找。</li>
</ul>
</li>
</ul>
<p>不断重复，直到找到目标值，或者查找范围缩小为空，表明目标值不存在。</p>
<h4 id="代码实现-10"><a href="#代码实现-10" class="headerlink" title="代码实现"></a>代码实现</h4><ol>
<li>循环实现</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">binarySearch</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> left, <span class="type">int</span> right, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">		<span class="keyword">while</span> (left &lt;= right) &#123;    </span><br><span class="line">        <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>; 		<span class="comment">// 计算中间索引 </span></span><br><span class="line">        <span class="keyword">if</span> (arr[mid] == target) &#123;		<span class="comment">// 如果目标值等于中间元素，返回索引</span></span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (arr[mid] &gt; target) &#123;		<span class="comment">// 如果目标值小于中间元素，继续在左半部分查找</span></span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">else</span> &#123;		<span class="comment">// 如果目标值大于中间元素，继续在右半部分查找</span></span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 未找到目标值，返回-1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>递归实现</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">bsearch</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> left, <span class="type">int</span> right, <span class="type">int</span> key)</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (left &gt; right) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">		<span class="comment">// 递归公式</span></span><br><span class="line">		<span class="type">int</span> mid = left + (right - left &gt;&gt; <span class="number">1</span>);</span><br><span class="line">		<span class="keyword">if</span> (key &lt; arr[mid]) <span class="keyword">return</span> bsearch(arr, left, mid - <span class="number">1</span>, key);</span><br><span class="line">		<span class="keyword">if</span> (key &gt; arr[mid]) <span class="keyword">return</span> bsearch(arr, mid + <span class="number">1</span>, right, key);</span><br><span class="line">		<span class="keyword">return</span> mid;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">binary_search</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> n, <span class="type">int</span> key)</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> bsearch(arr, <span class="number">0</span>, n - <span class="number">1</span>, key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="算法分析-10"><a href="#算法分析-10" class="headerlink" title="算法分析"></a>算法分析</h4><ol>
<li><p>时间复杂度：</p>
<ul>
<li>**最坏情况：<code>O(logn)</code>**。每次查找都会将范围缩小一半，需要进行的比较次数为 <code>log₂n</code> 次，时间复杂度为 <code>O(logn)</code>。</li>
<li>**最好情况：<code>O(1)</code>**。当目标值正好位于数组的中间位置时，只需进行一次比较即可找到目标值，此时复杂度为 <code>O(1)</code>。</li>
<li>**平均情况：<code>O(logn)</code>**。与最坏情况相同，平均情况下复杂度为 <code>O(logn)</code>。</li>
</ul>
</li>
<li><p>空间复杂度：**O(1)**。由于只使用了常数级别的额外变量（如 <code>left</code>、<code>right</code>、<code>mid</code>）。</p>
</li>
<li><p>前提条件：</p>
<ul>
<li><p><strong>数组有序</strong>：二分查找的前提是数组必须是有序的，若数组无序，算法无法正常工作。</p>
</li>
<li><p><strong>静态数组</strong>：二分查找适合用于静态数组，即数组元素在查找过程中不会改变。元素发生改变，需要先重新排序。</p>
</li>
</ul>
</li>
<li><p>鲁棒性：</p>
<ul>
<li><p><strong>目标值不存在的情况</strong>：目标值不在数组中，算法最终会将查找范围缩小至无效的区间（<code>left &gt; right</code>），此时返回 <code>-1</code>，表示未找到目标值。</p>
</li>
<li><p><strong>数组为空</strong>：在调用函数时，数组为空（<code>right &lt; left</code>），算法会直接返回 <code>-1</code>。</p>
</li>
</ul>
</li>
<li><p>稳定性：<strong>不稳定</strong>。无法保证对于重复出现的元素总是返回第一个出现的索引。</p>
</li>
</ol>
<h3 id="跳表"><a href="#跳表" class="headerlink" title="跳表"></a>跳表</h3><h4 id="算法思想-11"><a href="#算法思想-11" class="headerlink" title="算法思想"></a>算法思想</h4><p>跳表（Skip List）是一种<strong>基于链表的数据结构</strong>。其核心思想是是在链表上建立多层“跳跃”索引，每层索引中的元素是下层链表的子集，索引层数越高包含的元素越少。</p>
<p><strong>跳表特点</strong>：</p>
<ol>
<li>跳表的结构是多级链表，最低层是原始链表，上面的每一层是索引链表；</li>
<li>查找、插入和删除操作依赖于索引，通过逐层查找可以减少比较次数，进而提高效率；</li>
<li>跳表的随机层数决定了效率，可以通过随机函数控制索引的生成。</li>
</ol>
<h4 id="代码实现-11"><a href="#代码实现-11" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义跳表的最大层数</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_LEVEL 16</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> P 0.5  <span class="comment">// 跳表中元素晋升的概率</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 跳表节点定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">SkipListNode</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">SkipListNode</span> *<span class="title">forward</span>[];</span>  <span class="comment">// 指向各层的前进指针数组</span></span><br><span class="line">&#125; SkipListNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 跳表定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">SkipList</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> level;                      <span class="comment">// 当前跳表的最大层数</span></span><br><span class="line">    SkipListNode *header;           <span class="comment">// 跳表的头节点</span></span><br><span class="line">&#125; SkipList;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建节点</span></span><br><span class="line">SkipListNode *<span class="title function_">createNode</span><span class="params">(<span class="type">int</span> level, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">    SkipListNode *node = (SkipListNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(SkipListNode) + level * <span class="keyword">sizeof</span>(SkipListNode *));</span><br><span class="line">    node-&gt;value = value;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建跳表</span></span><br><span class="line">SkipList *<span class="title function_">createSkipList</span><span class="params">()</span> &#123;</span><br><span class="line">    SkipList *<span class="built_in">list</span> = (SkipList *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(SkipList));</span><br><span class="line">    <span class="built_in">list</span>-&gt;level = <span class="number">0</span>;  <span class="comment">// 初始时，跳表层数为 0</span></span><br><span class="line">    <span class="built_in">list</span>-&gt;header = createNode(MAX_LEVEL, <span class="number">0</span>);  <span class="comment">// 创建头节点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; MAX_LEVEL; i++) &#123;</span><br><span class="line">        <span class="built_in">list</span>-&gt;header-&gt;forward[i] = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">list</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成随机层数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">randomLevel</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> level = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (((<span class="type">double</span>)rand() / RAND_MAX) &lt; P &amp;&amp; level &lt; MAX_LEVEL) &#123;</span><br><span class="line">        level++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> level;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找操作</span></span><br><span class="line">SkipListNode *<span class="title function_">search</span><span class="params">(SkipList *<span class="built_in">list</span>, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">    SkipListNode *x = <span class="built_in">list</span>-&gt;header;</span><br><span class="line">    <span class="comment">// 从最高层往低层查找</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="built_in">list</span>-&gt;level - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">while</span> (x-&gt;forward[i] &amp;&amp; x-&gt;forward[i]-&gt;value &lt; value) &#123;</span><br><span class="line">            x = x-&gt;forward[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    x = x-&gt;forward[<span class="number">0</span>];  <span class="comment">// 到达底层后，前进到下一个节点</span></span><br><span class="line">    <span class="keyword">if</span> (x &amp;&amp; x-&gt;value == value) &#123;</span><br><span class="line">        <span class="keyword">return</span> x;  <span class="comment">// 找到目标节点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;  <span class="comment">// 未找到</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入操作</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">insert</span><span class="params">(SkipList *<span class="built_in">list</span>, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">    SkipListNode *update[MAX_LEVEL];  <span class="comment">// 记录更新路径</span></span><br><span class="line">    SkipListNode *x = <span class="built_in">list</span>-&gt;header;</span><br><span class="line">    <span class="comment">// 从最高层往低层查找插入位置</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="built_in">list</span>-&gt;level - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">while</span> (x-&gt;forward[i] &amp;&amp; x-&gt;forward[i]-&gt;value &lt; value) &#123;</span><br><span class="line">            x = x-&gt;forward[i];</span><br><span class="line">        &#125;</span><br><span class="line">        update[i] = x;  <span class="comment">// 记录每一层的最后节点</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> level = randomLevel();  <span class="comment">// 生成该节点的随机层数</span></span><br><span class="line">    <span class="keyword">if</span> (level &gt; <span class="built_in">list</span>-&gt;level) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="built_in">list</span>-&gt;level; i &lt; level; i++) &#123;</span><br><span class="line">            update[i] = <span class="built_in">list</span>-&gt;header;  <span class="comment">// 新层初始化</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">list</span>-&gt;level = level;  <span class="comment">// 更新跳表的层数</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建新节点并插入</span></span><br><span class="line">    x = createNode(level, value);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; level; i++) &#123;</span><br><span class="line">        x-&gt;forward[i] = update[i]-&gt;forward[i];</span><br><span class="line">        update[i]-&gt;forward[i] = x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除操作</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">delete</span><span class="params">(SkipList *<span class="built_in">list</span>, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">    SkipListNode *update[MAX_LEVEL];</span><br><span class="line">    SkipListNode *x = <span class="built_in">list</span>-&gt;header;</span><br><span class="line">    <span class="comment">// 从最高层往低层查找删除位置</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="built_in">list</span>-&gt;level - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">while</span> (x-&gt;forward[i] &amp;&amp; x-&gt;forward[i]-&gt;value &lt; value) &#123;</span><br><span class="line">            x = x-&gt;forward[i];</span><br><span class="line">        &#125;</span><br><span class="line">        update[i] = x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    x = x-&gt;forward[<span class="number">0</span>];  <span class="comment">// 到达底层</span></span><br><span class="line">    <span class="keyword">if</span> (x &amp;&amp; x-&gt;value == value) &#123;</span><br><span class="line">        <span class="comment">// 更新每一层的前进指针，删除节点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">list</span>-&gt;level; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (update[i]-&gt;forward[i] != x) <span class="keyword">break</span>;</span><br><span class="line">            update[i]-&gt;forward[i] = x-&gt;forward[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">free</span>(x);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查并更新跳表的层数</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">list</span>-&gt;level &gt; <span class="number">0</span> &amp;&amp; <span class="built_in">list</span>-&gt;header-&gt;forward[<span class="built_in">list</span>-&gt;level - <span class="number">1</span>] == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="built_in">list</span>-&gt;level--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="算法分析-11"><a href="#算法分析-11" class="headerlink" title="算法分析"></a>算法分析</h4><ol>
<li><p>时间复杂度：</p>
<ul>
<li><strong>查找操作</strong>：跳表的查找过程是从上层逐级往下查找，每一层的节点数期望是上一层的一半。查找的平均时间复杂度为 **O(log n)**，最坏情况下退化为 **O(n)**（所有元素都在最低层）。</li>
<li><strong>插入操作</strong>：插入操作需要找到插入位置，然后插入新节点。和查找过程类似，平均时间复杂度为 **O(log n)**。</li>
<li><strong>删除操作</strong>：删除操作与查找过程相似，找到要删除的节点，修改前驱节点的指针。平均时间复杂度为 **O(log n)**。</li>
</ul>
</li>
<li><p>空间复杂度：**O(n)**。跳表需要为每个节点维护多层索引，索引的层数是随机生成的。平均情况下，跳表每一层的节点数量是前一层的 <strong>1&#x2F;2</strong>。</p>
</li>
<li><p>前提条件：</p>
<ul>
<li>跳表是一种有序的数据结构，节点的值必须具有可比较性（例如整数、浮点数、字符串等可排序类型）。</li>
<li>跳表在设计上依赖于随机层数的生成，随机数生成器需要良好表现，不能总是生成过大的层数或过小的层数。</li>
</ul>
</li>
<li><p>鲁棒性：</p>
<ul>
<li>跳表的插入和删除操作依赖于随机层数生成，跳表的性能在实际运行时会有一定波动。虽然最坏情况下跳表的时间复杂度为 **O(n)**，但平均情况较好，能保持 **O(log n)**。</li>
<li>跳表的鲁棒性体现在它可以通过随机层数来避免复杂的平衡操作，不像红黑树等需要严格的平衡调整。</li>
</ul>
</li>
<li><p>稳定性：</p>
<ul>
<li><p><strong>查找的稳定性</strong>：跳表的查找操作是确定的，即使数据随机插入，只要结构不发生变化，多次查找同一个值的结果一致，因此跳表的查找操作是稳定的。</p>
</li>
<li><p><strong>插入&#x2F;删除的稳定性</strong>：由于跳表中的元素插入是基于随机层数生成的，插入和删除的效率会有所波动，但总体是稳定的。</p>
</li>
</ul>
</li>
</ol>
<h3 id="哈希查找"><a href="#哈希查找" class="headerlink" title="哈希查找"></a>哈希查找</h3><h4 id="算法思想-12"><a href="#算法思想-12" class="headerlink" title="算法思想"></a>算法思想</h4><p>哈希查找（Hashing）是一种通过键值（Key）来直接访问数据的方法，其核心思想是将元素的存储位置和键值通过一个哈希函数关联起来，将关键字映射到数组中的一个位置，然后通过数组的下标直接找到对应的值。</p>
<ul>
<li><strong>哈希函数（Hash Function）</strong>：负责将键值转换为数组索引。一个好的哈希函数应具有均匀性和简单性，避免大量冲突。</li>
<li><strong>哈希表（Hash Table）</strong>：利用数组实现的，存储元素的位置通过哈希函数计算得出。</li>
<li><strong>冲突处理</strong>：当两个不同的键值通过哈希函数得到相同的数组索引时，称为“冲突”。常用的冲突解决方法有开放地址法和链地址法。</li>
</ul>
<h4 id="代码实现-12"><a href="#代码实现-12" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 哈希表的最大容量</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TABLE_SIZE 100</span></span><br><span class="line"><span class="comment">// 定义哈希表</span></span><br><span class="line"><span class="type">int</span> hashTable[TABLE_SIZE];</span><br><span class="line"><span class="comment">// 初始化哈希表，所有位置设置为-1表示空</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">initHashTable</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; TABLE_SIZE; i++) &#123;</span><br><span class="line">        hashTable[i] = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 简单的哈希函数，将键值转换为数组索引</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">hashFunction</span><span class="params">(<span class="type">int</span> key)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> key % TABLE_SIZE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 插入键值</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">insert</span><span class="params">(<span class="type">int</span> key)</span> &#123;</span><br><span class="line">    <span class="type">int</span> index = hashFunction(key);  <span class="comment">// 计算哈希值</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 线性探测，处理冲突</span></span><br><span class="line">    <span class="keyword">while</span> (hashTable[index] != <span class="number">-1</span>) &#123;</span><br><span class="line">        index = (index + <span class="number">1</span>) % TABLE_SIZE;  <span class="comment">// 向后探测下一个位置</span></span><br><span class="line">    &#125;</span><br><span class="line">    hashTable[index] = key;  <span class="comment">// 插入键值</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 查找键值</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span> key)</span> &#123;</span><br><span class="line">    <span class="type">int</span> index = hashFunction(key);  <span class="comment">// 计算哈希值</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 线性探测查找，处理冲突</span></span><br><span class="line">    <span class="keyword">while</span> (hashTable[index] != <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (hashTable[index] == key) &#123;</span><br><span class="line">            <span class="keyword">return</span> index;  <span class="comment">// 找到键值，返回位置</span></span><br><span class="line">        &#125;</span><br><span class="line">        index = (index + <span class="number">1</span>) % TABLE_SIZE;  <span class="comment">// 向后探测下一个位置</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;  <span class="comment">// 未找到，返回-1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 删除键值</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">delete</span><span class="params">(<span class="type">int</span> key)</span> &#123;</span><br><span class="line">    <span class="type">int</span> index = search(key);  <span class="comment">// 查找键值所在位置</span></span><br><span class="line">    <span class="keyword">if</span> (index != <span class="number">-1</span>) &#123;</span><br><span class="line">        hashTable[index] = <span class="number">-1</span>;  <span class="comment">// 将对应位置设为空</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="算法分析-12"><a href="#算法分析-12" class="headerlink" title="算法分析"></a>算法分析</h4><ol>
<li><p>时间复杂度：</p>
<ul>
<li>**最坏情况：<code>O(n)</code>**。当发生大量冲突时，最坏情况下时间复杂度为 <code>O(n)</code> ，例如所有键值都映射到相同位置时，需要线性探测整个数组。</li>
<li>**最好情况：<code>O(1)</code>**。理想情况下，通过哈希函数能直接定位。</li>
<li>**平均情况：<code>O(1)</code>**。插入、查找和删除的平均时间复杂度为 <code>O(1)</code> ，理想情况下，通过哈希函数能直接定位。</li>
</ul>
</li>
<li><p>空间复杂度：**O(n)**。哈希表的空间复杂度为 <code>O(n)</code>，其中 <code>n</code> 是哈希表的大小。</p>
</li>
<li><p>前提条件：</p>
<ul>
<li><p>哈希函数应设计合理，尽量均匀分布键值，避免产生大量冲突。</p>
</li>
<li><p>表的大小应适当，通常选择一个比实际存储量略大的素数以减少冲突。</p>
</li>
</ul>
</li>
<li><p>鲁棒性：</p>
<ul>
<li><p><strong>目标值不存在的情况</strong>：对于不存在的元素，查找函数能返回 -1，表示未找到，具有良好的鲁棒性。</p>
</li>
<li><p>插入函数能自动处理冲突，避免覆盖已有数据。</p>
</li>
</ul>
</li>
<li><p>稳定性：<strong>不稳定</strong>。元素的插入和查找顺序不依赖于元素的原始顺序。</p>
</li>
</ol>
<h3 id="深度优先搜索"><a href="#深度优先搜索" class="headerlink" title="深度优先搜索"></a>深度优先搜索</h3><h4 id="算法思想-13"><a href="#算法思想-13" class="headerlink" title="算法思想"></a>算法思想</h4><p>深度优先搜索（Depth First Search, DFS）是一种遍历或搜索图或树数据结构的算法。其基本思想是沿着一个分支不断向前深入，直到找到目标或到达叶子节点。每当到达一个节点时，如果该节点的所有相邻节点都已经访问过或不可达，算法会回溯到上一个节点继续搜索未访问的相邻节点，直到所有节点都被访问。</p>
<p>DFS使用的是“栈”的思想（可以通过递归或显式使用栈结构来实现），即先探到最深处，然后逐步回溯。</p>
<h4 id="代码实现-13"><a href="#代码实现-13" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_NODES 100</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 图的邻接矩阵表示</span></span><br><span class="line"><span class="type">int</span> graph[MAX_NODES][MAX_NODES]; <span class="comment">// 图的邻接矩阵</span></span><br><span class="line"><span class="type">int</span> visited[MAX_NODES]; <span class="comment">// 标记节点是否已访问</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 深度优先搜索算法实现</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">DFS</span><span class="params">(<span class="type">int</span> node, <span class="type">int</span> num_nodes)</span> &#123;</span><br><span class="line">    visited[node] = <span class="number">1</span>; <span class="comment">// 标记当前节点为已访问</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历所有相邻节点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; num_nodes; i++) &#123;</span><br><span class="line">        <span class="comment">// 如果有相邻节点且未访问，继续深入</span></span><br><span class="line">        <span class="keyword">if</span> (graph[node][i] == <span class="number">1</span> &amp;&amp; !visited[i]) &#123;</span><br><span class="line">            DFS(i, num_nodes); <span class="comment">// 递归调用</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>graph</code> 是图的邻接矩阵，<code>graph[i][j] = 1</code> 表示节点 <code>i</code> 与节点 <code>j</code> 相连。</p>
</li>
<li><p><code>visited[i]</code> 用于标记节点是否已经被访问，以避免重复遍历。</p>
</li>
<li><p><code>DFS</code> 函数中，通过递归实现了从某个节点开始的深度优先搜索。</p>
</li>
</ul>
<h4 id="算法分析-13"><a href="#算法分析-13" class="headerlink" title="算法分析"></a>算法分析</h4><ol>
<li><p>时间复杂度：DFS的时间复杂度取决于图的表示方式，总的来说，DFS对稀疏图（边较少）和稠密图（边较多）都具有良好的性能表现。</p>
<ul>
<li><strong>邻接矩阵</strong>： <strong><code>O(V^2)</code></strong> ，其中 <code>V</code> 是图中节点数。</li>
<li><strong>邻接表</strong>： <strong><code>O(V+E)</code></strong> ，其中 <code>E</code> 是图中边的数量。</li>
</ul>
</li>
<li><p>空间复杂度：空间复杂度主要由递归栈占用</p>
<ul>
<li><strong>邻接矩阵</strong>： <strong><code>O(V)</code></strong> ，其中 <code>V</code> 是图中节点数。</li>
<li><strong>邻接表</strong>： <strong><code>O(V^2)</code></strong> ，其中 <code>V</code> 是图中节点数。</li>
</ul>
</li>
<li><p>前提条件：</p>
<ul>
<li>图可以是连通或非连通图。</li>
<li>适用于无向图和有向图。</li>
<li>对于递归实现，要求系统栈空间足够大，适合节点数量较小的图。如果图的节点非常多，递归深度过大可能会导致栈溢出，建议改用非递归方式（例如使用栈模拟递归）。</li>
</ul>
</li>
<li><p>鲁棒性：</p>
<ul>
<li>需要考虑边界情况，例如图为空（没有节点或边）、只有一个节点、图不连通等特殊情况。</li>
<li>需要处理节点数组越界、空指针等异常。</li>
</ul>
</li>
<li><p>稳定性：<strong>不稳定</strong>。不同的执行顺序可能会导致不同的遍历路径，取决于邻接节点的访问顺序。</p>
</li>
</ol>
<h3 id="广度优先搜索"><a href="#广度优先搜索" class="headerlink" title="广度优先搜索"></a>广度优先搜索</h3><h4 id="算法思想-14"><a href="#算法思想-14" class="headerlink" title="算法思想"></a>算法思想</h4><p>广度优先搜索（Breadth First Search, BFS）是一种图遍历算法，通常用于无权图最短路径问题、连通分量搜索等问题。其基本思想是：从起始节点开始，先访问所有相邻节点，然后再逐层向外扩展，直到目标节点被访问或所有节点都被遍历完。</p>
<p>BFS 使用队列（Queue）来维护当前层级的节点，并确保节点按层级顺序访问。每次从队列中取出一个节点，访问其所有未访问的邻节点，将它们加入队列。</p>
<h4 id="代码实现-14"><a href="#代码实现-14" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_VERTICES 100</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 队列结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> items[MAX_VERTICES];</span><br><span class="line">    <span class="type">int</span> front;</span><br><span class="line">    <span class="type">int</span> rear;</span><br><span class="line">&#125; Queue;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化队列</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">initQueue</span><span class="params">(Queue* q)</span> &#123;</span><br><span class="line">    q-&gt;front = <span class="number">-1</span>;</span><br><span class="line">    q-&gt;rear = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断队列是否为空</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">isEmpty</span><span class="params">(Queue* q)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> q-&gt;front == <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 入队</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">enqueue</span><span class="params">(Queue* q, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (q-&gt;rear == MAX_VERTICES - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;  <span class="comment">// 队列满了</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (q-&gt;front == <span class="number">-1</span>) &#123;</span><br><span class="line">            q-&gt;front = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        q-&gt;rear++;</span><br><span class="line">        q-&gt;items[q-&gt;rear] = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 出队</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">dequeue</span><span class="params">(Queue* q)</span> &#123;</span><br><span class="line">    <span class="type">int</span> item;</span><br><span class="line">    <span class="keyword">if</span> (isEmpty(q)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;  <span class="comment">// 队列为空</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        item = q-&gt;items[q-&gt;front];</span><br><span class="line">        q-&gt;front++;</span><br><span class="line">        <span class="keyword">if</span> (q-&gt;front &gt; q-&gt;rear) &#123;</span><br><span class="line">            q-&gt;front = q-&gt;rear = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> item;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 广度优先搜索算法</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">BFS</span><span class="params">(<span class="type">int</span> graph[MAX_VERTICES][MAX_VERTICES], <span class="type">int</span> startVertex, <span class="type">int</span> numVertices)</span> &#123;</span><br><span class="line">    Queue q;</span><br><span class="line">    initQueue(&amp;q);</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> visited[MAX_VERTICES] = &#123;<span class="literal">false</span>&#125;;  <span class="comment">// 标记每个节点是否访问过</span></span><br><span class="line">    visited[startVertex] = <span class="literal">true</span>;</span><br><span class="line">    enqueue(&amp;q, startVertex);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!isEmpty(&amp;q)) &#123;</span><br><span class="line">        <span class="type">int</span> currentVertex = dequeue(&amp;q);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;访问节点 %d\n&quot;</span>, currentVertex);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历当前节点的所有邻接节点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numVertices; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (graph[currentVertex][i] == <span class="number">1</span> &amp;&amp; !visited[i]) &#123;</span><br><span class="line">                visited[i] = <span class="literal">true</span>;  <span class="comment">// 标记为已访问</span></span><br><span class="line">                enqueue(&amp;q, i);  <span class="comment">// 将邻接节点加入队列</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="算法分析-14"><a href="#算法分析-14" class="headerlink" title="算法分析"></a>算法分析</h4><ol>
<li><p>时间复杂度： <strong>O(V + E)<strong>，其中，</strong>V</strong> 是顶点的数量，<strong>E</strong> 是边的数量。在最坏情况下，BFS 需要遍历每个顶点和与其相连的每条边。</p>
</li>
<li><p>空间复杂度：存储图的邻接矩阵和队列。</p>
<ul>
<li><strong>队列</strong>：最多存储所有顶点，即 O(V)。</li>
<li><strong>访问标记数组</strong>：存储每个顶点的访问状态，也是 O(V)。</li>
</ul>
</li>
<li><p>前提条件：</p>
<ul>
<li><strong>图的存储方式</strong>：本实现使用邻接矩阵表示图，因此适用于稠密图。如果图是稀疏的，可以改用邻接表来优化空间复杂度。</li>
<li><strong>输入合法性</strong>：输入的图应是连通图（探索全图），并且顶点的索引应合法。</li>
</ul>
</li>
<li><p>鲁棒性：</p>
<ul>
<li><p><strong>队列溢出检测</strong>：本代码中检查了队列是否满，但没有处理队列溢出的错误处理机制（如扩展队列容量）。对于大图来说，需要更鲁棒的动态队列实现。</p>
<p><strong>图遍历的边界处理</strong>：该算法可以处理连通图和非连通图，但要确保输入的顶点索引在有效范围内（即 [0, numVertices-1] 之间）。</p>
</li>
</ul>
</li>
<li><p>稳定性：<strong>稳定</strong>。按照层级顺序依次访问每个顶点，保证在最短路径问题中，较早访问的顶点优先处理，不会跳跃式访问。</p>
</li>
</ol>
</article><div class="post-copyright"><div class="copyright-cc-box"><i class="anzhiyufont anzhiyu-icon-copyright"></i></div><div class="post-copyright__author_box"><a class="post-copyright__author_img" href="/" title="头像"><img class="post-copyright__author_img_back" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.png&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/Barbecue-g/imagehost/Hexo/avatar.jpg?raw=true" title="头像" alt="头像"><img class="post-copyright__author_img_front" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.png&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/Barbecue-g/imagehost/Hexo/avatar.jpg?raw=true" title="头像" alt="头像"></a><div class="post-copyright__author_name">Barbecue</div><div class="post-copyright__author_desc">今天学习了吗</div></div><div class="post-copyright__post__info"><a class="post-copyright__original" title="该文章为原创文章，注意版权协议" href="https://barbecue-g.github.io/">原创</a><a class="post-copyright-title"><span onclick="rm.copyPageUrl('https://barbecue-g.github.io/')">C_排序与查找</span></a></div><div class="post-tools" id="post-tools"><div class="post-tools-left"><div class="rewardLeftButton"><div class="post-reward" onclick="anzhiyu.addRewardMask()"><div class="reward-button button--animated" title="赞赏作者"><i class="anzhiyufont anzhiyu-icon-hand-heart-fill"></i>打赏作者</div><div class="reward-main"><div class="reward-all"><span class="reward-title">感谢你赐予我前进的力量</span><ul class="reward-group"><li class="reward-item"><a href="https://cdn.jsdelivr.net/gh/Barbecue-g/imagehost/Hexo/wechatpay.jpg" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.png&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/Barbecue-g/imagehost/Hexo/wechatpay.jpg" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://cdn.jsdelivr.net/gh/Barbecue-g/imagehost/Hexo/alipay.jpg" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.png&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/Barbecue-g/imagehost/Hexo/alipay.jpg" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div></div><div id="quit-box" onclick="anzhiyu.removeRewardMask()" style="display: none"></div></div><div class="shareRight"><div class="share-link mobile"><div class="share-qrcode"><div class="share-button" title="使用手机访问这篇文章"><i class="anzhiyufont anzhiyu-icon-qrcode"></i></div><div class="share-main"><div class="share-main-all"><div id="qrcode" title="https://barbecue-g.github.io/"></div><div class="reward-dec">使用手机访问这篇文章</div></div></div></div></div><div class="share-link weibo"><a class="share-button" target="_blank" href="https://service.weibo.com/share/share.php?title=C_排序与查找&amp;url=https://barbecue-g.github.io/&amp;pic=https://cdn.jsdelivr.net/gh/Barbecue-g/imagehost/Hexo/0.jpg" rel="external nofollow noreferrer noopener"><i class="anzhiyufont anzhiyu-icon-weibo"></i></a></div><script>function copyCurrentPageUrl() {
  var currentPageUrl = window.location.href;
  var input = document.createElement("input");
  input.setAttribute("value", currentPageUrl);
  document.body.appendChild(input);
  input.select();
  input.setSelectionRange(0, 99999);
  document.execCommand("copy");
  document.body.removeChild(input);
}</script><div class="share-link copyurl"><div class="share-button" id="post-share-url" title="复制链接" onclick="copyCurrentPageUrl()"><i class="anzhiyufont anzhiyu-icon-link"></i></div></div></div></div></div><div class="post-copyright__notice"><span class="post-copyright-info">此文章版权归Barbeuce所有，如有转载，请注明明来自原作者</span></div></div><div class="post-tools-right"><div class="tag_share"><div class="post-meta__box"><div class="post-meta__box__category-list"><a class="post-meta__box__categoryes" href="/categories/C/"><span class="categoryes-punctuation"> <i class="anzhiyufont anzhiyu-icon-inbox"></i></span>C<span class="categoryesPageCount">15</span></a></div><div class="post-meta__box__tag-list"><a class="post-meta__box__tags" href="/tags/C/"><span class="tags-punctuation"> <i class="anzhiyufont anzhiyu-icon-tag"></i></span>C<span class="tagsPageCount">15</span></a></div></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/Barbecue-g/imagehost/Hexo/0.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"/><script src="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer="defer"></script></div></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/Language/C/C_%E6%95%B0%E7%BB%84"><img class="prev-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.png&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/Barbecue-g/imagehost/Language/C/C-icon.png" onerror="onerror=null;src='/img/404.png'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">C_数组</div></div></a></div><div class="next-post pull-right"><a href="/Language/C/C_%E6%8C%87%E9%92%88%E7%9A%84%E5%BA%94%E7%94%A8"><img class="next-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.png&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/Barbecue-g/imagehost/Language/C/C-icon.png" onerror="onerror=null;src='/img/404.png'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">C_指针的应用</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="anzhiyufont anzhiyu-icon-thumbs-up fa-fw" style="font-size: 1.5rem; margin-right: 4px"></i><span>喜欢这篇文章的人也看了</span></div><div class="relatedPosts-list"><div><a href="/Language/C/C_%E5%8E%86%E5%8F%B2" title="C_历史"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.png&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/Barbecue-g/imagehost/Language/C/C-icon.png" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-history fa-fw"></i> 2024-09-28</div><div class="title">C_历史</div></div></a></div><div><a href="/Language/C/C_%E5%87%BD%E6%95%B0" title="C_函数"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.png&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/Barbecue-g/imagehost/Language/C/C-icon.png" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-history fa-fw"></i> 2024-09-28</div><div class="title">C_函数</div></div></a></div><div><a href="/Language/C/C_%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B" title="C_基本数据类型"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.png&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/Barbecue-g/imagehost/Language/C/C-icon.png" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-history fa-fw"></i> 2024-09-28</div><div class="title">C_基本数据类型</div></div></a></div><div><a href="/Language/C/C_%E5%AD%97%E7%AC%A6%E4%B8%B2" title="C_字符串"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.png&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/Barbecue-g/imagehost/Language/C/C-icon.png" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-history fa-fw"></i> 2024-09-28</div><div class="title">C_字符串</div></div></a></div><div><a href="/Language/C/C_%E6%8C%87%E9%92%88" title="C_指针"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.png&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/Barbecue-g/imagehost/Language/C/C-icon.png" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-history fa-fw"></i> 2024-09-28</div><div class="title">C_指针</div></div></a></div><div><a href="/Language/C/C_%E6%8C%87%E9%92%88%E7%9A%84%E5%BA%94%E7%94%A8" title="C_指针的应用"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.png&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/Barbecue-g/imagehost/Language/C/C-icon.png" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-history fa-fw"></i> 2024-09-28</div><div class="title">C_指针的应用</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="anzhiyufont anzhiyu-icon-comments"></i><span> 评论</span></div><div class="comment-randomInfo"><a onclick="anzhiyu.addRandomCommentInfo()" href="javascript:void(0)">匿名评论</a></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div><div class="comment-barrage"></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-bars"></i><span>文章目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#C-%E6%8E%92%E5%BA%8F%E4%B8%8E%E6%9F%A5%E6%89%BE"><span class="toc-text">C_排序与查找</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F"><span class="toc-text">排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%84%E4%BC%B0%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95"><span class="toc-text">评估排序算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="toc-text">时间复杂度</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="toc-text">空间复杂度</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A8%B3%E5%AE%9A%E6%80%A7"><span class="toc-text">稳定性</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F"><span class="toc-text">插入排序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B4%E6%8E%A5%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F"><span class="toc-text">直接插入排序</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3"><span class="toc-text">算法思想</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-text">代码实现</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90"><span class="toc-text">算法分析</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8A%98%E5%8D%8A%E6%8E%92%E5%BA%8F"><span class="toc-text">折半排序</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3-1"><span class="toc-text">算法思想</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-1"><span class="toc-text">代码实现</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90-1"><span class="toc-text">算法分析</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F"><span class="toc-text">希尔排序</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3-2"><span class="toc-text">算法思想</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-2"><span class="toc-text">代码实现</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90-2"><span class="toc-text">算法分析</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%A4%E6%8D%A2%E6%8E%92%E5%BA%8F"><span class="toc-text">交换排序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F"><span class="toc-text">冒泡排序</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3-3"><span class="toc-text">算法思想</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-3"><span class="toc-text">代码实现</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90-3"><span class="toc-text">算法分析</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F"><span class="toc-text">快速排序</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3-4"><span class="toc-text">算法思想</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-4"><span class="toc-text">代码实现</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90-4"><span class="toc-text">算法分析</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F"><span class="toc-text">选择排序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F"><span class="toc-text">简单选择排序</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3-5"><span class="toc-text">算法思想</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-5"><span class="toc-text">代码实现</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90-5"><span class="toc-text">算法分析</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A0%86%E6%8E%92%E5%BA%8F"><span class="toc-text">堆排序</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3-6"><span class="toc-text">算法思想</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-6"><span class="toc-text">代码实现</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90-6"><span class="toc-text">算法分析</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F"><span class="toc-text">归并排序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3-7"><span class="toc-text">算法思想</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-7"><span class="toc-text">代码实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90-7"><span class="toc-text">算法分析</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F"><span class="toc-text">基数排序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3-8"><span class="toc-text">算法思想</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-8"><span class="toc-text">代码实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90-8"><span class="toc-text">算法分析</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9F%A5%E6%89%BE"><span class="toc-text">查找</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%84%E4%BC%B0%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95"><span class="toc-text">评估查找算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6-1"><span class="toc-text">时间复杂度</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6-1"><span class="toc-text">空间复杂度</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%89%8D%E6%8F%90%E6%9D%A1%E4%BB%B6"><span class="toc-text">前提条件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%B2%81%E6%A3%92%E6%80%A7"><span class="toc-text">鲁棒性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A8%B3%E5%AE%9A%E6%80%A7-1"><span class="toc-text">稳定性</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E6%80%A7%E6%9F%A5%E6%89%BE"><span class="toc-text">线性查找</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3-9"><span class="toc-text">算法思想</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-9"><span class="toc-text">代码实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90-9"><span class="toc-text">算法分析</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE"><span class="toc-text">二分查找</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3-10"><span class="toc-text">算法思想</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-10"><span class="toc-text">代码实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90-10"><span class="toc-text">算法分析</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B7%B3%E8%A1%A8"><span class="toc-text">跳表</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3-11"><span class="toc-text">算法思想</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-11"><span class="toc-text">代码实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90-11"><span class="toc-text">算法分析</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%93%88%E5%B8%8C%E6%9F%A5%E6%89%BE"><span class="toc-text">哈希查找</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3-12"><span class="toc-text">算法思想</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-12"><span class="toc-text">代码实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90-12"><span class="toc-text">算法分析</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2"><span class="toc-text">深度优先搜索</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3-13"><span class="toc-text">算法思想</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-13"><span class="toc-text">代码实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90-13"><span class="toc-text">算法分析</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2"><span class="toc-text">广度优先搜索</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3-14"><span class="toc-text">算法思想</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-14"><span class="toc-text">代码实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90-14"><span class="toc-text">算法分析</span></a></li></ol></li></ol></li></ol></li></ol></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><p id="ghbdages"><a class="github-badge" target="_blank" href="https://hexo.io/" style="margin-inline:5px" data-title="博客框架为Hexo_v5.4.0" title="博客框架为Hexo_v5.4.0"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.png&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@2.1.5/img/badge/Frame-Hexo.svg" alt="博客框架为Hexo_v5.4.0"/></a><a class="github-badge" target="_blank" href="https://github.com/" style="margin-inline:5px" data-title="本站项目由Github托管" title="本站项目由Github托管"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.png&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@2.1.5/img/badge/Source-Github.svg" alt="本站项目由Github托管"/></a><a class="github-badge" target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" style="margin-inline:5px" data-title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可" title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.png&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@2.2.0/img/badge/Copyright-BY-NC-SA.svg" alt="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可"/></a></p></div><div id="footer-bar"><div class="footer-bar-links"><div class="footer-bar-left"><div id="footer-bar-tips"><div class="copyright">&copy;2024 - 2025 By <a class="footer-bar-link" href="/" title="Barbecue" target="_blank">Barbecue</a></div></div><div id="footer-type-tips"></div></div><div class="footer-bar-right"><a class="footer-bar-link" target="_blank" rel="noopener" href="https://beian.miit.gov.cn/" title="赣ICP备-2024039887号">赣ICP备-2024039887号</a></div></div></div></footer></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="sidebar-site-data site-data is-center"><a href="/archives/" title="archive"><div class="headline">文章</div><div class="length-num">45</div></a><a href="/tags/" title="tag"><div class="headline">标签</div><div class="length-num">10</div></a><a href="/categories/" title="category"><div class="headline">分类</div><div class="length-num">5</div></a></div><span class="sidebar-menu-item-title">功能</span><div class="sidebar-menu-item"><a class="darkmode_switchbutton menu-child" href="javascript:void(0);" title="显示模式"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span>显示模式</span></a></div><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">CPP文档</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://zh.cppreference.com/" title="中文版"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.png&quot;" data-lazy-src="https://github.com/Barbecue-g/Imagehost/blob/master/Hexo/book-icon.png?raw=true" alt="中文版"/><span class="back-menu-item-text">中文版</span></a><a class="back-menu-item" target="_blank" rel="noopener" href="https://cplusplus.com/" title="英文版"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.png&quot;" data-lazy-src="https://github.com/Barbecue-g/Imagehost/blob/master/Hexo/book1-cion.png?raw=true" alt="英文版"/><span class="back-menu-item-text">英文版</span></a></div></div><div class="back-menu-list-group"><div class="back-menu-list-title">CPP规范</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://zh-google-styleguide.readthedocs.io/en/stable/contents.html" title="Google"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.png&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/Barbecue-g/imagehost/Hexo/Google-icon.jpg?raw=true" alt="Google"/><span class="back-menu-item-text">Google</span></a></div></div><div class="back-menu-list-group"><div class="back-menu-list-title">推荐网址</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://github.com/cloudwu/skynet" title="Skynet"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.png&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/Barbecue-g/imagehost/FrameWork/Skynet/Skynet-icon.png?raw=true" alt="Skynet"/><span class="back-menu-item-text">Skynet</span></a><a class="back-menu-item" target="_blank" rel="noopener" href="https://www.unrealengine.com/" title="UE5"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.png&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/Barbecue-g/imagehost/FrameWork/UE5/UE5-icon.png?raw=true" alt="UE5"/><span class="back-menu-item-text">UE5</span></a></div></div></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 目录</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/TOC/C"><i class="fa-solid fa-seedling faa-tada"></i><span> C语言</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/TOC/CPP"><i class="fa-solid fa-robot faa-tada"></i><span> CPP</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/TOC/Skynet"><i class="fa-solid fa-cloud faa-tada"></i><span> Skynet</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/TOC/UE5"><i class="fa-solid fa-gamepad faa-tada"></i><span> UE5</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size: 0.9em;"></i><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size: 0.9em;"></i><span> 归档</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 社交</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/link/"><i class="anzhiyufont anzhiyu-icon-link faa-tada" style="font-size: 0.9em;"></i><span> 推荐</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/comments/"><i class="anzhiyufont anzhiyu-icon-envelope faa-tada" style="font-size: 0.9em;"></i><span> 留言板</span></a></li></ul></div></div><span class="sidebar-menu-item-title">标签</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/C/" style="font-size: 0.88rem; color: rgb(142, 30, 183);">C<sup>15</sup></a><a href="/tags/Git/" style="font-size: 0.88rem; color: rgb(67, 106, 44);">Git<sup>3</sup></a><a href="/tags/Hexo/" style="font-size: 0.88rem; color: rgb(108, 92, 120);">Hexo<sup>1</sup></a><a href="/tags/MySQL/" style="font-size: 0.88rem; color: rgb(22, 118, 52);">MySQL<sup>2</sup></a><a href="/tags/Nginx/" style="font-size: 0.88rem; color: rgb(141, 121, 39);">Nginx<sup>1</sup></a><a href="/tags/Postman/" style="font-size: 0.88rem; color: rgb(157, 122, 114);">Postman<sup>1</sup></a><a href="/tags/Redis/" style="font-size: 0.88rem; color: rgb(168, 7, 175);">Redis<sup>1</sup></a><a href="/tags/skynet/" style="font-size: 0.88rem; color: rgb(56, 134, 139);">skynet<sup>18</sup></a><a href="/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/" style="font-size: 0.88rem; color: rgb(13, 195, 193);">正则表达式<sup>1</sup></a></div></div><hr/></div></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="anzhiyufont anzhiyu-icon-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="anzhiyufont anzhiyu-icon-gear"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="anzhiyufont anzhiyu-icon-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="anzhiyufont anzhiyu-icon-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div id="nav-music"><a id="nav-music-hoverTips" onclick="anzhiyu.musicToggle()" accesskey="m">播放音乐</a><div id="console-music-bg"></div><meting-js id="8152976493" server="netease" type="playlist" mutex="true" preload="none" theme="var(--anzhiyu-main)" data-lrctype="0" order="random" volume="0.7"></meting-js></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="anzhiyufont anzhiyu-icon-xmark"></i></button></nav><div class="is-center" id="loading-database"><i class="anzhiyufont anzhiyu-icon-spinner anzhiyu-pulse-icon"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div id="rightMenu"><div class="rightMenu-group rightMenu-small"><div class="rightMenu-item" id="menu-backward"><i class="anzhiyufont anzhiyu-icon-arrow-left"></i></div><div class="rightMenu-item" id="menu-forward"><i class="anzhiyufont anzhiyu-icon-arrow-right"></i></div><div class="rightMenu-item" id="menu-refresh"><i class="anzhiyufont anzhiyu-icon-arrow-rotate-right" style="font-size: 1rem;"></i></div><div class="rightMenu-item" id="menu-top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></div></div><div class="rightMenu-group rightMenu-line rightMenuPlugin"><div class="rightMenu-item" id="menu-copytext"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制选中文本</span></div><div class="rightMenu-item" id="menu-pastetext"><i class="anzhiyufont anzhiyu-icon-paste"></i><span>粘贴文本</span></div><a class="rightMenu-item" id="menu-commenttext"><i class="anzhiyufont anzhiyu-icon-comment-medical"></i><span>引用到评论</span></a><div class="rightMenu-item" id="menu-newwindow"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开</span></div><div class="rightMenu-item" id="menu-copylink"><i class="anzhiyufont anzhiyu-icon-link"></i><span>复制链接地址</span></div><div class="rightMenu-item" id="menu-copyimg"><i class="anzhiyufont anzhiyu-icon-images"></i><span>复制此图片</span></div><div class="rightMenu-item" id="menu-downloadimg"><i class="anzhiyufont anzhiyu-icon-download"></i><span>下载此图片</span></div><div class="rightMenu-item" id="menu-newwindowimg"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开图片</span></div><div class="rightMenu-item" id="menu-search"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>站内搜索</span></div><div class="rightMenu-item" id="menu-searchBaidu"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>百度搜索</span></div><div class="rightMenu-item" id="menu-music-toggle"><i class="anzhiyufont anzhiyu-icon-play"></i><span>播放音乐</span></div><div class="rightMenu-item" id="menu-music-back"><i class="anzhiyufont anzhiyu-icon-backward"></i><span>切换到上一首</span></div><div class="rightMenu-item" id="menu-music-forward"><i class="anzhiyufont anzhiyu-icon-forward"></i><span>切换到下一首</span></div><div class="rightMenu-item" id="menu-music-playlist" onclick="window.open(&quot;https://y.qq.com/n/ryqq/playlist/8802438608&quot;, &quot;_blank&quot;);" style="display: none;"><i class="anzhiyufont anzhiyu-icon-radio"></i><span>查看所有歌曲</span></div><div class="rightMenu-item" id="menu-music-copyMusicName"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制歌名</span></div></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item menu-link" id="menu-randomPost"><i class="anzhiyufont anzhiyu-icon-shuffle"></i><span>随便逛逛</span></a><a class="rightMenu-item menu-link" href="/categories/"><i class="anzhiyufont anzhiyu-icon-cube"></i><span>博客分类</span></a><a class="rightMenu-item menu-link" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags"></i><span>文章标签</span></a></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item" id="menu-copy" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制地址</span></a><a class="rightMenu-item" id="menu-commentBarrage" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-message"></i><span class="menu-commentBarrage-text">关闭热评</span></a><a class="rightMenu-item" id="menu-darkmode" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span class="menu-darkmode-text">深色模式</span></a><a class="rightMenu-item" id="menu-translate" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-language"></i><span>轉為繁體</span></a></div></div><div id="rightmenu-mask"></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.umd.js"></script><script src="https://cdn.cbd.int/instant.page@5.2.0/instantpage.js" type="module"></script><script src="https://cdn.cbd.int/vanilla-lazyload@17.8.5/dist/lazyload.iife.min.js"></script><script src="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.cbd.int/pangu@4.0.7/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><canvas id="universe"></canvas><script async src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/dark/dark.js"></script><script>// 消除控制台打印
var HoldLog = console.log;
console.log = function () {};
let now1 = new Date();
queueMicrotask(() => {
  const Log = function () {
    HoldLog.apply(console, arguments);
  }; //在恢复前输出日志
  const grt = new Date("01/01/2024 00:00:00"); //此处修改你的建站时间或者网站上线时间
  now1.setTime(now1.getTime() + 250);
  const days = (now1 - grt) / 1000 / 60 / 60 / 24;
  const dnum = Math.floor(days);
  const ascll = [
    `欢迎使用安知鱼!`,
    `生活明朗, 万物可爱`,
    `
        
       █████╗ ███╗   ██╗███████╗██╗  ██╗██╗██╗   ██╗██╗   ██╗
      ██╔══██╗████╗  ██║╚══███╔╝██║  ██║██║╚██╗ ██╔╝██║   ██║
      ███████║██╔██╗ ██║  ███╔╝ ███████║██║ ╚████╔╝ ██║   ██║
      ██╔══██║██║╚██╗██║ ███╔╝  ██╔══██║██║  ╚██╔╝  ██║   ██║
      ██║  ██║██║ ╚████║███████╗██║  ██║██║   ██║   ╚██████╔╝
      ╚═╝  ╚═╝╚═╝  ╚═══╝╚══════╝╚═╝  ╚═╝╚═╝   ╚═╝    ╚═════╝
        
        `,
    "已上线",
    dnum,
    "天",
    "©2024 By 安知鱼 V1.6.14",
  ];
  const ascll2 = [`NCC2-036`, `调用前置摄像头拍照成功，识别为【小笨蛋】.`, `Photo captured: `, `🤪`];

  setTimeout(
    Log.bind(
      console,
      `\n%c${ascll[0]} %c ${ascll[1]} %c ${ascll[2]} %c${ascll[3]}%c ${ascll[4]}%c ${ascll[5]}\n\n%c ${ascll[6]}\n`,
      "color:#425AEF",
      "",
      "color:#425AEF",
      "color:#425AEF",
      "",
      "color:#425AEF",
      ""
    )
  );
  setTimeout(
    Log.bind(
      console,
      `%c ${ascll2[0]} %c ${ascll2[1]} %c \n${ascll2[2]} %c\n${ascll2[3]}\n`,
      "color:white; background-color:#4fd953",
      "",
      "",
      'background:url("https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/tinggge.gif") no-repeat;font-size:450%'
    )
  );

  setTimeout(Log.bind(console, "%c WELCOME %c 你好，小笨蛋.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(
      console,
      "%c ⚡ Powered by 安知鱼 %c 你正在访问 Barbecue 的博客.",
      "color:white; background-color:#f0ad4e",
      ""
    )
  );

  setTimeout(Log.bind(console, "%c W23-12 %c 你已打开控制台.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(console, "%c S013-782 %c 你现在正处于监控中.", "color:white; background-color:#d9534f", "")
  );
});</script><script async src="/anzhiyu/random.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>(() => {
  const initValine = () => {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: 'hnelsWgo7rdNRClm4XkVzGRR-gzGzoHsz',
      appKey: 'R50Ps7cdwVouTiBALXFKiUzI',
      avatar: '“identicon”',
      serverURLs: '',
      emojiMaps: {"tv_doge":"6ea59c827c414b4a2955fe79e0f6fd3dcd515e24.png","tv_亲亲":"a8111ad55953ef5e3be3327ef94eb4a39d535d06.png","tv_偷笑":"bb690d4107620f1c15cff29509db529a73aee261.png","tv_再见":"180129b8ea851044ce71caf55cc8ce44bd4a4fc8.png","tv_冷漠":"b9cbc755c2b3ee43be07ca13de84e5b699a3f101.png","tv_发怒":"34ba3cd204d5b05fec70ce08fa9fa0dd612409ff.png","tv_发财":"34db290afd2963723c6eb3c4560667db7253a21a.png","tv_可爱":"9e55fd9b500ac4b96613539f1ce2f9499e314ed9.png","tv_吐血":"09dd16a7aa59b77baa1155d47484409624470c77.png","tv_呆":"fe1179ebaa191569b0d31cecafe7a2cd1c951c9d.png","tv_呕吐":"9f996894a39e282ccf5e66856af49483f81870f3.png","tv_困":"241ee304e44c0af029adceb294399391e4737ef2.png","tv_坏笑":"1f0b87f731a671079842116e0991c91c2c88645a.png","tv_大佬":"093c1e2c490161aca397afc45573c877cdead616.png","tv_大哭":"23269aeb35f99daee28dda129676f6e9ea87934f.png","tv_委屈":"d04dba7b5465779e9755d2ab6f0a897b9b33bb77.png","tv_害羞":"a37683fb5642fa3ddfc7f4e5525fd13e42a2bdb1.png","tv_尴尬":"7cfa62dafc59798a3d3fb262d421eeeff166cfa4.png","tv_微笑":"70dc5c7b56f93eb61bddba11e28fb1d18fddcd4c.png","tv_思考":"90cf159733e558137ed20aa04d09964436f618a1.png","tv_惊吓":"0d15c7e2ee58e935adc6a7193ee042388adc22af.png"},
      path: window.location.pathname,
      visitor: true
    }, null))
  }

  const loadValine = async () => {
    if (typeof Valine === 'function') initValine()
    else {
      await getScript('https://cdn.cbd.int/valine@1.5.1/dist/Valine.min.js')
      initValine()
    }
  }

  if ('Valine' === 'Valine' || !true) {
    if (true) anzhiyu.loadComment(document.getElementById('vcomment'),loadValine)
    else setTimeout(loadValine, 0)
  } else {
    window.loadOtherComment = loadValine
  }
})()</script><input type="hidden" name="page-type" id="page-type" value="post"></div><script src="https://cdn.cbd.int/blueimp-md5@2.19.0/js/md5.min.js"></script><script>window.addEventListener('load', () => {
  const changeContent = (content) => {
    if (content === '') return content

    content = content.replace(/<img.*?src="(.*?)"?[^\>]+>/ig, '[图片]') // replace image link
    content = content.replace(/<a[^>]+?href=["']?([^"']+)["']?[^>]*>([^<]+)<\/a>/gi, '[链接]') // replace url
    content = content.replace(/<pre><code>.*?<\/pre>/gi, '[代码]') // replace code
    content = content.replace(/<[^>]+>/g,"") // remove html tag

    if (content.length > 150) {
      content = content.substring(0,150) + '...'
    }
    return content
  }

  const getIcon = (icon, mail) => {
    if (icon) return icon
    let defaultIcon = '?d=“identicon”'
    let iconUrl = `https://gravatar.loli.net/avatar/${md5(mail.toLowerCase()) + defaultIcon}`
    return iconUrl
  }

  const generateHtml = array => {
    let result = ''

    if (array.length) {
      for (let i = 0; i < array.length; i++) {
        result += '<div class=\'aside-list-item\'>'

        if (true) {
          const name = 'data-lazy-src'
          result += `<a href='${array[i].url}' class='thumbnail'><img ${name}='${array[i].avatar}' alt='${array[i].nick}'></a>`
        }

        result += `<div class='content'>
        <a class='comment' href='${array[i].url}' title='${array[i].content}'>${array[i].content}</a>
        <div class='name'><span>${array[i].nick} / </span><time datetime="${array[i].date}">${anzhiyu.diffDate(array[i].date, true)}</time></div>
        </div></div>`
      }
    } else {
      result += '没有评论'
    }

    let $dom = document.querySelector('#card-newest-comments .aside-list')
    $dom && ($dom.innerHTML= result)
    window.lazyLoadInstance && window.lazyLoadInstance.update()
    window.pjax && window.pjax.refresh($dom)
  }

  const getComment = () => {
    const serverURL = 'https://hnelsWgo.api.lncldglobal.com'

    var settings = {
      "method": "GET",
      "headers": {
        "X-LC-Id": 'hnelsWgo7rdNRClm4XkVzGRR-gzGzoHsz',
        "X-LC-Key": 'R50Ps7cdwVouTiBALXFKiUzI',
        "Content-Type": "application/json"
      },
    }

    fetch(`${serverURL}/1.1/classes/Comment?limit=6&order=-createdAt`,settings)
      .then(response => response.json())
      .then(data => {
        const valineArray = data.results.map(function (e) {
          return {
            'avatar': getIcon(e.QQAvatar, e.mail),
            'content': changeContent(e.comment),
            'nick': e.nick,
            'url': e.url + '#' + e.objectId,
            'date': e.updatedAt,
          }
        })
        saveToLocal.set('valine-newest-comments', JSON.stringify(valineArray), 10/(60*24))
        generateHtml(valineArray)
      }).catch(e => {
        const $dom = document.querySelector('#card-newest-comments .aside-list')
        $dom.textContent= "无法获取评论，请确认相关配置是否正确"
      }) 
  }

  const newestCommentInit = () => {
    if (document.querySelector('#card-newest-comments .aside-list')) {
      const data = saveToLocal.get('valine-newest-comments')
      if (data) {
        generateHtml(JSON.parse(data))
      } else {
        getComment()
      }
    }
  }

  newestCommentInit()
  document.addEventListener('pjax:complete', newestCommentInit)
})</script><script>var visitorMail = "";
</script><script async data-pjax src="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/waterfall/waterfall.js"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/qrcodejs/1.0.0/qrcode.min.js"></script><script src="/js/anzhiyu/right_click_menu.js"></script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.9/icon/ali_iconfont_css.css"><script id="canvas_nest" defer="defer" color="0,190,255" opacity="1" zIndex="-1" count="64" mobile="false" src="https://cdn.cbd.int/butterfly-extsrc@1.1.3/dist/canvas-nest.min.js"></script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/aplayer/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.cbd.int/anzhiyu-blog-static@1.0.1/js/APlayer.min.js"></script><script src="https://cdn.cbd.int/hexo-anzhiyu-music@1.0.1/assets/js/Meting2.min.js"></script><script src="https://cdn.cbd.int/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]
var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {
  // removeEventListener scroll 
  anzhiyu.removeGlobalFnEvent('pjax')
  anzhiyu.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script charset="UTF-8" src="https://cdn.cbd.int/anzhiyu-theme-static@1.1.5/accesskey/accesskey.js"></script></div><div id="popup-window"><div class="popup-window-title">通知</div><div class="popup-window-divider"></div><div class="popup-window-content"><div class="popup-tip">你好呀</div><div class="popup-link"><i class="anzhiyufont anzhiyu-icon-arrow-circle-right"></i></div></div></div></body></html>