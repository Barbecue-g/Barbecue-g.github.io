<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Skynet概述</title>
      <link href="/FrameWork/Skynet/Skynet%E6%A6%82%E8%BF%B0"/>
      <url>/FrameWork/Skynet/Skynet%E6%A6%82%E8%BF%B0</url>
      
        <content type="html"><![CDATA[<h1 id="skynet概述"><a href="#skynet概述" class="headerlink" title="skynet概述"></a>skynet概述</h1><p>skynet 是一个为网络游戏服务器设计的轻量框架。但它本身并没有任何为网络游戏业务而特别设计的部分，所以尽可以把它用于其它领域。</p><p>skynet 并不是一个开箱即用的引擎，使用它需要先对框架本身的结构有所了解，理解框架到底帮助开发者解决怎样的问题。如果你希望使用这个框架来开发网络游戏服务器，你将发现，skynet 并不会引导你把服务器搭建起来。它更像是一套工具，只有你知道你想做什么，它才会帮助你更有效率的完成。</p><p>理解 skynet 并不复杂，希望通过读完本篇文章，你就能掌握它。这篇文章没有提及任何 api 的具体使用方法、如何搭建 skynet 开发环境、也没有手把手示范如何写出一个简单的游戏服务器，而仅仅介绍 skynet 的基础概念。所以在真正使用 skynet 做开发时还需要参考 wiki 中的其它文档。</p><h2 id="框架-Framework"><a href="#框架-Framework" class="headerlink" title="框架 Framework"></a>框架 Framework</h2><p>作为服务器，通常需要同时处理多份类似的业务。例如在网络游戏中，你需要同时向数千个用户提供服务；同时运作上百个副本，计算副本中的战斗、让 NPC 通过 AI 工作起来，等等。在单核年代，我们通常在 CPU 上轮流处理这些业务，给用户造成并行的假象。而现代计算机，则可以配置多达数十个核心，如何充分利用它们并行运作数千个相互独立的业务，是设计 skynet 的初衷。</p><p>简单的 web 服务倾向于把和用户相关的状态信息（设计好数据结构）储存在数据库中，通过网络收到用户请求后，从数据库中读出关联该用户的状态信息，处理后再写回数据库。而网络游戏服务通常有更强的上下文状态，以及多个用户间更复杂的交互。如果采用相同的模式，数据库和业务处理模块间很容易出现瓶颈，这个瓶颈甚至不能通过增加一个内存 cache 层来完全解决。</p><p>在 skynet 中，用服务 (service) 这个概念来表达某项具体业务，它包括了处理业务的逻辑以及关联的数据状态。使用 skynet 实现游戏服务器时，不建议把业务状态同步到数据库中，而是存放在服务的内存数据结构里。服务、连同服务处理业务的逻辑代码和业务关联的状态数据，都是常驻内存的。如果数据库是你架构的一部分，那么大多数情况下，它扮演的是一个数据备份的角色。你可以在状态改变时，把数据推到数据库保存，也可以定期写到数据库备份。业务处理时直接使用服务内的内存数据结构。</p><p>由于 skynet 服务并非独立进程，所以服务间的通讯也可以被实现的高效的多。另一方面，由于这些服务同时存在于同一个 skynet 进程下，我们可以认为它们同生共死。在编写服务间协作的代码时，不用刻意考虑对方是否还活着、通讯是否可靠的问题。大多数 skynet 服务使用 lua 编写，lua 的虚拟机帮助我们隔离了服务。虽然 skynet 的基础框架设计时并没有限制服务的实现形式，理论上可以用其它语言实现 skynet 服务，但作为刚接触 skynet 的开发者，可以忽略这些细节，仅使用 Lua 做开发。</p><p>简单说，可以把 skynet 理解为一个简单的操作系统，它可以用来调度数千个 lua 虚拟机，让它们并行工作。每个 lua 虚拟机都可以接收处理其它虚拟机发送过来的消息，以及对其它虚拟机发送消息。每个 lua 虚拟机，可以看成 skynet 这个操作系统下的独立进程，你可以在 skynet 工作时启动新的进程、销毁不再使用的进程、还可以通过调试控制台监管它们。skynet 同时掌控了外部的网络数据输入，和定时器的管理；它会把这些转换为一致的（类似进程间的消息）消息输入给这些进程。</p><p>例如：</p><p>在网络游戏中，你可以为每个在线用户创建一个 lua 虚拟机（skynet 称之为 lua 服务），姑且把它称为 agent 。用户在不和其它用户交互而仅仅自娱自乐时，agent 完全可以满足要求。agent 在用户上线时，从数据库加载关联于它的所有数据到 lua vm 中，对用户的网络请求做出反应。当然你也可以让一个 lua 服务管理多个在线用户，每个用户是 lua 虚拟机内的一个对象。</p><p>你还可以用独立的服务处理网络游戏中的副本（或是战场），处理玩家和玩家间，玩家协同对战 AI 的战斗。agent 会和副本服务通过消息进行交互，而不必让用户客户端直接与副本通讯。</p><p>这些都是具体的游戏服务器架构设计，skynet 并没有要求你应该怎么做，甚至不会建议你该怎么做。一切等你设计时做出决断。</p><h2 id="网络-Network"><a href="#网络-Network" class="headerlink" title="网络 Network"></a>网络 Network</h2><p>作为网络服务器框架，必然有封装好的网络层，对于 skynet 更是必不可少。由于 skynet 模拟了一个简单的操作系统，它最重要的工作就是调度数千个服务，如何让服务挂起时，尽量减少对系统的影响就是首要解决的问题。我们不建议你在 skynet 的服务中再使用任何直接和系统网络 api 打交道的模块，因为一旦这些模块被网络 IO 阻塞，影响的就不只是该服务本身，而是 skynet 里的工作线程了。skynet 会被配置成固定数量的工作线程，工作线程数通常和系统物理核心数量相关，而 skynet 所管理的服务数量则是动态的、远超过工作线程数量。skynet 内置的网络层可以和它的服务调度器协同工作，使用 skynet 提供的网络 API 就可以在网络 IO 阻塞时，完全释放出 CPU 处理能力。</p><p>skynet 有监听 TCP 连接，对外建立 TCP 连接，收发 UDP 数据包的能力。你只需要一行代码就可以监听一个端口，接收外部 TCP 连接。当有新的连接建立时，通过一个回调函数可以获得这个新连接的句柄。之后，和普通的网络应用程序一样，你可以读写这个句柄。与你写过的不同网络应用程序不太一样的是，你还可以把这个句柄转交给 skynet 中的其它服务去处理，以获得并行能力。这有点像传统 posix 系统中，接收一个新连接后，fork 一个子进程继承这个句柄来处理的模式。但不一样的是，skynet 的服务没有父子关系。 Skynet provides the functionalities of listening TCP connection, creating TCP connection, send&#x2F;recv UDP packages. You only need one line of code to start listening on a port, accepting TCP connection. When there is a new connection, you can use a callback function to gain the handler of the new connection. After that, you can read&#x2F;write this handler just like other network applications. The difference compared to other network applications is that you can also pass this handler to other Service of Skynet in order to achieve paralleling processing. This is similar to the traditional POSIX system when a new connection is coming, a child process will be forked to inherit this handler to do the real work. The difference here is that there is no inheritance between Services.</p><p>我们通常建议使用一个网关服务，专门监听端口，接受新连接。在用户身份确定后，再把真正的业务数据转交给特定的服务来处理。同时，网关还会负责按约定好的协议，把 TCP 连接上的数据流切分成一个个的包，而不需要业务处理服务来分割 TCP 数据流。业务处理的服务不必直接面对 socket 句柄，而由 skynet 正常的内部消息驱动即可。这样的网关服务，skynet 在发布版里就提供了一个，但它只是一个可选模块，你大可以不用它，或自己编写一个类似的服务以更符合你的项目需求。</p><p>另外， skynet 的 websocket 支持目前处于实验阶段，需要切换到 websocket 分支。</p><h2 id="客户端-Client"><a href="#客户端-Client" class="headerlink" title="客户端 Client"></a>客户端 Client</h2><p>skynet 完全不在意如何实现客户端应用，基于 skynet 的服务器，可以用浏览器做客户端（基于 http 或 websocket 协议 通讯），也可以自己用 C &#x2F; C++ &#x2F; Flash &#x2F; Unity3D 等等编写客户端。你可以选用 TCP socket 建立长连接通讯，也可以使用基于 http 协议的短连接，或者基于 UDP 来通讯。这都可以自由选择，skynet 没有提供直接相关的模块，都需要你自己实现。</p><p>在 skynet 发布版的示例中，实现了一个用 C + Lua 编写的最简单的客户端 demo ，仅供参考。它基于 TCP 长连接，基础协议是用 2 字节大端字来表示每个数据包的长度，skynet 的网关服务根据这个包长度切割成业务逻辑数据包，分发给对应的内部服务处理。如果你想使用 skynet 内置的网关模块，只需要遵循这个基础的分包约定即可。</p><p>对于每个业务包的编码协议约定，在这个 demo 中，使用了一种叫 sproto 自定义协议，它包含在 skynet 的发布版中。demo 演示了 sproto 如何打包数据，解包数据。但是否使用 sproto 协议，skynet 没有任何约束。你也可以使用 json 或是 google protocol buffers 等，只要你知道怎样将对应的协议解析模块自己集成进 Lua 即可。建议在网关，或是使用一个独立服务，将网络消息解包翻译成 skynet 内部消息再转发给对应服务，内部服务不必关心网络层如何传输这些消息的。</p><h2 id="服务-Service"><a href="#服务-Service" class="headerlink" title="服务 Service"></a>服务 Service</h2><p>skynet 的服务使用 lua 5.4 编写。只需要把符合规范的 .lua 文件放在 skynet 可以找到的路径下就可以由其它服务启动。在 skynet 的配置文件里配置了服务查询路径，<strong>以及需要启动的第一个服务</strong>，而其它服务都是由该服务直接或间接启动的。每个服务拥有一个唯一的 32bit id ，skynet 把这个 id 称为服务地址，由 skynet 框架分配。即使服务退出，该地址也会尽可能长时间的保留，以避免当消息发向一个正准备退出的服务后，新启动的服务顶替该地址，而导致消息发向了错误的实体。</p><p>每个服务分三个运行阶段：</p><ul><li><p>首先是服务加载阶段，当服务的源文件被加载时，就会按 lua 的运行规则被执行到。这个阶段不可以调用任何有可能阻塞住该服务的 skynet api 。因为，在这个阶段中，和服务配套的 skynet 设置并没有初始化完毕。</p></li><li><p>然后是服务初始化阶段，由 skynet.start 这个 api 注册的初始化函数执行。这个初始化函数理论上可以调用任何 skynet api 了，但启动该服务的 skynet.newservice 这个 api 会一直等待到初始化函数结束才会返回。</p></li><li><p>最后是服务工作阶段，当你在初始化阶段注册了消息处理函数的话，只要有消息输入，就会触发注册的消息处理函数。这些消息都是 skynet 内部消息，外部的网络数据，定时器也会通过内部消息的形式表达出来。</p></li></ul><p>从 skynet 底层框架来看，每个服务就是一个消息处理器。但在应用层看来并非如此。它是利用 lua 的 coroutine 工作的。当你的服务向另一个服务发送一个请求（即一个带 session 的消息）后，可以认为当前的消息已经处理完毕，服务会被 skynet 挂起。待对应服务收到请求并做出回应（发送一个回应类型的消息）后，服务会找到挂起的 coroutine ，把回应信息传入，延续之前未完的业务流程。从使用者角度看，更像是一个独立线程在处理这个业务流程，每个业务流程有自己独立的上下文，而不像 nodejs 等其它框架中使用的 callback 模式。</p><p>和 erlang 不同，一个 skynet 服务在某个业务流程被挂起后，即使回应消息尚未收到，它还是可以处理其他的消息的。所以同一个 skynet 服务可以同时拥有多条业务执行线。所以，你尽可以让同一个 skynet 服务处理很多消息，它们会看起来并行，和真正分拆到不同的服务中处理的区别是，这些处理流程永远不会真正的并行，它们只是在轮流工作。一段业务会一直运行到下一个 IO 阻塞点，然后切换到下一段逻辑。你可以利用这一点，让多条业务线在处理时共享同一组数据，这些数据在同一个 lua 虚拟机下时，读写起来都比通过消息交换要廉价的多。</p><p>互有利弊的是，一旦你当前业务处理线挂起，等回应到来继续运行时，内部状态很可能被同期其它业务处理逻辑所改变，请务必小心。在 skynet api 文档中，已经注明了哪些 API 可能导致阻塞。两次阻塞 API 调用之间，运行过程是原子的，利用这个特性，会比传统多线程程序更容易编写。</p><p>在同一服务内还可以有多个用户线程，这些线程可以用 skynet.fork 传入一个函数启动，也可以利用 skynet 的定时器的回调函数启动。上面提到的消息处理函数其实也是一条独立的用户线程（可以理解为：响应任何一个请求，都启动了一条新的独立用户线程）。这些并不像真正操作系统的线程那样，可以利用多个核心并行运行。同一服务内的不同用户线程永远是轮流获得执行权的，每个线程都会需要一个阻塞操作而挂起让出控制权，也会在其它线程让出控制权后再延续运行。</p><p>如果一条用户线程永远不调用阻塞 API 让出控制权，那么它将永远占据系统工作线程。skynet 并不是一个抢占式调度器，没有时间片的设计，不会因为一个工作线工作时间过长而强制挂起它。所以需要开发者自己小心，不要陷入死循环。不过，skynet 框架也做了一些监控工作，会在某个服务内的某个工作线程占据了太长时间后，以 log 的形式报告。提醒开发者修正导致死循环的 bug 。对于 lua 代码中的死循环 bug （而不是由 lua 调用的 C 模块导致的死循环）还可以由框架强制中断。具体知识可以在开发中遇到后逐步了解。</p><h2 id="消息-Message"><a href="#消息-Message" class="headerlink" title="消息 Message"></a>消息 Message</h2><p>每条 skynet 消息由 6 部分构成：消息类型、session 、发起服务地址 、接收服务地址 、消息 C 指针、消息长度。</p><p>每个 skynet 服务都可以处理多类消息。在 skynet 中，是用 type 这个词来区分消息的。但与其说消息类型不同，不如说更接近网络端口 (port) 这个概念。每个 skynet 服务都支持 255 个不同的 port 。消息分发函数可以根据不同的 port 来为不同的消息定制不同的消息处理流程。</p><p>skynet 预定义了一组消息类型，需要开发者关心的有：回应消息、网络消息、调试消息、文本消息、Lua 消息、错误。</p><ul><li><p>回应消息通常不需要特别处理，它由 skynet 基础库管理，用来调度服务内的 coroutine 。当你对外发起一个请求后，对方会回应一个消息，这个消息的类型就是回应消息。发起请求方收到回应消息，会根据消息的 session 来找到之前对应的请求所在的 coroutine ，并延续它。</p></li><li><p>网络消息也不必直接处理它，skynet 提供了 socket 封装库，封装管理这类消息，改由一组更友好的 socket api 方便使用。</p></li><li><p>调试消息已经被默认的 skynet 基础库处理了。它使得所有 skynet 服务都提供有一些共同的能力。比如反馈自身虚拟机所占用的内存情况、当前被挂起的任务数量、动态注入一段 lua 代码帮助调试、等等。是的、skynet 并不是通过外框架直接控制每个 lua 虚拟机，调试控制台只是通过向对应的服务发送调试消息，服务自身配合运行才得以反馈自身的状态。</p></li><li><p>真正的业务逻辑是由文本类消息和 Lua 类消息驱动的。它们的区别仅在于消息的编码形式不同，文本类消息主要方便一些底层的，直接使用 C 编写的服务处理，它就是简单字节串；而 Lua 类消息则可以序列化 Lua 的复杂数据类型。大多数情况下，我们都只使用 lua 类消息。</p></li></ul><p>接管某类消息需要在服务的初始化过程中注册该消息的序列化及反序列化函数，以及消息回调函数。lua 类的序列化函数已经由 skynet 基础库默认注册，它们会把框架传入的消息 C 指针及长度信息转换为一组 Lua 数据。编写业务的开发者只需要注册消息回调函数即可。这个回调函数会接收到别的服务发过来的一系列 Lua 值，以及发送服务的地址和该请求的 session 号（一个 31bit 正整数）。一般我们不必关心地址和 session ，因为 skynet.ret 和 skynet.response 这两个 api 可以帮助你正确的将回应消息发还给请求者。另外，skynet 还约定，如果一个请求不需要回应（单向推送），就置 session 为 0 。</p><p>skynet 在应用层还约定了错误类消息，不需要开发者主动处理。这类消息一般没有实际内容，只有发送源地址和 session 号。它专门用来表示某个请求发生了异常，或是某个服务即将或已经退出，无法完成请求。这类错误消息或由 skynet 基础库转换为 lua 层的 error ，抛给调用者。你可以将其理解为 RPC 调用的异常。</p><h2 id="外部服务-External-Service"><a href="#外部服务-External-Service" class="headerlink" title="外部服务 External Service"></a>外部服务 External Service</h2><p>我们应尽量可能的在同一个 skynet 进程内完成所有的业务逻辑，这样可以最大化利用系统的硬件能力，但有时又必不可少的使用一些外部进程。例如，你可以将 SQLite 封装为一个服务供其它内部服务使用；但你也可能希望使用独立的 MySQL 或是 Redis MongoDB 等独立的外部数据库服务。</p><p>skynet 发布版中提供了 mysql redis mongo 的驱动模块，省去了开发者自行封装的烦恼。这些驱动模块都是基于 skynet 的 socket API 实现的，可以很好的协同工作。如果你希望使用别的外部数据库，则需要自行封装。需要注意的是，大多数外部数据库的默认驱动模块都内含了网络部分，它们直接使用了系统的 socket api ，和 skynet 的网络层有一定的性能冲突。一个比较简单的兼容方案是额外再自定义一个中间进程，一边使用外部数据库的默认驱动模块，另一边用 skynet 提供的 socket channel 和 skynet 交互。</p><p>你还可能需要让 skynet 提供 http 协议的 web 服务，或是使用 http 协议和外部 web 服务对接。skynet 自带了 http 模块，实现一个简单的 http 服务器不会比用其它框架开发更复杂。即使用 skynet 做一个 web 服务器也可以轻松获得高性能。但是，出于简化编译依赖的想法，skynet 的默认编译脚本并没有将 openssl 链接进去，而 https 支持需要它。如果需要支持 https ，需要额外设置 <code>TLS_MODULE=ltls</code>。另外，你也可以用 nginx 制作一个 https 反向代理服务器，而不必直接使用 skynet 的 https 模块。</p><p>不建议把连接管理的网关实现成一个外部服务，因为 skynet 在管理大量 TCP 连接这方面已经做的很好了。放在 skynet 内部做可以减少大量不必要的进程间数据传输。</p><h2 id="集群-Cluster"><a href="#集群-Cluster" class="headerlink" title="集群 Cluster"></a>集群 Cluster</h2><p>skynet 在最开始设计的时候，是希望把集群管理做成底层特性的。所以，每个服务的地址预留了 8bit 作为集群节点编号。最多 255 台机器可以组成一个集群，不同节点下的服务可以像同一节点进程内部那样自由的传递消息。</p><p>随着 skynet 的演进和实际项目的实践，发现其实把节点间的消息传播透明化，抹平节点间和节点进程内的消息传播的区别并不是一个好主意。在同一进程内，我们可以认为服务以及服务间的通讯都是可靠的，如果自身工作所处的硬件环境正常，那么对方也一定是正常的。而当服务部署在不同进程（不同机器）上时，不可能保证完全可靠。另外一些在同一进程内可以共享访问的内存（skynet 提供的共享数据模块就基于此）也变得不可共享，这些差异无法完全被开发者忽视。</p><p>所以，虽然 skynet 可以被配置为多节点模式，但不推荐使用。</p><p>目前推荐把不同的 skynet 服务当作外部服务来对待，skynet 发布版中提供了 cluster 模块来简化开发。</p>]]></content>
      
      
      <categories>
          
          <category> skynet </category>
          
      </categories>
      
      
        <tags>
            
            <tag> skynet </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Skynet_bootstrap服务的启动</title>
      <link href="/FrameWork/Skynet/Skynet_%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/Skynet_bootstrap%E6%9C%8D%E5%8A%A1%E7%9A%84%E5%90%AF%E5%8A%A8"/>
      <url>/FrameWork/Skynet/Skynet_%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/Skynet_bootstrap%E6%9C%8D%E5%8A%A1%E7%9A%84%E5%90%AF%E5%8A%A8</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> skynet </category>
          
      </categories>
      
      
        <tags>
            
            <tag> skynet </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Skynet_基本概况</title>
      <link href="/FrameWork/Skynet/Skynet_%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/Skynet_%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%86%B5"/>
      <url>/FrameWork/Skynet/Skynet_%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/Skynet_%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%86%B5</url>
      
        <content type="html"><![CDATA[<h1 id="Skynet基本概况"><a href="#Skynet基本概况" class="headerlink" title="Skynet基本概况"></a>Skynet基本概况</h1><h2 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h2><p>主要工作流程图</p><p><img src="https://cdn.jsdelivr.net/gh/Barbecue-g/imagehost/FrameWork/Skynet/%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/Skynet_%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%86%B5/Skynet_Flowchart.png?raw=true" alt="Skynet_Flowchar"></p><p>上图中所示的每个队列都关联一个服务的。所有的队列连接成一个大链表。</p><p>一个工作线程主要工作流程：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">&#123;    </span><br><span class="line"><span class="built_in">queue</span> = get_one_queue(global_queue) <span class="comment">//通过全局队列拿到一个私有队列</span></span><br><span class="line">ctx  = get_ctx( <span class="built_in">queue</span>-&gt;handle ) <span class="comment">//通过队列拿到一个服务</span></span><br><span class="line">msg = get_one_message(<span class="built_in">queue</span>) <span class="comment">//从队列里面取出一个消息</span></span><br><span class="line">ctx-&gt;callback(msg) <span class="comment">//调用服务的回调函数 ,在这个回调函数里面再调用一个固定的 lua函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个<code>skynet</code>节点,也就是一个<code>skynet</code>进程。它启动的时候会创建多个线程：</p><ul><li>网络线程：<ul><li>接收skynet外部的网络请求，然后push到服务的队列。</li><li>当服务需要把数据发送给外部时,实质上是 服务—&gt;网络线程—&gt;外部</li></ul></li><li>定时器线程：把定时器消息push到某个服务。当服务在处理定时器消息时,就可以认为是定时器事件触发了。</li><li>监听线程：主要是发现工作线程有没有死循环。</li><li>工作线程：驱动服务处理消息</li></ul><h2 id="主函数代码"><a href="#主函数代码" class="headerlink" title="主函数代码"></a>主函数代码</h2><h3 id="skynet-main函数"><a href="#skynet-main函数" class="headerlink" title="skynet_main函数"></a>skynet_main函数</h3><p>main函数读取了一个 lua配置文件。这个配置文件就是启动 skynet进程时使用的命令，类似 <code>./skynet config</code> 。 这里的config就是配置文件。<a href="https://github.com/cloudwu/skynet/wiki/Config">Skynet_Config官方文档</a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span> * config_file = <span class="literal">NULL</span> ;</span><br><span class="line">skynet_globalinit();</span><br><span class="line">skynet_env_init();</span><br><span class="line"></span><br><span class="line">sigign();</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">skynet_config</span> <span class="title">config</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">lua_State</span> *<span class="title">L</span> =</span> luaL_newstate();<span class="comment">//生成luastate的目的主要是读取配置文件中的配置项</span></span><br><span class="line">luaL_openlibs(L);<span class="comment">// link lua lib</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> err =  luaL_loadbufferx(L, load_config, <span class="built_in">strlen</span>(load_config), <span class="string">&quot;=[skynet config]&quot;</span>, <span class="string">&quot;t&quot;</span>);</span><br><span class="line">assert(err == LUA_OK);</span><br><span class="line">lua_pushstring(L, config_file);</span><br><span class="line"></span><br><span class="line">err = lua_pcall(L, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>);<span class="comment">//执行配置文件</span></span><br><span class="line"></span><br><span class="line">_init_env(L);</span><br><span class="line"><span class="comment">//把配置文件里面的配置项 都读出来</span></span><br><span class="line">config.thread =  optint(<span class="string">&quot;thread&quot;</span>,<span class="number">8</span>);</span><br><span class="line">config.module_path = optstring(<span class="string">&quot;cpath&quot;</span>,<span class="string">&quot;./cservice/?.so&quot;</span>);<span class="comment">//默认路径下的动态链接库有gate.so  harbor.so  logger.so  snlua.so 常用snlua.so来创建模块实例</span></span><br><span class="line">config.harbor = optint(<span class="string">&quot;harbor&quot;</span>, <span class="number">1</span>);<span class="comment">//这里推荐在配置文件中设置为0 否则默认为1</span></span><br><span class="line">config.bootstrap = optstring(<span class="string">&quot;bootstrap&quot;</span>,<span class="string">&quot;snlua bootstrap&quot;</span>);<span class="comment">//启动服务设置: snlua作为服务模块 bootstrap作为服务对应的lua文件</span></span><br><span class="line">config.daemon = optstring(<span class="string">&quot;daemon&quot;</span>, <span class="literal">NULL</span>);<span class="comment">//后台运行配置</span></span><br><span class="line">config.logger = optstring(<span class="string">&quot;logger&quot;</span>, <span class="literal">NULL</span>);<span class="comment">//保存日志的文件名字 这里日志的来源是lua层调用的skynet.error(str)</span></span><br><span class="line">config.logservice = optstring(<span class="string">&quot;logservice&quot;</span>, <span class="string">&quot;logger&quot;</span>);<span class="comment">//默认日志模块是 logger 即 service_logger.c 所代表的模块</span></span><br><span class="line">config.profile = optboolean(<span class="string">&quot;profile&quot;</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">lua_close(L);</span><br><span class="line"></span><br><span class="line">skynet_start(&amp;config);<span class="comment">//next</span></span><br><span class="line">skynet_globalexit();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="skynet-start函数"><a href="#skynet-start函数" class="headerlink" title="skynet_start函数"></a>skynet_start函数</h3><p>初始化工作和启动两个服务——<code>bootstrap(ctx, config-&gt;bootstrap)</code> 和 <code>start(config-&gt;thread)</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> </span><br><span class="line"><span class="title function_">skynet_start</span><span class="params">(<span class="keyword">struct</span> skynet_config * config)</span> &#123;</span><br><span class="line"></span><br><span class="line">skynet_harbor_init(config-&gt;harbor);</span><br><span class="line">skynet_handle_init(config-&gt;harbor);<span class="comment">//可以简单的认为就是保存了 handle和服务 映射关系的数组</span></span><br><span class="line">skynet_mq_init();<span class="comment">//初始化一个全局队列 用来把所有服务关联的队列 连接起来</span></span><br><span class="line">skynet_module_init(config-&gt;module_path);<span class="comment">//模块初始化</span></span><br><span class="line">skynet_timer_init();</span><br><span class="line">skynet_socket_init();</span><br><span class="line"></span><br><span class="line">skynet_profile_enable(config-&gt;profile);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">skynet_context</span> *<span class="title">ctx</span> =</span> skynet_context_new(config-&gt;logservice, config-&gt;logger);<span class="comment">//首先创建日志服务</span></span><br><span class="line"></span><br><span class="line">skynet_handle_namehandle(skynet_context_handle(ctx), <span class="string">&quot;logger&quot;</span>);<span class="comment">//给日志服务绑定一个名字</span></span><br><span class="line"></span><br><span class="line">bootstrap(ctx, config-&gt;bootstrap);<span class="comment">//创建bootstrp服务 注意这里服务并没有完成所有流程 因为工作线程还没有启动 服务的第一个消息只是push进队列了</span></span><br><span class="line">start(config-&gt;thread);<span class="comment">//next</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="start函数"><a href="#start函数" class="headerlink" title="start函数"></a>start函数</h3><p>启动：监听线程、定时器线程、网络线程和多个工作线程。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">start</span><span class="params">(<span class="type">int</span> thread)</span> &#123;</span><br><span class="line"><span class="type">pthread_t</span> pid[thread+<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">monitor</span> *<span class="title">m</span> =</span> skynet_malloc(<span class="keyword">sizeof</span>(*m));<span class="comment">//创建监听管理器</span></span><br><span class="line"><span class="built_in">memset</span>(m, <span class="number">0</span>, <span class="keyword">sizeof</span>(*m));</span><br><span class="line">m-&gt;count = thread;<span class="comment">//数量跟工作线程数一致 工作线程数一般又设置成跟你的cpu核心数相同</span></span><br><span class="line">m-&gt;sleep = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">m-&gt;m = skynet_malloc(thread * <span class="keyword">sizeof</span>(<span class="keyword">struct</span> skynet_monitor *));</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;thread;i++) &#123;</span><br><span class="line">m-&gt;m[i] = skynet_monitor_new();<span class="comment">//每个工作线程安排一个监听</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">create_thread(&amp;pid[<span class="number">0</span>], thread_monitor, m);<span class="comment">//监听线程的职责是监听工作线程</span></span><br><span class="line">create_thread(&amp;pid[<span class="number">1</span>], thread_timer, m);<span class="comment">//定时器线程</span></span><br><span class="line">create_thread(&amp;pid[<span class="number">2</span>], thread_socket, m);<span class="comment">//网络线程</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">worker_parm</span> <span class="title">wp</span>[<span class="title">thread</span>];</span></span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;thread;i++) &#123;</span><br><span class="line">create_thread(&amp;pid[i+<span class="number">3</span>], thread_worker, &amp;wp[i]);<span class="comment">//给每个工作线程传递不同参数</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> skynet </category>
          
      </categories>
      
      
        <tags>
            
            <tag> skynet </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Skynet_socketChannel</title>
      <link href="/FrameWork/Skynet/Skynet_%E7%BD%91%E7%BB%9C/Skynet_socketChannel"/>
      <url>/FrameWork/Skynet/Skynet_%E7%BD%91%E7%BB%9C/Skynet_socketChannel</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> skynet </category>
          
      </categories>
      
      
        <tags>
            
            <tag> skynet </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Skynet_关闭网络连接</title>
      <link href="/FrameWork/Skynet/Skynet_%E7%BD%91%E7%BB%9C/Skynet_%E5%85%B3%E9%97%AD%E7%BD%91%E7%BB%9C%E8%BF%9E%E6%8E%A5"/>
      <url>/FrameWork/Skynet/Skynet_%E7%BD%91%E7%BB%9C/Skynet_%E5%85%B3%E9%97%AD%E7%BD%91%E7%BB%9C%E8%BF%9E%E6%8E%A5</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> skynet </category>
          
      </categories>
      
      
        <tags>
            
            <tag> skynet </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Skynet_写网络数据</title>
      <link href="/FrameWork/Skynet/Skynet_%E7%BD%91%E7%BB%9C/Skynet_%E5%86%99%E7%BD%91%E7%BB%9C%E6%95%B0%E6%8D%AE"/>
      <url>/FrameWork/Skynet/Skynet_%E7%BD%91%E7%BB%9C/Skynet_%E5%86%99%E7%BD%91%E7%BB%9C%E6%95%B0%E6%8D%AE</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> skynet </category>
          
      </categories>
      
      
        <tags>
            
            <tag> skynet </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Skynet_发起主动连接</title>
      <link href="/FrameWork/Skynet/Skynet_%E7%BD%91%E7%BB%9C/Skynet_%E5%8F%91%E8%B5%B7%E4%B8%BB%E5%8A%A8%E8%BF%9E%E6%8E%A5"/>
      <url>/FrameWork/Skynet/Skynet_%E7%BD%91%E7%BB%9C/Skynet_%E5%8F%91%E8%B5%B7%E4%B8%BB%E5%8A%A8%E8%BF%9E%E6%8E%A5</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> skynet </category>
          
      </categories>
      
      
        <tags>
            
            <tag> skynet </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Skynet_发起监听</title>
      <link href="/FrameWork/Skynet/Skynet_%E7%BD%91%E7%BB%9C/Skynet_%E5%8F%91%E8%B5%B7%E7%9B%91%E5%90%AC"/>
      <url>/FrameWork/Skynet/Skynet_%E7%BD%91%E7%BB%9C/Skynet_%E5%8F%91%E8%B5%B7%E7%9B%91%E5%90%AC</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> skynet </category>
          
      </categories>
      
      
        <tags>
            
            <tag> skynet </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Skynet_读网络数据</title>
      <link href="/FrameWork/Skynet/Skynet_%E7%BD%91%E7%BB%9C/Skynet_%E8%AF%BB%E7%BD%91%E7%BB%9C%E6%95%B0%E6%8D%AE"/>
      <url>/FrameWork/Skynet/Skynet_%E7%BD%91%E7%BB%9C/Skynet_%E8%AF%BB%E7%BD%91%E7%BB%9C%E6%95%B0%E6%8D%AE</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> skynet </category>
          
      </categories>
      
      
        <tags>
            
            <tag> skynet </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Skynet_接受新连接</title>
      <link href="/FrameWork/Skynet/Skynet_%E7%BD%91%E7%BB%9C/Skynet_%E6%8E%A5%E5%8F%97%E6%96%B0%E8%BF%9E%E6%8E%A5"/>
      <url>/FrameWork/Skynet/Skynet_%E7%BD%91%E7%BB%9C/Skynet_%E6%8E%A5%E5%8F%97%E6%96%B0%E8%BF%9E%E6%8E%A5</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> skynet </category>
          
      </categories>
      
      
        <tags>
            
            <tag> skynet </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Skynet_launcher的创建</title>
      <link href="/FrameWork/Skynet/Skynet_%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/Skynet_snlua%E6%9C%8D%E5%8A%A1%E7%9A%84%E5%88%9B%E5%BB%BA/Skynet_launcher%E7%9A%84%E5%88%9B%E5%BB%BA"/>
      <url>/FrameWork/Skynet/Skynet_%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/Skynet_snlua%E6%9C%8D%E5%8A%A1%E7%9A%84%E5%88%9B%E5%BB%BA/Skynet_launcher%E7%9A%84%E5%88%9B%E5%BB%BA</url>
      
        <content type="html"><![CDATA[<h1 id="launcher的创建"><a href="#launcher的创建" class="headerlink" title="launcher的创建"></a>launcher的创建</h1><p>目录</p><ul><li><a href="https://www.cnblogs.com/waittingforyou/p/16966196.html#%E5%BD%93%E5%89%8D%E5%B7%A5%E4%BD%9C%E7%BA%BF%E7%A8%8B%E5%AE%8C%E6%88%90%E6%AD%A5%E9%AA%A41">当前工作线程完成步骤1</a></li><li><a href="https://www.cnblogs.com/waittingforyou/p/16966196.html#%E5%8F%AF%E8%83%BD%E5%8F%A6%E4%B8%80%E4%B8%AA%E5%B7%A5%E4%BD%9C%E7%BA%BF%E7%A8%8B%E5%AE%8C%E6%88%90%E6%AD%A5%E9%AA%A42">可能另一个工作线程完成步骤2</a></li></ul><p>launcher服务是一个snlua服务。</p><p>当调用skynet.newservice请求创建某个服务的时候，实际上会把创建请求发送到launcher服务。launcher来真正启动一个目标服务。launcher本身又是怎么启动的？他是在bootstrap服务里面启动的。看看代码 11行。</p><blockquote><p>bootstrap服务也是一个snlua服务</p></blockquote><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--bootstrap.lua</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> skynet = <span class="built_in">require</span> <span class="string">&quot;skynet&quot;</span></span><br><span class="line"><span class="keyword">local</span> harbor = <span class="built_in">require</span> <span class="string">&quot;skynet.harbor&quot;</span></span><br><span class="line"><span class="keyword">local</span> service = <span class="built_in">require</span> <span class="string">&quot;skynet.service&quot;</span></span><br><span class="line"><span class="built_in">require</span> <span class="string">&quot;skynet.manager&quot;</span><span class="comment">-- import skynet.launch, ...</span></span><br><span class="line"></span><br><span class="line">skynet.start(<span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br><span class="line"><span class="keyword">local</span> standalone = skynet.<span class="built_in">getenv</span> <span class="string">&quot;standalone&quot;</span></span><br><span class="line"><span class="comment">--skynet.launch 用于启动一个 C 模块的服务。主要意思是 第一个参数是 c 模块的名字 可以是snlua logger...</span></span><br><span class="line"><span class="keyword">local</span> launcher = <span class="built_in">assert</span>(skynet.launch(<span class="string">&quot;snlua&quot;</span>,<span class="string">&quot;launcher&quot;</span>))</span><br><span class="line">skynet.name(<span class="string">&quot;.launcher&quot;</span>, launcher) <span class="comment">--给服务取一个名字叫做.launcher</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> harbor_id = <span class="built_in">tonumber</span>(skynet.<span class="built_in">getenv</span> <span class="string">&quot;harbor&quot;</span> <span class="keyword">or</span> <span class="number">0</span>)</span><br><span class="line"><span class="keyword">if</span> harbor_id == <span class="number">0</span> <span class="keyword">then</span></span><br><span class="line"><span class="built_in">assert</span>(standalone ==  <span class="literal">nil</span>)</span><br><span class="line">standalone = <span class="literal">true</span></span><br><span class="line">skynet.setenv(<span class="string">&quot;standalone&quot;</span>, <span class="string">&quot;true&quot;</span>)</span><br><span class="line">            </span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">skynet.newservice <span class="string">&quot;service_mgr&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">pcall</span>(skynet.newservice,skynet.<span class="built_in">getenv</span> <span class="string">&quot;start&quot;</span> <span class="keyword">or</span> <span class="string">&quot;main&quot;</span>)</span><br><span class="line">skynet.<span class="built_in">exit</span>()</span><br><span class="line"><span class="keyword">end</span>)</span><br></pre></td></tr></table></figure><p>也就是说 <code>skynet.launch(&quot;snlua&quot;,&quot;launcher&quot;)</code> 创建了 launcher服务。这两个参数的意思是 我们是要创建一个snlua服务，对应的脚本文件是launcher.lua。这个调用不会挂起我们当前协程，但不是在当前工作线程完成所有创建任务的。</p><h3 id="当前工作线程完成步骤1"><a href="#当前工作线程完成步骤1" class="headerlink" title="当前工作线程完成步骤1"></a>当前工作线程完成步骤1</h3><p>当前线程主要是push了 <strong>第一个消息</strong> 给我们创建的服务。我们跟踪一下</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">skynet.launch</span><span class="params">(...)</span></span></span><br><span class="line"><span class="keyword">local</span> addr = c.command(<span class="string">&quot;LAUNCH&quot;</span>, <span class="built_in">table</span>.<span class="built_in">concat</span>(&#123;...&#125;,<span class="string">&quot; &quot;</span>))<span class="comment">--next</span></span><br><span class="line"><span class="keyword">if</span> addr <span class="keyword">then</span></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">tonumber</span>(<span class="built_in">string</span>.<span class="built_in">sub</span>(addr , <span class="number">2</span>), <span class="number">16</span>)<span class="comment">--把8位16进制数转变成lua表示的十进制数 /这里把开头的冒号去掉了</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>跟踪到c层。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">lcommand</span><span class="params">(lua_State *L)</span> &#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">skynet_context</span> * <span class="title">context</span> =</span> lua_touserdata(L, lua_upvalueindex(<span class="number">1</span>));</span><br><span class="line"><span class="type">const</span> <span class="type">char</span> * cmd = luaL_checkstring(L,<span class="number">1</span>);</span><br><span class="line"><span class="type">const</span> <span class="type">char</span> * result;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span> * parm = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">if</span> (lua_gettop(L) == <span class="number">2</span>) &#123;</span><br><span class="line">parm = luaL_checkstring(L,<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">result = skynet_command(context, cmd, parm);<span class="comment">//cmd是&quot;LAUNCH&quot; parm是 &quot;snlua launcher&quot;</span></span><br><span class="line"><span class="keyword">if</span> (result) &#123;</span><br><span class="line">lua_pushstring(L, result);</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>11行</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">command_func</span> <span class="title">cmd_funcs</span>[] =</span> &#123;</span><br><span class="line"></span><br><span class="line">&#123; <span class="string">&quot;LAUNCH&quot;</span>, cmd_launch &#125;,<span class="comment">//这里</span></span><br><span class="line"></span><br><span class="line">&#123; <span class="literal">NULL</span>, <span class="literal">NULL</span> &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> * </span><br><span class="line"><span class="title function_">skynet_command</span><span class="params">(<span class="keyword">struct</span> skynet_context * context, <span class="type">const</span> <span class="type">char</span> * cmd , <span class="type">const</span> <span class="type">char</span> * param)</span> &#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">command_func</span> * <span class="title">method</span> =</span> &amp;cmd_funcs[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">while</span>(method-&gt;name) &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">strcmp</span>(cmd, method-&gt;name) == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> method-&gt;func(context, param);<span class="comment">//这里调用 cmd_launch</span></span><br><span class="line">&#125;</span><br><span class="line">++method;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继续跟踪 cmd_launch</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">char</span> *</span><br><span class="line"><span class="title function_">cmd_launch</span><span class="params">(<span class="keyword">struct</span> skynet_context * context, <span class="type">const</span> <span class="type">char</span> * param)</span> &#123;</span><br><span class="line"><span class="type">size_t</span> sz = <span class="built_in">strlen</span>(param);</span><br><span class="line"><span class="type">char</span> tmp[sz+<span class="number">1</span>];</span><br><span class="line"><span class="built_in">strcpy</span>(tmp,param);</span><br><span class="line"><span class="type">char</span> * args = tmp;</span><br><span class="line"><span class="type">char</span> * mod = strsep(&amp;args, <span class="string">&quot; \t\r\n&quot;</span>);</span><br><span class="line">args = strsep(&amp;args, <span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">skynet_context</span> * <span class="title">inst</span> =</span> skynet_context_new(mod,args);<span class="comment">//mod是 &quot;snlua&quot;  args是 &quot;launcher&quot;</span></span><br><span class="line"><span class="keyword">if</span> (inst == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">id_to_hex(context-&gt;result, inst-&gt;handle);<span class="comment">//把8位16进制的handle用字符串表示 注意是以冒号开头</span></span><br><span class="line"><span class="keyword">return</span> context-&gt;result;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们看到 9行，就感觉有点熟悉了。因为我们的logger服务当初也是这样创建的。<a href="https://www.cnblogs.com/waittingforyou/p/logger%E6%9C%8D%E5%8A%A1.md">回顾logger服务</a>。再次看看skynet_context_new</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> skynet_context * </span><br><span class="line"><span class="title function_">skynet_context_new</span><span class="params">(<span class="type">const</span> <span class="type">char</span> * name, <span class="type">const</span> <span class="type">char</span> *param)</span> &#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">skynet_module</span> * <span class="title">mod</span> =</span> skynet_module_query(name);<span class="comment">//获取模块</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *inst = skynet_module_instance_create(mod);<span class="comment">//根据模块创建对应实例</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">skynet_context</span> * <span class="title">ctx</span> =</span> skynet_malloc(<span class="keyword">sizeof</span>(*ctx));</span><br><span class="line"></span><br><span class="line">ctx-&gt;handle = skynet_handle_register(ctx);<span class="comment">//获取一个handle</span></span><br><span class="line">    </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">message_queue</span> * <span class="title">queue</span> =</span> ctx-&gt;<span class="built_in">queue</span> = skynet_mq_create(ctx-&gt;handle);<span class="comment">//创建服务的队列</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> r = skynet_module_instance_init(mod, inst, ctx, param);<span class="comment">//初始化模块实例 param是 launcher</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> (r == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">skynet_context</span> * <span class="title">ret</span> =</span> skynet_context_release(ctx);</span><br><span class="line"><span class="keyword">if</span> (ret) &#123;</span><br><span class="line">ctx-&gt;init = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">skynet_globalmq_push(<span class="built_in">queue</span>);<span class="comment">//服务队列加入全局队列</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>skynet_context_new 是创建一个服务，snlua服务跟logger服务创建过程大致类似。主要不同点在于他们属于不同的模块,所以对应模块的创建函数和初始化函数是不同的。我们主要看snlua模块的初始化实例的函数 snlua_init</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">char</span> *</span><br><span class="line"><span class="title function_">cmd_reg</span><span class="params">(<span class="keyword">struct</span> skynet_context * context, <span class="type">const</span> <span class="type">char</span> * param)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (param == <span class="literal">NULL</span> || param[<span class="number">0</span>] == <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line"><span class="built_in">sprintf</span>(context-&gt;result, <span class="string">&quot;:%x&quot;</span>, context-&gt;handle);<span class="comment">//%x 表示无符号十六进制整数</span></span><br><span class="line"><span class="keyword">return</span> context-&gt;result;<span class="comment">//开头是冒号</span></span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">snlua_init</span><span class="params">(<span class="keyword">struct</span> snlua *l, <span class="keyword">struct</span> skynet_context *ctx, <span class="type">const</span> <span class="type">char</span> * args)</span> &#123;</span><br><span class="line"><span class="type">int</span> sz = <span class="built_in">strlen</span>(args);<span class="comment">//此时 args 是 &quot;launcher&quot;</span></span><br><span class="line"><span class="type">char</span> * tmp = skynet_malloc(sz);</span><br><span class="line"><span class="built_in">memcpy</span>(tmp, args, sz);</span><br><span class="line">skynet_callback(ctx, l , launch_cb);<span class="comment">//服务队列里面第一个消息的处理 会调用launch_cb</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> * self = skynet_command(ctx, <span class="string">&quot;REG&quot;</span>, <span class="literal">NULL</span>);<span class="comment">//最终调用 cmd_reg</span></span><br><span class="line"><span class="type">uint32_t</span> handle_id = strtoul(self+<span class="number">1</span>, <span class="literal">NULL</span>, <span class="number">16</span>);<span class="comment">//将字符串转换成unsigned long(无符号长整型数)</span></span><br><span class="line"><span class="comment">// it must be first message</span></span><br><span class="line">skynet_send(ctx, <span class="number">0</span>, handle_id, PTYPE_TAG_DONTCOPY,<span class="number">0</span>, tmp, sz);<span class="comment">//倒数第三个参数为0 表示 session</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>主要做了两件事。</p><ul><li>skynet_callback 设置服务的回调函数 ，也就是处理队列中消息时使用的函数。这里设置的是 launch_cb</li><li>skynet_send 往自己的队列中push了一个消息。</li></ul><p>到这里 skynet_context_new 的处理完成。</p><p>我们再次回到调用 skynet_context_new 的地方</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">char</span> *</span><br><span class="line"><span class="title function_">cmd_launch</span><span class="params">(<span class="keyword">struct</span> skynet_context * context, <span class="type">const</span> <span class="type">char</span> * param)</span> &#123;</span><br><span class="line"><span class="type">size_t</span> sz = <span class="built_in">strlen</span>(param);</span><br><span class="line"><span class="type">char</span> tmp[sz+<span class="number">1</span>];</span><br><span class="line"><span class="built_in">strcpy</span>(tmp,param);</span><br><span class="line"><span class="type">char</span> * args = tmp;</span><br><span class="line"><span class="type">char</span> * mod = strsep(&amp;args, <span class="string">&quot; \t\r\n&quot;</span>);</span><br><span class="line">args = strsep(&amp;args, <span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">skynet_context</span> * <span class="title">inst</span> =</span> skynet_context_new(mod,args);<span class="comment">//mod是 &quot;snlua&quot;  args是 &quot;launcher&quot;</span></span><br><span class="line"></span><br><span class="line">    id_to_hex(context-&gt;result, inst-&gt;handle);<span class="comment">//把8位16进制的handle用字符串表示 注意是以冒号开头</span></span><br><span class="line">    <span class="keyword">return</span> context-&gt;result;<span class="comment">//里面存的是这种&quot;:123123bb&quot;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们看 12行 最终返回了 新服务的地址。再回到lua层的起点</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">skynet.launch</span><span class="params">(...)</span></span></span><br><span class="line"><span class="keyword">local</span> addr = c.command(<span class="string">&quot;LAUNCH&quot;</span>, <span class="built_in">table</span>.<span class="built_in">concat</span>(&#123;...&#125;,<span class="string">&quot; &quot;</span>))<span class="comment">--next</span></span><br><span class="line"><span class="keyword">if</span> addr <span class="keyword">then</span></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">tonumber</span>(<span class="built_in">string</span>.<span class="built_in">sub</span>(addr , <span class="number">2</span>), <span class="number">16</span>)<span class="comment">--把8位16进制数转变成lua表示的十进制数 /这里把开头的冒号去掉了</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>所以我们调用skynet.launch 最终返回了一个 新服务地址。总结下此时我们所在的bootstarp服务创建了 launcher服务，launcher给它自己的队列里push了第一个消息。launcher队列将来被工作线程执行到时,就会开始处理这个消息。</p><p><img src="https://img2023.cnblogs.com/blog/493645/202212/493645-20221208151845761-1525456613.png" alt="image-20220609103022289"></p><h3 id="可能另一个工作线程完成步骤2"><a href="#可能另一个工作线程完成步骤2" class="headerlink" title="可能另一个工作线程完成步骤2"></a>可能另一个工作线程完成步骤2</h3><p>现在假设 有一个工作线程来驱动launcher工作了。那么<strong>第一个消息</strong>的处理会交给 <code>launch_cb</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">launch_cb</span><span class="params">(<span class="keyword">struct</span> skynet_context * context, <span class="type">void</span> *ud, <span class="type">int</span> type, <span class="type">int</span> session, <span class="type">uint32_t</span> source , <span class="type">const</span> <span class="type">void</span> * msg, <span class="type">size_t</span> sz)</span> &#123;</span><br><span class="line">assert(type == <span class="number">0</span> &amp;&amp; session == <span class="number">0</span>);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">snlua</span> *<span class="title">l</span> =</span> ud;</span><br><span class="line"></span><br><span class="line">    skynet_callback(context, <span class="literal">NULL</span>, <span class="literal">NULL</span>);<span class="comment">//这里取消了回调函数 但是最终lua服务的回调函数的设置 是通过lua服务的skynet.start()函数 </span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> err = init_cb(l, context, msg, sz);<span class="comment">//next</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面取消了回调函数。然后调用init_cb。这个函数你暂时需要关注两点。1.代表当前服务的context被保存在注册表中了。以后在需要context时，可以方便的获取。2. 我们最终执行了一个lua文件。这个lua文件就是launcher.lua服务代表的文件。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">init_cb</span><span class="params">(<span class="keyword">struct</span> snlua *l, <span class="keyword">struct</span> skynet_context *ctx, <span class="type">const</span> <span class="type">char</span> * args, <span class="type">size_t</span> sz)</span> &#123;</span><br><span class="line">lua_State *L = l-&gt;L;</span><br><span class="line">l-&gt;ctx = ctx;</span><br><span class="line">lua_gc(L, LUA_GCSTOP, <span class="number">0</span>);</span><br><span class="line">lua_pushboolean(L, <span class="number">1</span>);  <span class="comment">/* signal for libraries to ignore env. vars. */</span></span><br><span class="line">lua_setfield(L, LUA_REGISTRYINDEX, <span class="string">&quot;LUA_NOENV&quot;</span>);</span><br><span class="line">luaL_openlibs(L);</span><br><span class="line">luaL_requiref(L, <span class="string">&quot;skynet.profile&quot;</span>, init_profile, <span class="number">0</span>);<span class="comment">//当你在lua层require &quot;skynet.profile&quot; 的时候会调用c函数 init_profile ,最终返回一张表</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> profile_lib = lua_gettop(L);</span><br><span class="line"><span class="comment">// replace coroutine.resume / coroutine.wrap</span></span><br><span class="line">lua_getglobal(L, <span class="string">&quot;coroutine&quot;</span>);</span><br><span class="line">lua_getfield(L, profile_lib, <span class="string">&quot;resume&quot;</span>);</span><br><span class="line">lua_setfield(L, <span class="number">-2</span>, <span class="string">&quot;resume&quot;</span>);</span><br><span class="line">lua_getfield(L, profile_lib, <span class="string">&quot;wrap&quot;</span>);</span><br><span class="line">lua_setfield(L, <span class="number">-2</span>, <span class="string">&quot;wrap&quot;</span>);</span><br><span class="line"></span><br><span class="line">lua_settop(L, profile_lib<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">lua_pushlightuserdata(L, ctx);</span><br><span class="line">lua_setfield(L, LUA_REGISTRYINDEX, <span class="string">&quot;skynet_context&quot;</span>);<span class="comment">//把ctx设置到当前服务对应的 lua_State 的全局注册表中 key的名字是 &quot;skynet_context&quot;</span></span><br><span class="line">luaL_requiref(L, <span class="string">&quot;skynet.codecache&quot;</span>, codecache , <span class="number">0</span>);<span class="comment">//当你在lua层require &quot;skynet.codecache&quot; 的时候会调用c函数 codecache ,最终返回一张表</span></span><br><span class="line">lua_pop(L,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">lua_gc(L, LUA_GCGEN, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *path = optstring(ctx, <span class="string">&quot;lua_path&quot;</span>,<span class="string">&quot;./lualib/?.lua;./lualib/?/init.lua&quot;</span>);</span><br><span class="line">lua_pushstring(L, path);</span><br><span class="line">lua_setglobal(L, <span class="string">&quot;LUA_PATH&quot;</span>);</span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *cpath = optstring(ctx, <span class="string">&quot;lua_cpath&quot;</span>,<span class="string">&quot;./luaclib/?.so&quot;</span>);</span><br><span class="line">lua_pushstring(L, cpath);</span><br><span class="line">lua_setglobal(L, <span class="string">&quot;LUA_CPATH&quot;</span>);</span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *service = optstring(ctx, <span class="string">&quot;luaservice&quot;</span>, <span class="string">&quot;./service/?.lua&quot;</span>);</span><br><span class="line">lua_pushstring(L, service);</span><br><span class="line">lua_setglobal(L, <span class="string">&quot;LUA_SERVICE&quot;</span>);</span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *preload = skynet_command(ctx, <span class="string">&quot;GETENV&quot;</span>, <span class="string">&quot;preload&quot;</span>);</span><br><span class="line">lua_pushstring(L, preload);</span><br><span class="line">lua_setglobal(L, <span class="string">&quot;LUA_PRELOAD&quot;</span>);</span><br><span class="line"></span><br><span class="line">lua_pushcfunction(L, traceback);</span><br><span class="line">assert(lua_gettop(L) == <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> * loader = optstring(ctx, <span class="string">&quot;lualoader&quot;</span>, <span class="string">&quot;./lualib/loader.lua&quot;</span>);<span class="comment">//我们真正的lua服务文件是被loader.lua文件加载执行的</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> r = luaL_loadfile(L,loader);</span><br><span class="line"></span><br><span class="line">lua_pushlstring(L, args, sz);<span class="comment">//这里的arges是 &quot;launcher&quot;</span></span><br><span class="line">r = lua_pcall(L,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>);<span class="comment">//开始执行lua文件了 这个文件是 loader.lua</span></span><br><span class="line"></span><br><span class="line">lua_settop(L,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (lua_getfield(L, LUA_REGISTRYINDEX, <span class="string">&quot;memlimit&quot;</span>) == LUA_TNUMBER) &#123;</span><br><span class="line"><span class="type">size_t</span> limit = lua_tointeger(L, <span class="number">-1</span>);</span><br><span class="line">l-&gt;mem_limit = limit;</span><br><span class="line">skynet_error(ctx, <span class="string">&quot;Set memory limit to %.2f M&quot;</span>, (<span class="type">float</span>)limit / (<span class="number">1024</span> * <span class="number">1024</span>));</span><br><span class="line">lua_pushnil(L);</span><br><span class="line">lua_setfield(L, LUA_REGISTRYINDEX, <span class="string">&quot;memlimit&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">lua_pop(L, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">lua_gc(L, LUA_GCRESTART, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ul><li>每个snlua服务都有一个 lua_State成员。lua_State代表一个lua环境，没有lua环境，后面是不能把消息交给lua处理的。</li><li>配置文件具体是怎么读取的呢 可以看这里 <a href="https://www.cnblogs.com/waittingforyou/p/16966212.html">skynet启动时读取配置文件</a></li></ul></blockquote><p>我们看上面的lua文件是怎么被执行到的。看 49行。实际上我们第一个执行到的文件是 loader.lua。在这个文件里面，才运行了launcher.lua文件。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- loader.lua</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> args = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> word <span class="keyword">in</span> <span class="built_in">string</span>.<span class="built_in">gmatch</span>(..., <span class="string">&quot;%S+&quot;</span>) <span class="keyword">do</span> </span><br><span class="line"><span class="built_in">table</span>.<span class="built_in">insert</span>(args, word)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">SERVICE_NAME = args[<span class="number">1</span>] <span class="comment">--lua服务指定的文件名字 比如 launcher.lua 对应的名字是 launcher</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> main, pattern</span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> err = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> pat <span class="keyword">in</span> <span class="built_in">string</span>.<span class="built_in">gmatch</span>(LUA_SERVICE, <span class="string">&quot;([^;]+);*&quot;</span>) <span class="keyword">do</span> <span class="comment">--LUA_SERVICE 是存放lua服务对应文件的所有路径 类似 &quot;./service/?.lua;./skynet-1.5.0/test/?.lua;&quot; </span></span><br><span class="line"><span class="keyword">local</span> filename = <span class="built_in">string</span>.<span class="built_in">gsub</span>(pat, <span class="string">&quot;?&quot;</span>, SERVICE_NAME) <span class="comment">---用 launcher替换掉路径配置中的 &quot;?&quot;</span></span><br><span class="line"><span class="keyword">local</span> f, msg = <span class="built_in">loadfile</span>(filename)</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> f <span class="keyword">then</span></span><br><span class="line"><span class="built_in">table</span>.<span class="built_in">insert</span>(err, msg)</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">pattern = pat</span><br><span class="line">main = f</span><br><span class="line"><span class="keyword">break</span> <span class="comment">--这里表示从其中一条路径找到一个文件就够了</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- LUA_PATH LUA_CPATH 这些都是启动skynet时在配置文件里设置的 不过配置文件中使用小写 比如lua_path</span></span><br><span class="line">LUA_SERVICE = <span class="literal">nil</span></span><br><span class="line"><span class="built_in">package</span>.<span class="built_in">path</span> , LUA_PATH = LUA_PATH <span class="comment">--等价于 package.path = LUA_PATH ;LUA_PATH = nil</span></span><br><span class="line"><span class="built_in">package</span>.<span class="built_in">cpath</span> , LUA_CPATH = LUA_CPATH <span class="comment">--等价于 package.cpath = LUA_CPATH ;LUA_CPATH = nil</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--如果pattern类似 ./aaa/bbb/?/main.lua 那么下面返回值service_path是 ./aaa/bbb/?/</span></span><br><span class="line"><span class="comment">--一般情况下pattern类似 ./aaa/bbb/?.lua 那么下面的返回值service_path是 nil</span></span><br><span class="line"><span class="keyword">local</span> service_path = <span class="built_in">string</span>.<span class="built_in">match</span>(pattern, <span class="string">&quot;(.*/)[^/?]+$&quot;</span>) </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> service_path <span class="keyword">then</span></span><br><span class="line">service_path = <span class="built_in">string</span>.<span class="built_in">gsub</span>(service_path, <span class="string">&quot;?&quot;</span>, args[<span class="number">1</span>])</span><br><span class="line"><span class="built_in">package</span>.<span class="built_in">path</span> = service_path .. <span class="string">&quot;?.lua;&quot;</span> .. <span class="built_in">package</span>.<span class="built_in">path</span></span><br><span class="line">SERVICE_PATH = service_path</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">local</span> p = <span class="built_in">string</span>.<span class="built_in">match</span>(pattern, <span class="string">&quot;(.*/).+$&quot;</span>)</span><br><span class="line">SERVICE_PATH = p</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">_G</span>.<span class="built_in">require</span> = (<span class="built_in">require</span> <span class="string">&quot;skynet.require&quot;</span>).<span class="built_in">require</span> <span class="comment">--注意这里首先加载了 skynet.require 然后替换了lua原本的require</span></span><br><span class="line"></span><br><span class="line">main(<span class="built_in">select</span>(<span class="number">2</span>, <span class="built_in">table</span>.<span class="built_in">unpack</span>(args))) <span class="comment">--从这里开始执行我们指定的 lua服务文件</span></span><br></pre></td></tr></table></figure><blockquote><p>lua的模式匹配可以看看这里 <a href="https://www.cnblogs.com/waittingforyou/p/16966219.html">lua模式匹配</a> ；另外 <code>package.path , LUA_PATH = LUA_PATH</code> 这句可以理解为 <code>package.path , LUA_PATH = func()</code>,当前func函数只有一个返回值，但是左边却有两个变量，所以LUA_PATH 只能是nil了</p></blockquote><p>44行 最后开始执行我们的 launcher.lua文件。我们当前只关注下面的代码。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- launcher.lua</span></span><br><span class="line"></span><br><span class="line">skynet.dispatch(<span class="string">&quot;lua&quot;</span>, <span class="function"><span class="keyword">function</span><span class="params">(session, address, cmd , ...)</span></span></span><br><span class="line">cmd = <span class="built_in">string</span>.<span class="built_in">upper</span>(cmd)</span><br><span class="line"><span class="keyword">local</span> f = command[cmd]</span><br><span class="line"><span class="keyword">if</span> f <span class="keyword">then</span></span><br><span class="line"><span class="keyword">local</span> ret = f(address, ...)</span><br><span class="line"><span class="keyword">if</span> ret ~= NORET <span class="keyword">then</span></span><br><span class="line">skynet.ret(skynet.pack(ret))</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">skynet.ret(skynet.pack &#123;<span class="string">&quot;Unknown command&quot;</span>&#125; )</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span>)</span><br><span class="line"></span><br><span class="line">skynet.start(<span class="function"><span class="keyword">function</span><span class="params">()</span></span> <span class="keyword">end</span>)</span><br></pre></td></tr></table></figure><p>也就是说执行launcher.lua文件，主要是调用了上面两个函数。skynet.dispatch注册了 lua类型消息的回调函数。也就是收到lua类型消息时,都交给这个函数处理。另外一个是skynet.start函数。skynet.start主要做了两件事。1. 注册回调函数 2.注册一个定时器</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">skynet.start</span><span class="params">(start_func)</span></span></span><br><span class="line">c.callback(skynet.dispatch_message)<span class="comment">--注册c层处理消息的回调函数,最终会把消息转交给lua层的函数</span></span><br><span class="line">init_thread = skynet.timeout(<span class="number">0</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span></span><span class="comment">--注册一个定时器</span></span><br><span class="line">skynet.init_service(start_func)</span><br><span class="line">init_thread = <span class="literal">nil</span></span><br><span class="line"><span class="keyword">end</span>)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>第2行是注册回调函数 我们看代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">lcallback</span><span class="params">(lua_State *L)</span> &#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">skynet_context</span> * <span class="title">context</span> =</span> lua_touserdata(L, lua_upvalueindex(<span class="number">1</span>));</span><br><span class="line"><span class="type">int</span> forward = lua_toboolean(L, <span class="number">2</span>);</span><br><span class="line">luaL_checktype(L,<span class="number">1</span>,LUA_TFUNCTION);</span><br><span class="line">lua_settop(L,<span class="number">1</span>);</span><br><span class="line">lua_rawsetp(L, LUA_REGISTRYINDEX, _cb);<span class="comment">//相当于 注册表[_cb] = fun</span></span><br><span class="line"></span><br><span class="line">lua_rawgeti(L, LUA_REGISTRYINDEX, LUA_RIDX_MAINTHREAD);</span><br><span class="line">lua_State *gL = lua_tothread(L,<span class="number">-1</span>);<span class="comment">//获取我们的主协程 也就是当前lua层调用skynet.start所在的协程</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">skynet_callback(context, gL, _cb);<span class="comment">//lua服务注册回调函数 在回调函数里面会调用lua应用层的消息分发函数skynet.dispatch_message</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意上面的 13行，注册了服务的回调函数 _cb。我们看看当我们服务收到消息时,是怎么处理的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line">_cb(<span class="keyword">struct</span> skynet_context * context, <span class="type">void</span> * ud, <span class="type">int</span> type, <span class="type">int</span> session, <span class="type">uint32_t</span> source, <span class="type">const</span> <span class="type">void</span> * msg, <span class="type">size_t</span> sz) &#123;</span><br><span class="line">lua_State *L = ud;<span class="comment">//这里是主协程</span></span><br><span class="line"><span class="type">int</span> trace = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> r;</span><br><span class="line"><span class="type">int</span> top = lua_gettop(L);</span><br><span class="line"><span class="keyword">if</span> (top == <span class="number">0</span>) &#123;</span><br><span class="line">lua_pushcfunction(L, traceback);</span><br><span class="line">lua_rawgetp(L, LUA_REGISTRYINDEX, _cb);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">assert(top == <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line">lua_pushvalue(L,<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">lua_pushinteger(L, type);</span><br><span class="line">lua_pushlightuserdata(L, (<span class="type">void</span> *)msg);</span><br><span class="line">lua_pushinteger(L,sz);</span><br><span class="line">lua_pushinteger(L, session);</span><br><span class="line">lua_pushinteger(L, source);</span><br><span class="line"></span><br><span class="line">r = lua_pcall(L, <span class="number">5</span>, <span class="number">0</span> , trace);<span class="comment">//调用lua层的skynet.dispatch_message 其参数是prototype, msg, sz, session, source</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (r == LUA_OK) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意 21行 最终把 消息的五个参数 传递给了lua层。接下来关注注册定时器的代码。关于定时器的使用，可以看看这里 <a href="https://www.cnblogs.com/waittingforyou/p/16966224.html">初试定时器</a></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">skynet.init_service</span><span class="params">(start)</span></span></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line">skynet_require.init_all()</span><br><span class="line">start() <span class="comment">--这个就是我们的start_func函数。可以认为是lua层的main函数</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">local</span> ok, err = <span class="built_in">xpcall</span>(main, <span class="built_in">traceback</span>)</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> ok <span class="keyword">then</span></span><br><span class="line">skynet.<span class="built_in">error</span>(<span class="string">&quot;init service failed: &quot;</span> .. <span class="built_in">tostring</span>(err))</span><br><span class="line">skynet.send(<span class="string">&quot;.launcher&quot;</span>,<span class="string">&quot;lua&quot;</span>, <span class="string">&quot;ERROR&quot;</span>)</span><br><span class="line">skynet.<span class="built_in">exit</span>()</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">skynet.send(<span class="string">&quot;.launcher&quot;</span>,<span class="string">&quot;lua&quot;</span>, <span class="string">&quot;LAUNCHOK&quot;</span>)<span class="comment">--任何服务在完成start后 都会发送LAUNCHOK 消息给 launcher服务</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">skynet.start</span><span class="params">(start_func)</span></span></span><br><span class="line">c.callback(skynet.dispatch_message)<span class="comment">--注册c层处理消息的回调函数,最终会把消息转交给lua层的函数</span></span><br><span class="line">init_thread = skynet.timeout(<span class="number">0</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span></span><span class="comment">--注册一个定时器</span></span><br><span class="line">skynet.init_service(start_func)</span><br><span class="line">init_thread = <span class="literal">nil</span></span><br><span class="line"><span class="keyword">end</span>)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>上面代码注册了一个定时器。定时器会获取一个协程，这个协程的任务函数是一个 匿名函数。当定时器触发时,匿名函数被执行，这个匿名函数内部会调用我们注册的启动函数 start_func ，然后会发送一个消息通知 launcher。回到我们 launcher.lua文件</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- launcher.lua</span></span><br><span class="line"></span><br><span class="line">skynet.dispatch(<span class="string">&quot;lua&quot;</span>, <span class="function"><span class="keyword">function</span><span class="params">(session, address, cmd , ...)</span></span></span><br><span class="line">cmd = <span class="built_in">string</span>.<span class="built_in">upper</span>(cmd)</span><br><span class="line"><span class="keyword">local</span> f = command[cmd]</span><br><span class="line"><span class="keyword">if</span> f <span class="keyword">then</span></span><br><span class="line"><span class="keyword">local</span> ret = f(address, ...)</span><br><span class="line"><span class="keyword">if</span> ret ~= NORET <span class="keyword">then</span></span><br><span class="line">skynet.ret(skynet.pack(ret))</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">skynet.ret(skynet.pack &#123;<span class="string">&quot;Unknown command&quot;</span>&#125; )</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span>)</span><br><span class="line"></span><br><span class="line">skynet.start(<span class="function"><span class="keyword">function</span><span class="params">()</span></span> <span class="keyword">end</span>)</span><br></pre></td></tr></table></figure><p>我们发现 我们通过skynet.start注册的star_func函数没有做任何事情。最后定时器协程被回收了。此时认为launcher服务启动完成了。over</p>]]></content>
      
      
      <categories>
          
          <category> skynet </category>
          
      </categories>
      
      
        <tags>
            
            <tag> skynet </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Skynet_logger服务</title>
      <link href="/FrameWork/Skynet/Skynet_%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/Skynet_logger%E6%9C%8D%E5%8A%A1/Skynet_logger%E6%9C%8D%E5%8A%A1"/>
      <url>/FrameWork/Skynet/Skynet_%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/Skynet_logger%E6%9C%8D%E5%8A%A1/Skynet_logger%E6%9C%8D%E5%8A%A1</url>
      
        <content type="html"><![CDATA[<h1 id="Skynet-logger服务"><a href="#Skynet-logger服务" class="headerlink" title="Skynet_logger服务"></a>Skynet_logger服务</h1><p>日志服务使用举例：默认是写到<code>stdout</code></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">skynet.<span class="built_in">error</span>(<span class="string">&quot;hello world&quot;</span>)</span><br></pre></td></tr></table></figure><p>写日志主要分三步：</p><ol><li>logger日志服务创建</li><li>把日志转变成 <code>skynet_message</code> 然后push到日志服务队列</li><li>日志服务处理消息时把日志提取出来，写入文件或者标准输出。</li></ol><h2 id="logger服务创建"><a href="#logger服务创建" class="headerlink" title="logger服务创建"></a>logger服务创建</h2><p> <code>skynet_main</code> ：读取配置中的日志服务（主要展示<code>logger</code>配置的获取）</p><ol><li><code>config.logger</code> ：保存日志的文件名字</li><li><code>config.logservice</code> ：默认日志模块</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">skynet_config</span> <span class="title">config</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">lua_State</span> *<span class="title">L</span> =</span> luaL_newstate();<span class="comment">//生成luastate的目的主要是读取配置文件中的配置项</span></span><br><span class="line">luaL_openlibs(L);<span class="comment">// 链接 lua 库</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> err =  luaL_loadbufferx(L, load_config, <span class="built_in">strlen</span>(load_config), <span class="string">&quot;=[skynet config]&quot;</span>, <span class="string">&quot;t&quot;</span>);</span><br><span class="line">assert(err == LUA_OK);</span><br><span class="line">lua_pushstring(L, config_file);</span><br><span class="line"></span><br><span class="line">err = lua_pcall(L, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>);<span class="comment">//执行配置文件</span></span><br><span class="line"></span><br><span class="line">_init_env(L);</span><br><span class="line">    </span><br><span class="line"><span class="comment">//把配置文件里面的配置项 都读出来</span></span><br><span class="line">config.logger = optstring(<span class="string">&quot;logger&quot;</span>, <span class="literal">NULL</span>);<span class="comment">//保存日志的文件名字</span></span><br><span class="line">config.logservice = optstring(<span class="string">&quot;logservice&quot;</span>, <span class="string">&quot;logger&quot;</span>);<span class="comment">//默认日志模块是 logger 即 service_logger.c 所代表的模块</span></span><br><span class="line">config.profile = optboolean(<span class="string">&quot;profile&quot;</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">lua_close(L);</span><br><span class="line"></span><br><span class="line">skynet_start(&amp;config);<span class="comment">//next</span></span><br><span class="line">skynet_globalexit();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> <code>skynet_start</code> ：通过 <code>skynet_context_new</code> 创建<code>logger</code>日志服务（主要展示<code>logger</code> 的创建）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> </span><br><span class="line"><span class="title function_">skynet_start</span><span class="params">(<span class="keyword">struct</span> skynet_config * config)</span> &#123;</span><br><span class="line"></span><br><span class="line">skynet_harbor_init(config-&gt;harbor);</span><br><span class="line">skynet_handle_init(config-&gt;harbor);</span><br><span class="line">skynet_mq_init();</span><br><span class="line">skynet_module_init(config-&gt;module_path);</span><br><span class="line">skynet_timer_init();</span><br><span class="line">skynet_socket_init();</span><br><span class="line"></span><br><span class="line">  <span class="comment">//创建日志服务</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">skynet_context</span> *<span class="title">ctx</span> =</span> skynet_context_new(config-&gt;logservice, config-&gt;logger);<span class="comment">//参数分别是 &quot;logger&quot; NULL</span></span><br><span class="line">skynet_handle_namehandle(skynet_context_handle(ctx), <span class="string">&quot;logger&quot;</span>);<span class="comment">//给日志服务绑定一个名字</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> <code>skynet_context_new</code>  ：通过名字获取模块并创建一个服务（主要展示服务的创建）</p><ol><li>通过名字获取模块 <code>m</code> (模块实际上就是一些函数集合在一起,用来专门实现某种功能)</li><li>使用模块的实例化函数,实例化一个对象（eg： <code>inst = m.create()</code> 就是创建了一个实例）</li><li>使用某个模块的函数处理某个实例化对象（eg： <code>m.init(inst,param)</code>、 <code>m.xxx(inst,param)</code> 、 <code>m.yyy(inst,param)</code> ）</li><li>使用完后，释放对应实例（eg： <code>m.relaase(inst)</code> ）</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> skynet_context * </span><br><span class="line"><span class="title function_">skynet_context_new</span><span class="params">(<span class="type">const</span> <span class="type">char</span> * name, <span class="type">const</span> <span class="type">char</span> *param)</span> &#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">skynet_module</span> * <span class="title">mod</span> =</span> skynet_module_query(name);<span class="comment">//获取模块</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *inst = skynet_module_instance_create(mod);<span class="comment">//根据模块创建对应实例</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">skynet_context</span> * <span class="title">ctx</span> =</span> skynet_malloc(<span class="keyword">sizeof</span>(*ctx));<span class="comment">//内存分配</span></span><br><span class="line">CHECKCALLING_INIT(ctx)</span><br><span class="line"></span><br><span class="line">ctx-&gt;mod = mod;<span class="comment">//模块</span></span><br><span class="line">ctx-&gt;instance = inst;<span class="comment">//模块的实例</span></span><br><span class="line">ATOM_INIT(&amp;ctx-&gt;ref , <span class="number">2</span>);<span class="comment">//初始化引用数为 2</span></span><br><span class="line">ctx-&gt;cb = <span class="literal">NULL</span>;</span><br><span class="line">ctx-&gt;cb_ud = <span class="literal">NULL</span>;</span><br><span class="line">ctx-&gt;session_id = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 应该先设置为0，以避免 skynet_handle_retireall 得到一个未初始化的handle。不设置为的话是一个随机值。如果注册没有返回前，回收开始执行，回收会从ctx里面拿handle，导致拿到一个随机值当handle</span></span><br><span class="line">ctx-&gt;handle = <span class="number">0</span>;</span><br><span class="line">ctx-&gt;handle = skynet_handle_register(ctx);<span class="comment">//每个服务分配一个唯一的handle</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">message_queue</span> * <span class="title">queue</span> =</span> ctx-&gt;<span class="built_in">queue</span> = skynet_mq_create(ctx-&gt;handle);<span class="comment">//创建一个私有队列</span></span><br><span class="line">  <span class="comment">// init 函数可能使用了ctx-&gt;handle，所以最后必须初始化</span></span><br><span class="line">context_inc();<span class="comment">//服务总数加一个</span></span><br><span class="line"></span><br><span class="line">CHECKCALLING_BEGIN(ctx)</span><br><span class="line"><span class="type">int</span> r = skynet_module_instance_init(mod, inst, ctx, param);</span><br><span class="line">CHECKCALLING_END(ctx)</span><br><span class="line"><span class="keyword">if</span> (r == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">skynet_context</span> * <span class="title">ret</span> =</span> skynet_context_release(ctx);<span class="comment">//减少引用一次 </span></span><br><span class="line"><span class="keyword">if</span> (ret) &#123;</span><br><span class="line">ctx-&gt;init = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">skynet_globalmq_push(<span class="built_in">queue</span>);<span class="comment">//服务队列加入全局队列</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h3><p> <code>skynet_main</code> 在初始化读取配置信息时，有如下代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">config.module_path = optstring(<span class="string">&quot;cpath&quot;</span>,<span class="string">&quot;./cservice/?.so&quot;</span>);<span class="comment">//默认路径下的动态链接库有gate.so  harbor.so  logger.so  snlua.so 常用snlua.so来创建模块实例</span></span><br></pre></td></tr></table></figure><p>在 <code>config.module_path</code> 目录下有以so为后缀的文件。xxx.so就对应一个模块。假设某个模块第一次被查询。</p><p> <code>skynet_module_query(name)</code> 获取模块的具体步骤是：根据名字读取指定路径下的 xxx.so文件。把文件里面的函数提取出来作为一个模块缓存起来，返回对应模块。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">open_sym</span><span class="params">(<span class="keyword">struct</span> skynet_module *mod)</span> &#123;</span><br><span class="line">mod-&gt;create = get_api(mod, <span class="string">&quot;_create&quot;</span>);<span class="comment">//创建模块的实例</span></span><br><span class="line">mod-&gt;init = get_api(mod, <span class="string">&quot;_init&quot;</span>);<span class="comment">//对实例进行初始化</span></span><br><span class="line">mod-&gt;release = get_api(mod, <span class="string">&quot;_release&quot;</span>);</span><br><span class="line">mod-&gt;signal = get_api(mod, <span class="string">&quot;_signal&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> mod-&gt;init == <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> skynet_module * </span><br><span class="line"><span class="title function_">skynet_module_query</span><span class="params">(<span class="type">const</span> <span class="type">char</span> * name)</span> &#123;<span class="comment">//next</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">skynet_module</span> * <span class="title">result</span> =</span> _query(name);<span class="comment">//查询 </span></span><br><span class="line"><span class="keyword">if</span> (result)<span class="comment">//说明不是第一次查询 因为已经缓存了 则直接返回</span></span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">SPIN_LOCK(M)</span><br><span class="line"></span><br><span class="line">result = _query(name); <span class="comment">// double check</span></span><br><span class="line"><span class="comment">//如果是第一次查询</span></span><br><span class="line"><span class="keyword">if</span> (result == <span class="literal">NULL</span> &amp;&amp; M-&gt;count &lt; MAX_MODULE_TYPE) &#123;<span class="comment">//某个模块是第一次被查询 </span></span><br><span class="line"><span class="type">int</span> index = M-&gt;count;<span class="comment">//M可以认为是一个模块集合, 里面保存了所有模块 index是为新添加的模块分配一个位置</span></span><br><span class="line"><span class="type">void</span> * dl = _try_open(M,name);<span class="comment">//打开对应模块对应的so文件</span></span><br><span class="line"><span class="keyword">if</span> (dl) &#123;</span><br><span class="line">M-&gt;m[index].name = name;<span class="comment">//设置对应模块的名字</span></span><br><span class="line">M-&gt;m[index].module = dl;<span class="comment">//设置对应模块对应的动态库</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (open_sym(&amp;M-&gt;m[index]) == <span class="number">0</span>) &#123;<span class="comment">//用动态库里面的函数填充模块</span></span><br><span class="line">M-&gt;m[index].name = skynet_strdup(name);</span><br><span class="line">M-&gt;count ++;</span><br><span class="line">result = &amp;M-&gt;m[index];<span class="comment">//result是返回结果 即模块</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SPIN_UNLOCK(M)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里获取的是 <code>logger.so</code> 对应的模块。由 <code>skynet_context_new</code> 代码，接下来是实例化模块 <code>skynet_module_instance_create</code> 。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> * </span><br><span class="line"><span class="title function_">skynet_module_instance_create</span><span class="params">(<span class="keyword">struct</span> skynet_module *m)</span> &#123;<span class="comment">//next</span></span><br><span class="line"><span class="keyword">if</span> (m-&gt;create) &#123;</span><br><span class="line"><span class="keyword">return</span> m-&gt;create();<span class="comment">//next</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> (<span class="type">void</span> *)(<span class="type">intptr_t</span>)(~<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>logger 模块里面的 <code>create</code> 函数 是从 <code>logger.so</code> 提取出来，而 <code>logger.so</code> 文件是下面这个文件编译出来的。</p><p><img src="https://cdn.jsdelivr.net/gh/Barbecue-g/imagehost/FrameWork/Skynet/%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/Skynet_logger%E6%9C%8D%E5%8A%A1/Skynet_logger.png?raw=true" alt="Skynet_logger"></p><p>logger 模块里面的函数都是在 <code>service_logger.c</code> 里定义的。所以实例化logger模块就是调用下面 <code>logger_create</code> 函数。最终就是内存分配了一个<code>struct logger</code> 。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">logger</span> &#123;</span></span><br><span class="line">FILE * handle;</span><br><span class="line"><span class="type">char</span> * filename;</span><br><span class="line"><span class="type">uint32_t</span> starttime;</span><br><span class="line"><span class="type">int</span> close;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> logger *</span><br><span class="line"><span class="title function_">logger_create</span><span class="params">(<span class="type">void</span>)</span> &#123;<span class="comment">//next</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">logger</span> * <span class="title">inst</span> =</span> skynet_malloc(<span class="keyword">sizeof</span>(*inst));</span><br><span class="line">inst-&gt;handle = <span class="literal">NULL</span>;</span><br><span class="line">inst-&gt;close = <span class="number">0</span>;</span><br><span class="line">inst-&gt;filename = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> inst;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由 <code>skynet_context_new</code> 代码，在实例化模块后, 创建了一个 <code>skynet_context</code> 。每一个服务都会分配一个 <code>handle</code> ，每个服务的队列也会保存这个 <code>handle</code> 。 <code>skynet_handle_register</code>  就是给去注册服务并且获取分配的 <code>handle</code> 。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">uint32_t</span><span class="comment">//next</span></span><br><span class="line">skynet_handle_register(<span class="keyword">struct</span> skynet_context *ctx) &#123;<span class="comment">//注册一个服务 返回为这个服务分配的handle</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">handle_storage</span> *<span class="title">s</span> =</span> H;</span><br><span class="line"></span><br><span class="line">rwlock_wlock(&amp;s-&gt;lock);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="type">uint32_t</span> handle = s-&gt;handle_index;</span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;s-&gt;slot_size;i++,handle++) &#123;</span><br><span class="line"><span class="keyword">if</span> (handle &gt; HANDLE_MASK) &#123;<span class="comment">//handle的高八位是留给harbor的 所以handle用来查找槽位是靠剩下的24位</span></span><br><span class="line"><span class="comment">// 0 is reserved</span></span><br><span class="line">handle = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> hash = handle &amp; (s-&gt;slot_size<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">if</span> (s-&gt;slot[hash] == <span class="literal">NULL</span>) &#123;</span><br><span class="line">s-&gt;slot[hash] = ctx;</span><br><span class="line">s-&gt;handle_index = handle + <span class="number">1</span>;<span class="comment">//下一次分配handle就从这个值开始计算</span></span><br><span class="line"></span><br><span class="line">rwlock_wunlock(&amp;s-&gt;lock);</span><br><span class="line"></span><br><span class="line">handle |= s-&gt;harbor;<span class="comment">//按位或运算，a |= b 等价于 a = a | b。两个二进制位中只要有一个为1，结果位即为1</span></span><br><span class="line"><span class="keyword">return</span> handle;<span class="comment">//返回值由两部分合并而成</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">assert((s-&gt;slot_size*<span class="number">2</span> - <span class="number">1</span>) &lt;= HANDLE_MASK);<span class="comment">//下面这段代码是扩容</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">skynet_context</span> ** <span class="title">new_slot</span> =</span> skynet_malloc(s-&gt;slot_size * <span class="number">2</span> * <span class="keyword">sizeof</span>(<span class="keyword">struct</span> skynet_context *));</span><br><span class="line"><span class="built_in">memset</span>(new_slot, <span class="number">0</span>, s-&gt;slot_size * <span class="number">2</span> * <span class="keyword">sizeof</span>(<span class="keyword">struct</span> skynet_context *));</span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;s-&gt;slot_size;i++) &#123;<span class="comment">//把老槽位里面的服务数据转移到合适的新的槽位中</span></span><br><span class="line"><span class="type">int</span> hash = skynet_context_handle(s-&gt;slot[i]) &amp; (s-&gt;slot_size * <span class="number">2</span> - <span class="number">1</span>);</span><br><span class="line">assert(new_slot[hash] == <span class="literal">NULL</span>);</span><br><span class="line">new_slot[hash] = s-&gt;slot[i];</span><br><span class="line">&#125;</span><br><span class="line">skynet_free(s-&gt;slot);</span><br><span class="line">s-&gt;slot = new_slot;</span><br><span class="line">s-&gt;slot_size *= <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>返回的handle是32位的 ，主要是两部分组成。高8位的habor+剩余24位。剩余的24位才可以认为是ctx所在的槽位。</p><ol><li><p>唯一服务标识</p><ul><li><p><strong>作用</strong>：每个服务在Skynet启动时会被分配一个全局唯一的<code>handle</code>（32位无符号整数）。即使服务退出，其<code>handle</code>也不会被重复使用，确保系统内服务标识的持久性。</p></li><li><p><strong>结构</strong>：</p><p><strong>高8位</strong>：表示<code>harbor id</code>，用于标识集群中的不同节点，最多支持255个节点。</p><p><strong>低24位</strong>：服务在节点内的唯一索引，单个节点最多支持约1600万个服务。</p></li></ul></li><li><p>服务实例管理</p><ul><li><strong>存储结构</strong>：通过<code>handle_storage</code>结构管理所有服务实例的上下文（<code>skynet_context</code>），包含以下组件<ul><li><strong>slot数组</strong>：动态扩容的数组，存储服务实例指针。初始大小为4，满时以2倍扩容（类似C++的<code>vector</code>实现）。</li><li><strong>哈希映射</strong>：<code>handle</code>通过取模运算映射到<code>slot</code>数组的索引，快速定位服务实例。</li></ul></li><li><strong>生命周期</strong>：<ul><li><strong>注册</strong>：<code>skynet_handle_register</code>为新服务分配<code>handle</code>并插入<code>slot</code>数组。</li><li><strong>回收</strong>：服务退出时通过<code>skynet_handle_retire</code>回收<code>handle</code>，并清空<code>slot</code>中的指针。</li></ul></li></ul></li><li><p>跨节点通信</p><ul><li><strong>集群支持</strong>：<code>handle</code>的高8位<code>harbor id</code>允许跨节点通信。例如，节点A的服务可通过<code>harbor id</code>和低24位<code>handle</code>组合定位节点B的服务，实现分布式消息传递。</li><li><strong>消息路由</strong>：发送消息时，目标<code>handle</code>会被解析为<code>harbor id</code>和本地索引，确保消息正确路由至目标节点和服务。</li></ul></li><li><p>名称服务</p><ul><li><strong>名称绑定</strong>：通过<code>skynet_handle_namehandle</code>可为<code>handle</code>注册易读名称（如<code>logger</code>），名称存储在按字典序排序的<code>name</code>数组中，通过二分查找快速定位</li><li><strong>动态管理</strong>：名称与<code>handle</code>的绑定支持动态增删，避免上层逻辑依赖易变的数值<code>handle</code>。</li></ul></li><li><p>消息队列关联</p><ul><li><strong>专属队列</strong>：每个服务拥有一个次级消息队列（<code>message_queue</code>），<code>handle</code>用于在全局队列中标识该队列的归属。</li><li><strong>调度机制</strong>：工作线程（Worker）从全局队列中获取次级队列时，通过<code>handle</code>找到对应的<code>skynet_context</code>，并调用其回调函数处理消息。</li></ul></li><li><p>性能优化</p><ul><li><strong>调度机制</strong>：工作线程（Worker）从全局队列中获取次级队列时，通过<code>handle</code>找到对应的<code>skynet_context</code>，并调用其回调函数处理消息。</li><li><strong>内存效率</strong>：动态扩容的<code>slot</code>和<code>name</code>数组减少内存碎片，同时避免预分配过多资源。</li></ul></li></ol><p>由 <code>skynet_context_new</code> 代码，接下来是创建一个队列 <code>skynet_mq_create</code> 。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">message_queue</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span></span><br><span class="line"><span class="type">uint32_t</span> handle;</span><br><span class="line"><span class="type">int</span> cap;</span><br><span class="line"><span class="type">int</span> head;</span><br><span class="line"><span class="type">int</span> tail;</span><br><span class="line"><span class="type">int</span> release;</span><br><span class="line"><span class="type">int</span> in_global;</span><br><span class="line"><span class="type">int</span> overload;</span><br><span class="line"><span class="type">int</span> overload_threshold;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">skynet_message</span> *<span class="title">queue</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">message_queue</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> message_queue * </span><br><span class="line"><span class="title function_">skynet_mq_create</span><span class="params">(<span class="type">uint32_t</span> handle)</span> &#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">message_queue</span> *<span class="title">q</span> =</span> skynet_malloc(<span class="keyword">sizeof</span>(*q));</span><br><span class="line">q-&gt;handle = handle;</span><br><span class="line">q-&gt;cap = DEFAULT_QUEUE_SIZE;<span class="comment">//64</span></span><br><span class="line">q-&gt;head = <span class="number">0</span>;</span><br><span class="line">q-&gt;tail = <span class="number">0</span>;</span><br><span class="line">SPIN_INIT(q)</span><br><span class="line"><span class="comment">// 当创建队列时（总是在服务创建和服务初始化之间）。</span></span><br><span class="line"><span class="comment">// 设置 in_global 标志以避免将其推送到全局队列。</span></span><br><span class="line"><span class="comment">// 如果服务初始化成功，skynet_context_new 将调用 skynet_mq_push 将其推送到全局队列。</span></span><br><span class="line">q-&gt;in_global = MQ_IN_GLOBAL;</span><br><span class="line">q-&gt;release = <span class="number">0</span>;</span><br><span class="line">q-&gt;overload = <span class="number">0</span>;<span class="comment">//记录过载状态时的负载是多少</span></span><br><span class="line">q-&gt;overload_threshold = MQ_OVERLOAD;<span class="comment">//过载的警戒线</span></span><br><span class="line">q-&gt;<span class="built_in">queue</span> = skynet_malloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> skynet_message) * q-&gt;cap);</span><br><span class="line">q-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> q;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由 <code>skynet_context_new</code> 代码，对模块的实例进行初始化 <code>skynet_module_instance_init</code> 。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">skynet_module_instance_init</span><span class="params">(<span class="keyword">struct</span> skynet_module *m, <span class="type">void</span> * inst, <span class="keyword">struct</span> skynet_context *ctx, <span class="type">const</span> <span class="type">char</span> * parm)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> m-&gt;init(inst, ctx, parm);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由 <code>skynet_module_instance_init</code> 代码，在 <code>service_logger.c</code> 找对应的函数 <code>logger_init</code> ，对模块的实例的各个成员进行填充。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">logger_init</span><span class="params">(<span class="keyword">struct</span> logger * inst, <span class="keyword">struct</span> skynet_context *ctx, <span class="type">const</span> <span class="type">char</span> * parm)</span> &#123;<span class="comment">//next</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> * r = skynet_command(ctx, <span class="string">&quot;STARTTIME&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line">inst-&gt;starttime = strtoul(r, <span class="literal">NULL</span>, <span class="number">10</span>);</span><br><span class="line"><span class="keyword">if</span> (parm) &#123;<span class="comment">//判断parm参数文件是否存在</span></span><br><span class="line">inst-&gt;handle = fopen(parm,<span class="string">&quot;a&quot;</span>);<span class="comment">//这里的handle是打开的系统文件描述符 不要和skynet服务的handle搞混了</span></span><br><span class="line"><span class="keyword">if</span> (inst-&gt;handle == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">inst-&gt;filename = skynet_malloc(<span class="built_in">strlen</span>(parm)+<span class="number">1</span>);<span class="comment">//申请文件名所需字符内存</span></span><br><span class="line"><span class="built_in">strcpy</span>(inst-&gt;filename, parm);</span><br><span class="line">inst-&gt;close = <span class="number">1</span>;<span class="comment">//表示在释放的时候 需要关闭文件描述符</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;<span class="comment">//默认情况下是走这里</span></span><br><span class="line">inst-&gt;handle = <span class="built_in">stdout</span>;<span class="comment">//没有配置日志写入哪个文件 就写入标准输出 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (inst-&gt;handle) &#123;<span class="comment">//next</span></span><br><span class="line">skynet_callback(ctx, inst, logger_cb);<span class="comment">//设置模块实例 和 回调函数</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;<span class="comment">//走到这里表示已经出现错误了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：默认情况下日志服务是把日志写到标准输出的。</p></blockquote><p>由 <code>logger_init</code> 代码，设置模块实例和回调函数，调用 <code>skynet_callback</code> 函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> </span><br><span class="line"><span class="title function_">skynet_callback</span><span class="params">(<span class="keyword">struct</span> skynet_context * context, <span class="type">void</span> *ud, skynet_cb cb)</span> &#123;</span><br><span class="line">context-&gt;cb = cb;</span><br><span class="line">context-&gt;cb_ud = ud;<span class="comment">//就是logger实例</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意: <code>skynet_callback</code> 绑定了日志服务的回调函数。当日志服务队列里面有消息需要处理时,就交给这个回调函数去做。</p></blockquote><p>由 <code>skynet_context_new</code> 代码，接下来调用 <code>skynet_globalmq_push</code> 把之前创建的服务队列加入到全局队列。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> </span><br><span class="line"><span class="title function_">skynet_globalmq_push</span><span class="params">(<span class="keyword">struct</span> message_queue * <span class="built_in">queue</span>)</span> &#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">global_queue</span> *<span class="title">q</span>=</span> Q;</span><br><span class="line"></span><br><span class="line">SPIN_LOCK(q)</span><br><span class="line">assert(<span class="built_in">queue</span>-&gt;next == <span class="literal">NULL</span>);<span class="comment">//要求queue必须是独立的 </span></span><br><span class="line"><span class="keyword">if</span>(q-&gt;tail) &#123;</span><br><span class="line">q-&gt;tail-&gt;next = <span class="built_in">queue</span>;</span><br><span class="line">q-&gt;tail = <span class="built_in">queue</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">q-&gt;head = q-&gt;tail = <span class="built_in">queue</span>;</span><br><span class="line">&#125;</span><br><span class="line">SPIN_UNLOCK(q)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查看 <code>skynet_start</code> 代码，到这里通过 <code>skynet_context_new</code> 创建日志服务的代码总算调用完成了。</p><p>实际上在 lua 层调用 <code>skynet.error(str)</code> 写日志的基本原理是：</p><ol><li>首先把要写入的字符串信息包装成一个 <code>skynet_message</code> 。</li><li>push到日志服务的队列。</li><li>之后工作线程检查到日志队列中有消息,则取出消息,并调用日志服务的回调函数处理。</li></ol><p> 通过 <code>skynet基本概况</code> 里面介绍就知道,日志服务和 <code>bootstrap</code> 服务创建后，才启动了多种线程。也就是说，如果当前日志服务里面有消息，也是不会输出的，因为还没有 工作线程 来驱动日志服务干活。</p><h2 id="push消息到日志服务队列"><a href="#push消息到日志服务队列" class="headerlink" title="push消息到日志服务队列"></a>push消息到日志服务队列</h2><p>logger服务已经有了，可以调用 <code>skynet.error(&quot;hello&quot;)</code> 写日志。在 <code>skynet.lua</code> 中定义如下：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> c = <span class="built_in">require</span> <span class="string">&quot;skynet.core&quot;</span> <span class="comment">--这里实际上是一个c库 全局查找一下 skynet_core 即可知道这个库里面都往lua里面塞了什么函数</span></span><br><span class="line"></span><br><span class="line">skynet.<span class="built_in">error</span> = c.<span class="built_in">error</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Barbecue-g/imagehost/FrameWork/Skynet/%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/Skynet_logger%E6%9C%8D%E5%8A%A1/Skynet_core.png?raw=true" alt="Skynet_core"></p><p>在lua中写下 <code>require &quot;skynet.core&quot;</code> ，可以认为就是调用了 c层函数 <code>luaopen_skynet_core</code> ，最后返回了一个lua表。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">LUAMOD_API <span class="type">int</span></span><br><span class="line"><span class="title function_">luaopen_skynet_core</span><span class="params">(lua_State *L)</span> &#123;</span><br><span class="line">luaL_checkversion(L);</span><br><span class="line"></span><br><span class="line">luaL_Reg l[] = &#123;</span><br><span class="line"></span><br><span class="line">&#123; <span class="string">&quot;error&quot;</span>, lerror &#125;,<span class="comment">//这次关注的</span></span><br><span class="line"></span><br><span class="line">&#123; <span class="literal">NULL</span>, <span class="literal">NULL</span> &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// functions without skynet_context</span></span><br><span class="line">luaL_Reg l2[] = &#123;</span><br><span class="line">&#123; <span class="string">&quot;tostring&quot;</span>, ltostring &#125;,</span><br><span class="line">&#123; <span class="string">&quot;pack&quot;</span>, luaseri_pack &#125;,</span><br><span class="line">&#123; <span class="literal">NULL</span>, <span class="literal">NULL</span> &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">lua_createtable(L, <span class="number">0</span>, <span class="keyword">sizeof</span>(l)/<span class="keyword">sizeof</span>(l[<span class="number">0</span>]) + <span class="keyword">sizeof</span>(l2)/<span class="keyword">sizeof</span>(l2[<span class="number">0</span>]) <span class="number">-2</span>);<span class="comment">//给lua创建一个表 x </span></span><br><span class="line"></span><br><span class="line">lua_getfield(L, LUA_REGISTRYINDEX, <span class="string">&quot;skynet_context&quot;</span>);<span class="comment">//拿到注册索引</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">skynet_context</span> *<span class="title">ctx</span> =</span> lua_touserdata(L,<span class="number">-1</span>);<span class="comment">//从注册表中拿到了ctx</span></span><br><span class="line"><span class="keyword">if</span> (ctx == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> luaL_error(L, <span class="string">&quot;Init skynet context first&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">luaL_setfuncs(L,l,<span class="number">1</span>);<span class="comment">//把l中的函数填充到表x中 并共享上值 ctx</span></span><br><span class="line"></span><br><span class="line">luaL_setfuncs(L,l2,<span class="number">0</span>);<span class="comment">//把l2中的函数填充到表x中 但没有共享的上值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码主要是把函数塞进返回的lua表中。所以调用 <code>skynet.error</code> 实际上是调用c函数 <code>lerror</code> 。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">lerror</span><span class="params">(lua_State *L)</span> &#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">skynet_context</span> * <span class="title">context</span> =</span> lua_touserdata(L, lua_upvalueindex(<span class="number">1</span>));<span class="comment">//获取context</span></span><br><span class="line"><span class="type">int</span> n = lua_gettop(L);</span><br><span class="line"></span><br><span class="line">luaL_Buffer b;</span><br><span class="line">luaL_buffinit(L, &amp;b);</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line">luaL_tolstring(L, i, <span class="literal">NULL</span>);</span><br><span class="line">luaL_addvalue(&amp;b);</span><br><span class="line"><span class="keyword">if</span> (i&lt;n) &#123;</span><br><span class="line">luaL_addchar(&amp;b, <span class="string">&#x27; &#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">luaL_pushresult(&amp;b);</span><br><span class="line">skynet_error(context, <span class="string">&quot;%s&quot;</span>, lua_tostring(L, <span class="number">-1</span>));<span class="comment">//next</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码最后调用了 <code>skynet_error</code> 里面有个参数是 <code>context</code> 。 <code>context</code> 表示的是lua层调用 <code>skynet.error</code> 时所在的服务。</p><p>实际上服务是分为不同类型的。skynet主要关注的服务是 <code>snlua</code> 类型。</p><p><img src="https://cdn.jsdelivr.net/gh/Barbecue-g/imagehost/FrameWork/Skynet/%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/Skynet_logger%E6%9C%8D%E5%8A%A1/Skynet_snlua.png?raw=true" alt="snlua处理过程"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">skynet_message</span> &#123;</span></span><br><span class="line"><span class="type">uint32_t</span> source;<span class="comment">//源lua服务</span></span><br><span class="line"><span class="type">int</span> session;</span><br><span class="line"><span class="type">void</span> * data;</span><br><span class="line"><span class="type">size_t</span> sz;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> *</span><br><span class="line"><span class="title function_">skynet_strdup</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str)</span> &#123;</span><br><span class="line"><span class="type">size_t</span> sz = <span class="built_in">strlen</span>(str);</span><br><span class="line"><span class="type">char</span> * ret = skynet_malloc(sz+<span class="number">1</span>);<span class="comment">//分配内存</span></span><br><span class="line"><span class="built_in">memcpy</span>(ret, str, sz+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="comment">//</span></span><br><span class="line">skynet_error(<span class="keyword">struct</span> skynet_context * context, <span class="type">const</span> <span class="type">char</span> *msg, ...) &#123;<span class="comment">//context主要用来设置 skynet_message 的source属性</span></span><br><span class="line"><span class="type">static</span> <span class="type">uint32_t</span> logger = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (logger == <span class="number">0</span>) &#123;</span><br><span class="line">logger = skynet_handle_findname(<span class="string">&quot;logger&quot;</span>);<span class="comment">//找到默认的日志服务</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (logger == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> tmp[LOG_MESSAGE_SIZE];</span><br><span class="line"><span class="type">char</span> *data = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">va_list ap;</span><br><span class="line"></span><br><span class="line">va_start(ap,msg);</span><br><span class="line"><span class="type">int</span> len = vsnprintf(tmp, LOG_MESSAGE_SIZE, msg, ap);</span><br><span class="line">va_end(ap);</span><br><span class="line"><span class="keyword">if</span> (len &gt;=<span class="number">0</span> &amp;&amp; len &lt; LOG_MESSAGE_SIZE) &#123;</span><br><span class="line">data = skynet_strdup(tmp);<span class="comment">//分配内存</span></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">skynet_message</span> <span class="title">smsg</span>;</span><span class="comment">//构建一个smsg</span></span><br><span class="line"><span class="keyword">if</span> (context == <span class="literal">NULL</span>) &#123;</span><br><span class="line">smsg.source = <span class="number">0</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">smsg.source = skynet_context_handle(context);<span class="comment">//设置source</span></span><br><span class="line">&#125;</span><br><span class="line">smsg.session = <span class="number">0</span>;</span><br><span class="line">smsg.data = data;<span class="comment">//就是&quot;hello world&quot;</span></span><br><span class="line">smsg.sz = len | ((<span class="type">size_t</span>)PTYPE_TEXT &lt;&lt; MESSAGE_TYPE_SHIFT);<span class="comment">//高八位表示skynet消息类型是 PTYPE_TEXT</span></span><br><span class="line">skynet_context_push(logger, &amp;smsg);<span class="comment">//把消息push到logger服务</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码主要是把 <code>skynet.error(str)</code> 中的 <code>str</code> 拷贝一份,然后包装成 <code>skynet_message</code> ，push到 <code>logger</code> 服务对应的队列中。</p><p>由 <code>skynet_error</code> 代码，接下来调用 <code>skynet_context_push</code> 把消息push到logger服务里面。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">skynet_context_push</span><span class="params">(<span class="type">uint32_t</span> handle, <span class="keyword">struct</span> skynet_message *message)</span> &#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">skynet_context</span> * <span class="title">ctx</span> =</span> skynet_handle_grab(handle);<span class="comment">//每个handle和服务一一对应，这里是拿到日志服务</span></span><br><span class="line"><span class="keyword">if</span> (ctx == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">skynet_mq_push(ctx-&gt;<span class="built_in">queue</span>, message);<span class="comment">//将消息push到日志服务的队列中</span></span><br><span class="line">skynet_context_release(ctx);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码往服务中push消息。主要是通过服务的id得到服务，然后把消息加入到服务对应的队列中。调用 <code>skynet_mq_push</code> 代码。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> </span><br><span class="line"><span class="title function_">skynet_mq_push</span><span class="params">(<span class="keyword">struct</span> message_queue *q, <span class="keyword">struct</span> skynet_message *message)</span> &#123;</span><br><span class="line">assert(message);</span><br><span class="line">SPIN_LOCK(q)</span><br><span class="line"></span><br><span class="line">q-&gt;<span class="built_in">queue</span>[q-&gt;tail] = *message;</span><br><span class="line"><span class="keyword">if</span> (++ q-&gt;tail &gt;= q-&gt;cap) &#123;</span><br><span class="line">q-&gt;tail = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (q-&gt;head == q-&gt;tail) &#123;</span><br><span class="line">expand_queue(q);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (q-&gt;in_global == <span class="number">0</span>) &#123;<span class="comment">//q没有在全局队列中，使其加入</span></span><br><span class="line">q-&gt;in_global = MQ_IN_GLOBAL;</span><br><span class="line">skynet_globalmq_push(q);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SPIN_UNLOCK(q)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="logger服务处理消息"><a href="#logger服务处理消息" class="headerlink" title="logger服务处理消息"></a>logger服务处理消息</h2><p>Skynet_处理队列消息，已经说明了服务是怎么处理消息的。最后消息的处理是交给 <code>ctx</code> 的 <code>cb</code> 函数处理的。也就是说 <code>logger</code> 服务的消息最后交给 <code>logger_cb</code> 处理。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">logger_cb</span><span class="params">(<span class="keyword">struct</span> skynet_context * context, <span class="type">void</span> *ud, <span class="type">int</span> type, <span class="type">int</span> session, <span class="type">uint32_t</span> source, <span class="type">const</span> <span class="type">void</span> * msg, <span class="type">size_t</span> sz)</span> &#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">logger</span> * <span class="title">inst</span> =</span> ud;<span class="comment">//logger实例</span></span><br><span class="line"><span class="keyword">switch</span> (type) &#123;</span><br><span class="line"><span class="keyword">case</span> PTYPE_SYSTEM:<span class="comment">//这里表示打开一个新的日志文件</span></span><br><span class="line"><span class="keyword">if</span> (inst-&gt;filename) &#123;</span><br><span class="line">inst-&gt;handle = freopen(inst-&gt;filename, <span class="string">&quot;a&quot;</span>, inst-&gt;handle);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> PTYPE_TEXT:</span><br><span class="line"><span class="keyword">if</span> (inst-&gt;filename) &#123;<span class="comment">//如果指定了日志文件 则加点时间信息</span></span><br><span class="line"><span class="type">char</span> tmp[SIZETIMEFMT];</span><br><span class="line"><span class="type">int</span> csec = timestring(ud, tmp);</span><br><span class="line"><span class="built_in">fprintf</span>(inst-&gt;handle, <span class="string">&quot;%s.%02d &quot;</span>, tmp, csec);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">fprintf</span>(inst-&gt;handle, <span class="string">&quot;[:%08x] &quot;</span>, source);<span class="comment">//默认写日志，以服务id开头</span></span><br><span class="line">fwrite(msg, sz , <span class="number">1</span>, inst-&gt;handle);</span><br><span class="line"><span class="built_in">fprintf</span>(inst-&gt;handle, <span class="string">&quot;\n&quot;</span>);</span><br><span class="line">fflush(inst-&gt;handle);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：push消息到 <code>logger</code> 队列时 ，消息类型指定为 <code>PTYPE_TEXT</code> 。实际上就是直接写入标准输出。</p></blockquote><h3 id="tips"><a href="#tips" class="headerlink" title="tips:"></a>tips:</h3><blockquote><p>这里讨论的日志功能的服务是默认的日志服务。实际上，也可以配置为一个 <code>snlua</code> 服务，这样当调用 <code>skynet.error</code> 时，会发送一个 <code>PTYPE_TEXT</code>  消息给一个 <code>snlua</code> 服务。</p></blockquote><p>对比：</p><ul><li><p>默认创建日志服务代码如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这里创建一个服务 这个日志服务是service_logger.c代表的默认日志服务</span></span><br><span class="line"><span class="comment">//参数分别是 &quot;logger&quot; NULL</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">skynet_context</span> *<span class="title">ctx</span> =</span> skynet_context_new(config-&gt;logservice, config-&gt;logger);</span><br></pre></td></tr></table></figure></li><li><p>实际上可以改成</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这里创建一个服务 这个日志服务是service_snlua.c代表的lua服务</span></span><br><span class="line"><span class="comment">//参数分别是 &quot;snlua&quot; xxx;xxx表示lua服务对应的脚本文件</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">skynet_context</span> *<span class="title">ctx</span> =</span> skynet_context_new(config-&gt;logservice, config-&gt;logger);</span><br></pre></td></tr></table></figure></li></ul><p>即 <code>config-&gt;logservice</code>, <code>config-&gt;logger</code> 。这两个配置项决定了默认的日志功能服务到底是什么。</p>]]></content>
      
      
      <categories>
          
          <category> skynet </category>
          
      </categories>
      
      
        <tags>
            
            <tag> skynet </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Skynet_snlua服务的创建</title>
      <link href="/FrameWork/Skynet/Skynet_%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/Skynet_snlua%E6%9C%8D%E5%8A%A1%E7%9A%84%E5%88%9B%E5%BB%BA/Skynet_snlua%E6%9C%8D%E5%8A%A1%E7%9A%84%E5%88%9B%E5%BB%BA"/>
      <url>/FrameWork/Skynet/Skynet_%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/Skynet_snlua%E6%9C%8D%E5%8A%A1%E7%9A%84%E5%88%9B%E5%BB%BA/Skynet_snlua%E6%9C%8D%E5%8A%A1%E7%9A%84%E5%88%9B%E5%BB%BA</url>
      
        <content type="html"><![CDATA[<h1 id="snlua服务的创建"><a href="#snlua服务的创建" class="headerlink" title="snlua服务的创建"></a>snlua服务的创建</h1><p>在<a href="https://barbecue-g.github.io/FrameWork/Skynet/Skynet_%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/Skynet_%E6%9C%8D%E5%8A%A1%E9%97%B4%E8%AF%B7%E6%B1%82%E5%92%8C%E5%93%8D%E5%BA%94/Skynet_%E6%9C%8D%E5%8A%A1%E9%97%B4%E8%AF%B7%E6%B1%82%E5%92%8C%E5%93%8D%E5%BA%94">服务间请求和响应</a>的时候，在main服务里启动了一个db服务。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--main.lua</span></span><br><span class="line"><span class="keyword">local</span> skynet = <span class="built_in">require</span> <span class="string">&quot;skynet&quot;</span></span><br><span class="line"></span><br><span class="line">skynet.start(<span class="function"><span class="keyword">function</span><span class="params">()</span></span><span class="comment">--lua服务的入口函数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> db = skynet.newservice(<span class="string">&quot;db&quot;</span>)<span class="comment">--启动一个db服务</span></span><br><span class="line"><span class="keyword">local</span> key = <span class="string">&quot;zhangsan&quot;</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">local</span> age = skynet.call(db, <span class="string">&quot;lua&quot;</span>, <span class="string">&quot;GET&quot;</span>,key) <span class="comment">--发送 lua类型 的请求给db服务,然后等待对方回应</span></span><br><span class="line"></span><br><span class="line">skynet.<span class="built_in">exit</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span>)</span><br></pre></td></tr></table></figure><p>调用 <code>skynet.newservice(&quot;db&quot;)</code>启动了一个db服务。当调用 <code>skynet.newservice</code> 的时候，当前协程会挂起。他会发送一个请求给  <code>launcher</code> 服务，表示请启动一个db服务。 <code>launcher</code> 服务收到请求后，会启动创建db服务。当db服务启动完成后，会通知 <code>launcher</code> 服务，此时 <code>launcher</code> 服务才会发送响应消息给的main服务。这个时候， <code>skynet.newservice</code> 调用才会返回。</p><p><img src="https://img2023.cnblogs.com/blog/493645/202212/493645-20221208150359514-1764194323.png" alt="launch调用关系"></p><p>关于launcher服务的创建，看这里 <a href="https://barbecue-g.github.io/FrameWork/Skynet/Skynet_%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/Skynet_snlua%E6%9C%8D%E5%8A%A1%E7%9A%84%E5%88%9B%E5%BB%BA/Skynet_launcher%E7%9A%84%E5%88%9B%E5%BB%BA">launcher的创建</a> .</p><p>我们具体看看 <code>skynet.newservice(&quot;db&quot;)</code></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">skynet.newservice</span><span class="params">(name, ...)</span></span></span><br><span class="line"><span class="keyword">return</span> skynet.call(<span class="string">&quot;.launcher&quot;</span>, <span class="string">&quot;lua&quot;</span> , <span class="string">&quot;LAUNCH&quot;</span>, <span class="string">&quot;snlua&quot;</span>, name, ...)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>这里调用skynet.call 。注意参数 <code>&quot;LAUNCH&quot;, &quot;snlua&quot;, “db”</code> 。我们再看看launcher服务是怎么处理的。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--launcher.lua</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">command.LAUNCH</span><span class="params">(_, service, ...)</span></span><span class="comment">--收到服务main 请求创建一个服务db 的消息</span></span><br><span class="line">launch_service(service, ...) <span class="comment">--此时 service是 &quot;snlua&quot; </span></span><br><span class="line"><span class="keyword">return</span> NORET <span class="comment">--注意这里 NORET 表示 当前协程不用返回响应给main服务</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">skynet.dispatch(<span class="string">&quot;lua&quot;</span>, <span class="function"><span class="keyword">function</span><span class="params">(session, address, cmd , ...)</span></span> <span class="comment">--设置任务函数 f</span></span><br><span class="line">cmd = <span class="built_in">string</span>.<span class="built_in">upper</span>(cmd)</span><br><span class="line"><span class="keyword">local</span> f = command[cmd] <span class="comment">--此时cmd是 &quot;LAUNCH&quot;</span></span><br><span class="line"><span class="keyword">if</span> f <span class="keyword">then</span></span><br><span class="line"><span class="keyword">local</span> ret = f(address, ...)</span><br><span class="line"><span class="keyword">if</span> ret ~= NORET <span class="keyword">then</span></span><br><span class="line">skynet.ret(skynet.pack(ret))</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span>)</span><br></pre></td></tr></table></figure><p>继续看 launch_service 函数。实际上这个函数主要是调用了skynet.launch创建了模块为snlua的lua服务。因为skynet.launch函数的特点如下</p><ul><li>在当前工作线程下调用 skynet_context_new 创建db服务，并给对应的队列push一个消息</li><li>在合适的时机，队列的消息被取出被处理，同时执行服务对应的lua文件</li></ul><p>所以当前launcher服务只能等待。 当被创建的db服务的lua文件执行完成初始化后，也就是发送一个完成服务创建的通知给launcher时,launcher才会回应main服务。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">launch_service</span><span class="params">(service, ...)</span></span></span><br><span class="line"><span class="keyword">local</span> param = <span class="built_in">table</span>.<span class="built_in">concat</span>(&#123;...&#125;, <span class="string">&quot; &quot;</span>)</span><br><span class="line"><span class="keyword">local</span> inst = skynet.launch(service, param)<span class="comment">-- 此时service是 &quot;snlua&quot;  param 是 &quot;db&quot;</span></span><br><span class="line"><span class="keyword">local</span> session = skynet.context()</span><br><span class="line"><span class="keyword">local</span> response = skynet.response() <span class="comment">--这个返回一个闭包 </span></span><br><span class="line"><span class="keyword">if</span> inst <span class="keyword">then</span> <span class="comment">--inst是db服务的地址</span></span><br><span class="line">services[inst] = service .. <span class="string">&quot; &quot;</span> .. param</span><br><span class="line">instance[inst] = response</span><br><span class="line">launch_session[inst] = session</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">response(<span class="literal">false</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">return</span> inst</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>上面的代码实际上记录了请求者main服务的信息。现在假设db服务的db.lua文件执行完成了初始化。也就是db.lua的skynet.start注册的定时器触发了。还记得吗？这个定时器主要做了两件事 1. 执行启动函数 2.发送服务创建完成的通知给launcher服务。我们看看skynet.start函数。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--skynet.lua</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">skynet.init_service</span><span class="params">(start)</span></span></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line">skynet_require.init_all()</span><br><span class="line">start() <span class="comment">--执行启动函数 start_func</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">local</span> ok, err = <span class="built_in">xpcall</span>(main, <span class="built_in">traceback</span>)</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> ok <span class="keyword">then</span></span><br><span class="line"><span class="comment">--略</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">skynet.send(<span class="string">&quot;.launcher&quot;</span>,<span class="string">&quot;lua&quot;</span>, <span class="string">&quot;LAUNCHOK&quot;</span>)<span class="comment">--任何服务在完成start后 都会发送 LAUNCHOK 消息给 launcher服务</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">skynet.start</span><span class="params">(start_func)</span></span></span><br><span class="line">c.callback(skynet.dispatch_message)</span><br><span class="line">init_thread = skynet.timeout(<span class="number">0</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br><span class="line">skynet.init_service(start_func)</span><br><span class="line">init_thread = <span class="literal">nil</span></span><br><span class="line"><span class="keyword">end</span>)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>注意上面的 行10 代码。我们现在看看launcher收到这个 LAUNCHOK 消息的处理过程。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--每一个lua服务启动完成后(即start_func函数执行完毕 都会发送一个LAUNCHOK 消息给 launcher服务</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">command.LAUNCHOK</span><span class="params">(address)</span></span> <span class="comment">--收到服务db send过来的消息 表示服务db自身已经完成创建</span></span><br><span class="line"><span class="comment">-- init notice</span></span><br><span class="line"><span class="keyword">local</span> response = instance[address] <span class="comment">--address是db服务的地址</span></span><br><span class="line"><span class="keyword">if</span> response <span class="keyword">then</span></span><br><span class="line">response(<span class="literal">true</span>, address) <span class="comment">-- 发送响应给 之前的 main服务</span></span><br><span class="line">instance[address] = <span class="literal">nil</span></span><br><span class="line">launch_session[address] = <span class="literal">nil</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> NORET</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>行4 通过db的地址找到了之前已经准备好的响应闭包。然后在 行6 执行这个闭包。这样launcher就算是真正响应main服务了，虽然这个响应是延迟的。我们可以具体看看这个 闭包。实际上在 行13回应了main服务。相当于告诉main服务，你要的db服务，我已经给你创建好了。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">skynet.response</span><span class="params">(pack)</span></span></span><br><span class="line">pack = pack <span class="keyword">or</span> skynet.pack</span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> co_session = <span class="built_in">assert</span>(session_coroutine_id[running_thread], <span class="string">&quot;no session&quot;</span>)</span><br><span class="line">session_coroutine_id[running_thread] = <span class="literal">nil</span> <span class="comment">--这里不再保存session了 因为下面的response闭包已经保存session了</span></span><br><span class="line"><span class="keyword">local</span> co_address = session_coroutine_address[running_thread]</span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">response</span><span class="params">(ok, ...)</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> ret</span><br><span class="line"><span class="keyword">if</span> unresponse[response] <span class="keyword">then</span></span><br><span class="line"><span class="keyword">if</span> ok <span class="keyword">then</span></span><br><span class="line">ret = c.send(co_address, skynet.PTYPE_RESPONSE, co_session, pack(...))</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">unresponse[response] = <span class="literal">nil</span></span><br><span class="line">ret = ret ~= <span class="literal">nil</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">ret = <span class="literal">false</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">pack = <span class="literal">nil</span></span><br><span class="line"><span class="keyword">return</span> ret</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">unresponse[response] = co_address <span class="comment">--表示当前服务 还欠 co_address 一个响应 ,此时co_address就是我们的main服务</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> response</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>此时我们应该回到main服务调用 skynet.newservice(“db”)的地方了</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">skynet.newservice</span><span class="params">(name, ...)</span></span></span><br><span class="line"><span class="keyword">return</span> skynet.call(<span class="string">&quot;.launcher&quot;</span>, <span class="string">&quot;lua&quot;</span> , <span class="string">&quot;LAUNCH&quot;</span>, <span class="string">&quot;snlua&quot;</span>, name, ...)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>此时调用skynet.call挂起的协程，重新被唤醒，并返回地址给main服务了。</p>]]></content>
      
      
      <categories>
          
          <category> skynet </category>
          
      </categories>
      
      
        <tags>
            
            <tag> skynet </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Skynet_lua函数尾调用</title>
      <link href="/FrameWork/Skynet/Skynet_%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/Skynet_%E6%9C%8D%E5%8A%A1%E9%97%B4%E8%AF%B7%E6%B1%82%E5%92%8C%E5%93%8D%E5%BA%94/Skynet_lua%E5%87%BD%E6%95%B0%E5%B0%BE%E8%B0%83%E7%94%A8"/>
      <url>/FrameWork/Skynet/Skynet_%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/Skynet_%E6%9C%8D%E5%8A%A1%E9%97%B4%E8%AF%B7%E6%B1%82%E5%92%8C%E5%93%8D%E5%BA%94/Skynet_lua%E5%87%BD%E6%95%B0%E5%B0%BE%E8%B0%83%E7%94%A8</url>
      
        <content type="html"><![CDATA[<h1 id="Lua函数尾调用"><a href="#Lua函数尾调用" class="headerlink" title="Lua函数尾调用"></a>Lua函数尾调用</h1><h2 id="尾调用的基本概念"><a href="#尾调用的基本概念" class="headerlink" title="尾调用的基本概念"></a>尾调用的基本概念</h2><p>尾调用（Tail Call）是指一个函数的<strong>最后一个动作</strong>是调用另一个函数，并且<strong>不需要保留当前函数的执行环境</strong>。这种调用方式在Lua中具有特殊重要性，因为Lua解释器会对尾调用进行优化，避免不必要的栈空间使用。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 正确的尾调用示例</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span><span class="params">(x)</span></span></span><br><span class="line">  <span class="keyword">return</span> g(x)  <span class="comment">-- 尾调用：最后一步操作且直接返回结果</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>与普通函数调用不同，尾调用使Lua编译器能够<strong>重用当前的栈帧</strong>，而不是创建一个新的调用帧。这意味着尾调用不会增加栈深度，即使无限递归也不会导致栈溢出。这一特性使得Lua能够高效地处理递归算法和状态机实现，尤其在使用深度递归或长期运行的状态转换时显得尤为重要。</p><blockquote><p>理解尾调用的关键是认识到它不仅仅是”函数最后一行调用”，而是<strong>函数最后一步操作</strong>。这意味着在调用后，当前函数不再需要执行任何计算或保留任何状态。这种特性使得Lua可以像执行<code>goto</code>语句一样处理尾调用，直接跳转到新函数而不保留返回地址。</p></blockquote><h2 id="调用栈与调用帧的原理"><a href="#调用栈与调用帧的原理" class="headerlink" title="调用栈与调用帧的原理"></a>调用栈与调用帧的原理</h2><p>要理解尾调用优化，首先需要了解函数调用的底层机制。在大多数编程语言中，函数调用使用<strong>调用栈</strong>（Call Stack）来管理执行上下文。</p><h3 id="函数调用机制"><a href="#函数调用机制" class="headerlink" title="函数调用机制"></a>函数调用机制</h3><p>当调用一个函数时，系统会在调用栈上创建一个新的<strong>调用帧</strong>（Call Frame），也称为栈帧。这个调用帧包含以下信息：</p><ul><li>函数参数和局部变量</li><li>返回地址（调用结束后应返回的位置）</li><li>其他上下文信息</li></ul><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 普通函数调用示例</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span><span class="params">()</span></span></span><br><span class="line">  <span class="keyword">local</span> m = <span class="number">1</span></span><br><span class="line">  <span class="keyword">local</span> n = <span class="number">2</span></span><br><span class="line">  <span class="keyword">local</span> result = g(m + n)  <span class="comment">-- 普通调用：需要保留f()的上下文</span></span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">g</span><span class="params">(sum)</span></span></span><br><span class="line">  <span class="keyword">return</span> sum * <span class="number">2</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>在这种情况下，当<code>f()</code>调用<code>g()</code>时，必须保留<code>f()</code>的调用帧，因为<code>g()</code>返回后<code>f()</code>还需要继续执行（将结果返回给调用者）。随着函数调用层次加深，调用栈会不断增长，如果递归层次过深，就会导致<strong>栈溢出</strong>（Stack Overflow）。</p><h3 id="尾调用优化的内存管理"><a href="#尾调用优化的内存管理" class="headerlink" title="尾调用优化的内存管理"></a>尾调用优化的内存管理</h3><p>与传统调用不同，尾调用优化允许Lua<strong>重用当前调用帧</strong>而不是创建新帧。当函数进行尾调用时，解释器会在调用新函数前丢弃当前调用帧，因为不再需要当前函数的上下文信息。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 尾调用优化示例</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span><span class="params">()</span></span></span><br><span class="line">  <span class="keyword">local</span> m = <span class="number">1</span></span><br><span class="line">  <span class="keyword">local</span> n = <span class="number">2</span></span><br><span class="line">  <span class="keyword">return</span> g(m + n)  <span class="comment">-- 尾调用：直接返回g()的结果，无需保留f()的上下文</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>这种优化带来了显著的内存优势，尤其是对于递归操作。普通递归需要O(n)的空间复杂度（n为递归深度），而尾递归只需要O(1)的空间复杂度。</p><p>下表对比了传统调用与尾调用优化的差异：</p><table><thead><tr><th align="left">特性</th><th align="left">传统函数调用</th><th align="left">尾调用优化</th></tr></thead><tbody><tr><td align="left"><strong>栈帧管理</strong></td><td align="left">每次调用创建新栈帧</td><td align="left">重用当前栈帧</td></tr><tr><td align="left"><strong>内存使用</strong></td><td align="left">随调用深度增加而增加</td><td align="left">恒定不变</td></tr><tr><td align="left"><strong>最大深度</strong></td><td align="left">受栈大小限制</td><td align="left">理论上无限</td></tr><tr><td align="left"><strong>返回机制</strong></td><td align="left">需要返回调用点</td><td align="left">直接跳转，无需返回</td></tr></tbody></table><h2 id="尾调用的识别与写法"><a href="#尾调用的识别与写法" class="headerlink" title="尾调用的识别与写法"></a>尾调用的识别与写法</h2><p>正确识别和编写尾调用对于利用Lua的优化至关重要。尾调用的核心特征是<strong>函数的最后一步操作</strong>是调用另一个函数，并且<strong>立即返回其结果</strong> 。</p><h3 id="正确的尾调用形式"><a href="#正确的尾调用形式" class="headerlink" title="正确的尾调用形式"></a>正确的尾调用形式</h3><p>以下是有效的尾调用示例：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 1. 直接返回调用结果</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span><span class="params">(x)</span></span></span><br><span class="line">  <span class="keyword">return</span> bar(x + <span class="number">1</span>)  <span class="comment">-- 尾调用</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 2. 条件分支中的尾调用</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span><span class="params">(x)</span></span></span><br><span class="line">  <span class="keyword">if</span> x &gt; <span class="number">0</span> <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">return</span> positive(x)  <span class="comment">-- 尾调用</span></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> negative(x)  <span class="comment">-- 尾调用</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 3. 复杂表达式参数的尾调用</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span><span class="params">(x)</span></span></span><br><span class="line">  <span class="keyword">return</span> bar(x[<span class="number">1</span>].func(x[<span class="number">2</span>] * <span class="number">3</span>, i + j))  <span class="comment">-- 尾调用（参数可以是复杂表达式）</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h3 id="非尾调用形式"><a href="#非尾调用形式" class="headerlink" title="非尾调用形式"></a>非尾调用形式</h3><p>需要注意的是，并非所有在函数末尾的调用都是尾调用。以下是一些常见的非尾调用形式：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 1. 调用后还有额外操作</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span><span class="params">(x)</span></span></span><br><span class="line">  <span class="keyword">return</span> g(x) + <span class="number">1</span>  <span class="comment">-- 非尾调用：需要执行加法操作</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 2. 调用结果存储后返回</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span><span class="params">(x)</span></span></span><br><span class="line">  <span class="keyword">local</span> result = g(x)  <span class="comment">-- 非尾调用：需要存储到变量</span></span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 3. 调整返回值数量</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span><span class="params">(x)</span></span></span><br><span class="line">  <span class="keyword">return</span> x <span class="keyword">or</span> g(x)  <span class="comment">-- 非尾调用：可能需要调整返回值数量</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 4. 包装在括号中</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span><span class="params">(x)</span></span></span><br><span class="line">  <span class="keyword">return</span> (g(x))  <span class="comment">-- 非尾调用：括号强制调整为一个返回值</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 5. 没有return语句的调用</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span><span class="params">(x)</span></span></span><br><span class="line">  g(x)  <span class="comment">-- 非尾调用：丢弃返回值，且没有return语句</span></span><br><span class="line">  <span class="comment">-- 隐式返回nil</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>下表总结了尾调用与非尾调用的关键区别：</p><table><thead><tr><th align="left">特征</th><th align="left">尾调用</th><th align="left">非尾调用</th></tr></thead><tbody><tr><td align="left"><strong>返回表达式</strong></td><td align="left">直接返回函数调用结果</td><td align="left">返回包含其他操作的表达式</td></tr><tr><td align="left"><strong>栈帧需求</strong></td><td align="left">不需要保留当前栈帧</td><td align="left">需要保留当前栈帧</td></tr><tr><td align="left"><strong>内存使用</strong></td><td align="left">恒定不变</td><td align="left">随调用深度增加</td></tr><tr><td align="left"><strong>优化潜力</strong></td><td align="left">可被Lua优化</td><td align="left">无优化</td></tr></tbody></table><h3 id="尾递归的特殊情况"><a href="#尾递归的特殊情况" class="headerlink" title="尾递归的特殊情况"></a>尾递归的特殊情况</h3><p>尾递归是尾调用的特例，指函数最后调用自身。由于尾调用优化，尾递归可以无限进行而不会栈溢出。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 普通递归（非尾调用）</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span><span class="params">(n)</span></span></span><br><span class="line">  <span class="keyword">if</span> n == <span class="number">1</span> <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> n * factorial(n - <span class="number">1</span>)  <span class="comment">-- 非尾调用：返回后还需进行乘法操作</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 尾递归形式</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">tail_factorial</span><span class="params">(n, total)</span></span></span><br><span class="line">  total = total <span class="keyword">or</span> <span class="number">1</span></span><br><span class="line">  <span class="keyword">if</span> n == <span class="number">1</span> <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">return</span> total</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> tail_factorial(n - <span class="number">1</span>, n * total)  <span class="comment">-- 尾调用：最后一步直接返回自身</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 包装函数提供更友好的接口</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span><span class="params">(n)</span></span></span><br><span class="line">  <span class="keyword">return</span> tail_factorial(n, <span class="number">1</span>)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>这种转换通过将中间结果（<code>total</code>）作为参数传递，避免了返回后的额外计算，使递归调用成为尾调用。</p><h2 id="尾调用的应用场景"><a href="#尾调用的应用场景" class="headerlink" title="尾调用的应用场景"></a>尾调用的应用场景</h2><p>尾调用在Lua编程中有几个重要应用场景，特别是处理递归算法和状态机实现。</p><h3 id="递归优化"><a href="#递归优化" class="headerlink" title="递归优化"></a>递归优化</h3><p>递归函数最容易从尾调用优化中受益。通过将普通递归转换为尾递归，可以显著减少内存使用并避免栈溢出。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 斐波那契数列的普通递归实现（效率低下）</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fib</span><span class="params">(n)</span></span></span><br><span class="line">  <span class="keyword">if</span> n &lt;= <span class="number">1</span> <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">return</span> n</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> fib(n - <span class="number">1</span>) + fib(n - <span class="number">2</span>)  <span class="comment">-- 双重递归，性能极差</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 使用尾递归优化斐波那契计算</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">tail_fib</span><span class="params">(n, a, b)</span></span></span><br><span class="line">  a = a <span class="keyword">or</span> <span class="number">0</span></span><br><span class="line">  b = b <span class="keyword">or</span> <span class="number">1</span></span><br><span class="line">  <span class="keyword">if</span> n == <span class="number">0</span> <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">return</span> a</span><br><span class="line">  <span class="keyword">elseif</span> n == <span class="number">1</span> <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> tail_fib(n - <span class="number">1</span>, b, a + b)  <span class="comment">-- 尾调用：线性递归</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 更友好的包装函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fib</span><span class="params">(n)</span></span></span><br><span class="line">  <span class="keyword">return</span> tail_fib(n, <span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h3 id="状态机实现"><a href="#状态机实现" class="headerlink" title="状态机实现"></a>状态机实现</h3><p>尾调用特别适合实现<strong>状态机</strong>，其中每个状态由一个函数表示，状态转换通过尾调用另一个函数实现。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 简单迷宫游戏的状态机实现</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">room1</span><span class="params">()</span></span></span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;You are in room 1. Exits: south, east&quot;</span>)</span><br><span class="line">  <span class="keyword">local</span> move = <span class="built_in">io</span>.<span class="built_in">read</span>()  <span class="comment">-- 读取用户输入</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> move == <span class="string">&quot;south&quot;</span> <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">return</span> room3()  <span class="comment">-- 尾调用：转移到房间3</span></span><br><span class="line">  <span class="keyword">elseif</span> move == <span class="string">&quot;east&quot;</span> <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">return</span> room2()  <span class="comment">-- 尾调用：转移到房间2</span></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Invalid move&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> room1()  <span class="comment">-- 尾调用：保持当前状态</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">room2</span><span class="params">()</span></span></span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;You are in room 2. Exits: south, west&quot;</span>)</span><br><span class="line">  <span class="keyword">local</span> move = <span class="built_in">io</span>.<span class="built_in">read</span>()</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> move == <span class="string">&quot;south&quot;</span> <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">return</span> room4()  <span class="comment">-- 尾调用：转移到房间4</span></span><br><span class="line">  <span class="keyword">elseif</span> move == <span class="string">&quot;west&quot;</span> <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">return</span> room1()  <span class="comment">-- 尾调用：转移到房间1</span></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Invalid move&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> room2()  <span class="comment">-- 尾调用：保持当前状态</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">room3</span><span class="params">()</span></span></span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;You are in room 3. Exits: north, east&quot;</span>)</span><br><span class="line">  <span class="keyword">local</span> move = <span class="built_in">io</span>.<span class="built_in">read</span>()</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> move == <span class="string">&quot;north&quot;</span> <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">return</span> room1()  <span class="comment">-- 尾调用：转移到房间1</span></span><br><span class="line">  <span class="keyword">elseif</span> move == <span class="string">&quot;east&quot;</span> <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">return</span> room4()  <span class="comment">-- 尾调用：转移到房间4</span></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Invalid move&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> room3()  <span class="comment">-- 尾调用：保持当前状态</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">room4</span><span class="params">()</span></span></span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;Congratulations! You found the exit.&quot;</span>)</span><br><span class="line">  <span class="comment">-- 结束游戏，没有尾调用</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 开始游戏</span></span><br><span class="line">room1()</span><br></pre></td></tr></table></figure><p>在这种状态机实现中，每个房间函数结束时通过尾调用转移到下一个状态（房间）。由于Lua的尾调用优化，这种实现可以无限进行而不会消耗额外的栈空间，无论游戏进行多长时间或有多少状态转换。</p><h2 id="尾调用的局限性与注意事项"><a href="#尾调用的局限性与注意事项" class="headerlink" title="尾调用的局限性与注意事项"></a>尾调用的局限性与注意事项</h2><p>虽然尾调用优化是一个强大特性，但在实际使用中需要注意一些限制和考虑因素。</p><h3 id="语言实现支持"><a href="#语言实现支持" class="headerlink" title="语言实现支持"></a>语言实现支持</h3><p>并非所有语言都支持尾调用优化。Lua是少数明确支持正确尾调用的脚本语言，但许多其他语言（如Python、Java）不支持或支持有限。这意味着在Lua中能正常工作的尾递归代码，在其他语言中可能导致栈溢出。</p><h3 id="调试复杂性"><a href="#调试复杂性" class="headerlink" title="调试复杂性"></a>调试复杂性</h3><p>尾调用优化可能会增加调试难度，因为优化后的调用不会在栈跟踪中显示：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span><span class="params">()</span></span></span><br><span class="line">  <span class="keyword">return</span> b()  <span class="comment">-- 尾调用</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">b</span><span class="params">()</span></span></span><br><span class="line">  <span class="built_in">error</span>(<span class="string">&quot;debugging test&quot;</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 调用a()时的错误堆栈将不显示a()，因为调用帧已被重用</span></span><br></pre></td></tr></table></figure><p>这种情况下，错误堆栈跟踪可能不完整，缺少中间调用信息，使问题调试更加困难。</p><h3 id="识别正确的尾调用"><a href="#识别正确的尾调用" class="headerlink" title="识别正确的尾调用"></a>识别正确的尾调用</h3><p>准确识别尾调用需要特别注意语法细节。以下是一些容易混淆的情况：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 看起来像但实际不是尾调用的例子</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span><span class="params">(x)</span></span></span><br><span class="line">  g(x)          <span class="comment">-- 非尾调用：缺少return</span></span><br><span class="line">  <span class="keyword">return</span>        <span class="comment">-- 非尾调用：显示返回但无调用</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span><span class="params">(x)</span></span></span><br><span class="line">  <span class="keyword">return</span> g(x) + <span class="number">1</span>  <span class="comment">-- 非尾调用：有额外操作</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span><span class="params">(x)</span></span></span><br><span class="line">  <span class="keyword">return</span> (g(x))    <span class="comment">-- 非尾调用：括号导致调整返回值</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>下表对比了优化前后的差异：</p><table><thead><tr><th align="left">方面</th><th align="left">无尾调用优化</th><th align="left">有尾调用优化</th></tr></thead><tbody><tr><td align="left"><strong>栈深度</strong></td><td align="left">随调用链增长而增长</td><td align="left">保持恒定</td></tr><tr><td align="left"><strong>内存使用</strong></td><td align="left">随调用深度增加</td><td align="left">恒定不变</td></tr><tr><td align="left"><strong>最大调用链</strong></td><td align="left">有限制（取决于栈大小）</td><td align="left">理论上无限</td></tr><tr><td align="left"><strong>调试信息</strong></td><td align="left">完整调用栈</td><td align="left">优化调用不在栈中</td></tr><tr><td align="left"><strong>跨语言兼容性</strong></td><td align="left">通常更兼容</td><td align="left">可能在其他语言中失败</td></tr></tbody></table><p>Lua的尾调用优化是一个强大特性，特别适合实现递归算法和状态机。通过理解和正确应用尾调用，可以编写出更高效、更节省内存的代码。然而，需要注意尾调用的识别条件和潜在局限性，以确保代码的正确性和可维护性。</p>]]></content>
      
      
      <categories>
          
          <category> skynet </category>
          
      </categories>
      
      
        <tags>
            
            <tag> skynet </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Skynet_协程</title>
      <link href="/FrameWork/Skynet/Skynet_%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/Skynet_%E6%9C%8D%E5%8A%A1%E9%97%B4%E8%AF%B7%E6%B1%82%E5%92%8C%E5%93%8D%E5%BA%94/Skynet_%E5%8D%8F%E7%A8%8B"/>
      <url>/FrameWork/Skynet/Skynet_%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/Skynet_%E6%9C%8D%E5%8A%A1%E9%97%B4%E8%AF%B7%E6%B1%82%E5%92%8C%E5%93%8D%E5%BA%94/Skynet_%E5%8D%8F%E7%A8%8B</url>
      
        <content type="html"><![CDATA[<h1 id="Skynet-协程"><a href="#Skynet-协程" class="headerlink" title="Skynet_协程"></a>Skynet_协程</h1><h2 id="协程的基本概念"><a href="#协程的基本概念" class="headerlink" title="协程的基本概念"></a>协程的基本概念</h2><p>每个lua虚拟机中可以有多个协程协调工作，但虚拟机中永远只有一个协程在工作。</p><ol><li><p>情况一：</p><p>协程都会绑定一个 <code>主体函数</code> 。如果协程还没有运行过，直接调用 <code>coroutine_resume(co,...)</code> 就会导致协程开始运行，即开始执行主体函数，主体函数收到的参数就是上面的 <code>...</code> 。调用者此时处于阻塞等待的状态。当主体函数执行完成的时候， <code>coroutine_resume</code> 也返回了，对于调用者来说， <code>coroutine_resume</code> 返回值就是主体函数的返回值。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> co = coroutine_create(</span><br><span class="line">    <span class="function"><span class="keyword">function</span><span class="params">(money)</span></span> <span class="comment">--绑定了一个匿名主体函数</span></span><br><span class="line">        </span><br><span class="line">    <span class="comment">-- dosomething</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span>  <span class="string">&quot;绫罗绸缎&quot;</span> <span class="comment">--ret的返回值</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">local</span> ok,ret = coroutine_resume(co,<span class="number">955</span>) <span class="comment">--当协程co执行的时候,当前调用者是阻塞的,即不能立即执行第10行</span></span><br><span class="line"><span class="built_in">print</span>(ok,ret)</span><br></pre></td></tr></table></figure><blockquote><p><code>ok</code> 是第一个返回值， <code>true</code> 表示协程内部执行的时候没有报错</p></blockquote></li><li><p>情况二：<br>开始执行了一个主体函数，但在中途，主体函数让出了控制权，即调用 <code>coroutine_yield(...)</code> 挂起协程，此时<code>coroutine_resume</code> 会返回。返回值就是 <code>...</code> 。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> co = coroutine_create(</span><br><span class="line">    <span class="function"><span class="keyword">function</span><span class="params">(money)</span></span> <span class="comment">--绑定了一个匿名主体函数</span></span><br><span class="line">        </span><br><span class="line">    <span class="comment">-- dosomething 1</span></span><br><span class="line">        coroutine_yield(<span class="string">&quot;感觉快猝死了&quot;</span>)</span><br><span class="line">        <span class="comment">-- dosomething 2</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span>  <span class="string">&quot;绫罗绸缎&quot;</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">local</span> ok,ret = coroutine_resume(co,<span class="number">996</span>) <span class="comment">--此时ret的值是 &quot;感觉快猝死了&quot;</span></span><br><span class="line"><span class="built_in">print</span>(ok,ret)</span><br></pre></td></tr></table></figure></li><li><p>情况三：</p><p>调用者需要协程再次工作，并调用协程。只需调用 <code>coroutine_resume(co,...)</code> ，就可让协程继续工作。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> co = coroutine_create(</span><br><span class="line">    <span class="function"><span class="keyword">function</span><span class="params">(money)</span></span> <span class="comment">--绑定了一个匿名主体函数</span></span><br><span class="line">        </span><br><span class="line">    <span class="comment">-- dosomething 1</span></span><br><span class="line">        <span class="keyword">local</span> tip = coroutine_yield(<span class="string">&quot;感觉快猝死了&quot;</span>) <span class="comment">--此时的tip就是 50</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Much appreciated&quot;</span>)</span><br><span class="line">   <span class="comment">-- dosomething 2    </span></span><br><span class="line">        <span class="keyword">return</span>  <span class="string">&quot;绫罗绸缎&quot;</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">local</span> ok,ret = coroutine_resume(co,<span class="number">996</span>) <span class="comment">--此时ret的值是 &quot;感觉快猝死了&quot;</span></span><br><span class="line"><span class="built_in">print</span>(ok,ret)<span class="comment">--建议继续工作</span></span><br><span class="line">ok,ret = coroutine_resume(co,<span class="number">50</span>) <span class="comment">--50是打车费</span></span><br><span class="line"><span class="built_in">print</span>(ok,ret) <span class="comment">--此时ret的值是 &quot;绫罗绸缎&quot;</span></span><br></pre></td></tr></table></figure><blockquote><p>注意：唤醒挂起的协程时，跟第一次执行主体函数一样，也是可以传递参数的。只是协程获取传递进来的参数是在  <code>coroutine_yield</code> 函数的左边。</p><ul><li><code>coroutine_yield</code> 的右边：当前协程让出时传出去的值,</li><li><code>coroutine_yield</code> 的左边：当前协程被唤醒时,外面传进来的值</li></ul></blockquote></li></ol><h2 id="skynet的协程框架"><a href="#skynet的协程框架" class="headerlink" title="skynet的协程框架"></a>skynet的协程框架</h2><p><img src="https://cdn.jsdelivr.net/gh/Barbecue-g/imagehost/FrameWork/Skynet/%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/Skynet_%E6%9C%8D%E5%8A%A1%E9%97%B4%E8%AF%B7%E6%B1%82%E5%92%8C%E5%93%8D%E5%BA%94/skynet_%E5%8D%8F%E7%A8%8B%E6%A6%82%E5%BF%B5%E5%9B%BE.png?raw=true" alt="skynet_协程概念图"></p><h2 id="skynet的协程池具体工作原理"><a href="#skynet的协程池具体工作原理" class="headerlink" title="skynet的协程池具体工作原理"></a>skynet的协程池具体工作原理</h2><p>skynet本身是有协程池，如果需要一个协程，那么首先从协程池中去取；如果协程池中没有，那么就创建一个协程。 <code>co_create(f)</code> 就是获取一个协程。</p><blockquote><p>注意： <code>f</code> 函数不是协程绑定的主体函数。 <code>f</code> 可以叫做当前协程的 <code>任务函数</code> 。 刚刚获取一个协程时，任务函数并不会马上执行。只有当协程<strong>被唤醒</strong>的时候，才会执行这个函数。</p></blockquote><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> <span class="built_in">coroutine</span> = <span class="built_in">coroutine</span> <span class="comment">--lua自带的协程库</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">coroutine_resume</span><span class="params">(co, ...)</span></span> <span class="comment">--唤醒协程</span></span><br><span class="line">running_thread = co <span class="comment">--唤醒协程时 记录当前正在执行的协程</span></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">coroutine</span>.<span class="built_in">resume</span>(co, ...)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">local</span> coroutine_yield = <span class="built_in">coroutine</span>.<span class="built_in">yield</span><span class="comment">--挂起协程</span></span><br><span class="line"><span class="keyword">local</span> coroutine_create = <span class="built_in">coroutine</span>.<span class="built_in">create</span> <span class="comment">-- 创建协程</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">co_create</span><span class="params">(f)</span></span><span class="comment">--f函数为任务函数</span></span><br><span class="line"><span class="keyword">local</span> co = tremove(coroutine_pool)<span class="comment">--从协程池中取出一个协程</span></span><br><span class="line"><span class="keyword">if</span> co == <span class="literal">nil</span> <span class="keyword">then</span><span class="comment">--一开始协程为空</span></span><br><span class="line">co = coroutine_create(<span class="function"><span class="keyword">function</span><span class="params">(...)</span></span><span class="comment">--匿名函数，此为主体函数</span></span><br><span class="line">f(...)<span class="comment">--首先执行任务函数f</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">true</span> <span class="keyword">do</span></span><br><span class="line"><span class="comment">-- coroutine exit</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- recycle co into pool</span></span><br><span class="line">f = <span class="literal">nil</span><span class="comment">--把任务函数f清空</span></span><br><span class="line">coroutine_pool[#coroutine_pool+<span class="number">1</span>] = co<span class="comment">--把协程回收</span></span><br><span class="line"><span class="comment">-- recv new main function f</span></span><br><span class="line">f = coroutine_yield <span class="string">&quot;SUSPEND&quot;</span><span class="comment">--挂起当前协程 当协程再次唤醒时 把传递进来的参数赋值给f </span></span><br><span class="line">f(coroutine_yield())<span class="comment">--等于f(...)，其中二次挂起（yield()）是为了接收新f任务所需的参数</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span>)</span><br><span class="line"><span class="keyword">else</span><span class="comment">--取出协程池中的协程</span></span><br><span class="line"><span class="comment">-- pass the main function f to coroutine, and restore running thread</span></span><br><span class="line"><span class="keyword">local</span> <span class="built_in">running</span> = running_thread <span class="comment">--保存调用co_create所在的协程</span></span><br><span class="line">coroutine_resume(co, f) <span class="comment">--重新设置任务函数new_f ，coroutine_resume每次都会设置当前正在运行的协程</span></span><br><span class="line">running_thread = <span class="built_in">running</span> <span class="comment">--恢复记录调用co_create所在的协程</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">return</span> co</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>上面的代码看出， <code>co_create</code> 是对lua自带协程库包了一层。而调用 <code>co_create( f )</code> 时指定的 <code>f</code> 函数 并不是这个协程真正绑定的主体函数。真正的绑定的主体函数是匿名函数 <code>function(...) end</code> 。</p><p>针对上面代码分析，举例调用：先假设协程池是空，当需要做一个任务时</p><ul><li><p>先获取一个协程 <code>co = co_reate(f)</code> ，此时会调用 <code>coroutine_create</code> 创建一个协程。(此时已经设置好 <code>f</code> 任务函数)</p></li><li><p>调用 <code>coroutine_resume (co,...)</code> ，完成任务后协程会放回协程池，同时调用 <code>coroutine_yield &quot;SUSPEND&quot;</code> 把协程挂起。此时 <code>coroutine_resume (co,...)</code> 返回了，且返回值中就有 <code>&quot;SUSPEND&quot;</code> 。</p><blockquote><p>注意：协程虽然在逻辑上是回收了，但是它是挂起状态。</p></blockquote></li><li><p>外部通过 <code>coroutine_resume(co, new_f)</code> 唤醒协程并传入<strong>新任务函数</strong> <code>new_f</code> ，并赋值给 <code>f</code> 。</p></li><li><p>等待 <code>new_f</code> 的参数并执行新任务，外部通过 <code>coroutine_resume(co, arg1, arg2, ...)</code> 唤醒协程并传入<strong>参数</strong>。<code>coroutine_yield()</code>返回这些参数，并传递给 <code>f</code>。</p></li><li><p><code>f</code> 执行其自身的逻辑。执行完毕后，循环再次开始，清空 <code>f</code> ，回收协程，挂起等待下一个新任务 <code>coroutine_yield &quot;SUSPEND&quot;</code> 。</p></li></ul><h3 id="关键点总结"><a href="#关键点总结" class="headerlink" title="关键点总结"></a>关键点总结</h3><ul><li><strong>协程池</strong>：这套机制的核心目的是复用协程，避免重复创建的开销协程执行完一个任务后并不会销毁，而是通过 <code>yield</code> 挂起，放回池中，等待下一次被分配新任务。</li><li><strong>双重 yield</strong>：<code>f(coroutine_yield())</code>体现了其关键作用。它第一次挂起（<code>yield &quot;SUSPEND&quot;</code>）是为了接收<strong>新任务函数</strong>，第二次挂起（<code>yield()</code>）是为了接收<strong>该任务所需的参数</strong>。</li><li><strong>灵活性</strong>：通过这种“函数+参数”分两次传递的方式，协程池可以处理各种不同的任务函数和其对应的参数，非常灵活。</li></ul>]]></content>
      
      
      <categories>
          
          <category> skynet </category>
          
      </categories>
      
      
        <tags>
            
            <tag> skynet </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Skynet_服务间请求和响应</title>
      <link href="/FrameWork/Skynet/Skynet_%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/Skynet_%E6%9C%8D%E5%8A%A1%E9%97%B4%E8%AF%B7%E6%B1%82%E5%92%8C%E5%93%8D%E5%BA%94/Skynet_%E6%9C%8D%E5%8A%A1%E9%97%B4%E8%AF%B7%E6%B1%82%E5%92%8C%E5%93%8D%E5%BA%94"/>
      <url>/FrameWork/Skynet/Skynet_%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/Skynet_%E6%9C%8D%E5%8A%A1%E9%97%B4%E8%AF%B7%E6%B1%82%E5%92%8C%E5%93%8D%E5%BA%94/Skynet_%E6%9C%8D%E5%8A%A1%E9%97%B4%E8%AF%B7%E6%B1%82%E5%92%8C%E5%93%8D%E5%BA%94</url>
      
        <content type="html"><![CDATA[<h1 id="Skynet-服务间请求和响应"><a href="#Skynet-服务间请求和响应" class="headerlink" title="Skynet_服务间请求和响应"></a>Skynet_服务间请求和响应</h1><h2 id="snlua服务启动的基本知识"><a href="#snlua服务启动的基本知识" class="headerlink" title="snlua服务启动的基本知识"></a>snlua服务启动的基本知识</h2><p> <strong>lua</strong> 服务跟 <strong>logger</strong> 服务的工作模式在c层看来都是一样的，即都有一个队列，然后不断的从队列中取出消息，然后处理掉消息。当然这两者属于不同<strong>模块</strong>。</p><p> <strong>lua</strong> 服务可以认为跟 <strong>logger</strong> 服务最大的区别是：</p><ul><li>取出消息-&gt;lua服务回调函数-&gt; <code>skynet.dispatch_message</code> </li><li>取出消息-&gt;logger服务回调函数</li></ul><p>之前创建一个 <strong>logger</strong> 服务是在底层调用 <code>skynet_context_new(const char * name, const char *param)</code> ，  <code>name</code> 就是模块名字 <code>logger</code> ， <code>param</code> 默认是 <code>NULL</code> 。实际上创建一个 <strong>lua</strong> 服务,也是调用这个函数，<code>name</code> 就是 <code>snlua</code> ， <code>param</code> 是一个 <strong>lua</strong> 文件名.</p><p>但实际上服务创建是通过 <code>skynet.newservice</code> 创建的。这个函数最终一样会调用底层的 <code>skynet_context_new</code> 来创建服务。skynet进程启动后,就会启动一个 <code>bootstrap</code> 服务， <code>bootstrap</code> 服务就会调用 <code>skynet.newservice(&quot;main&quot;)</code> 创建main服务。执行main服务配置lua代码过程：</p><p><img src="https://cdn.jsdelivr.net/gh/Barbecue-g/imagehost/FrameWork/Skynet/%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/Skynet_%E6%9C%8D%E5%8A%A1%E9%97%B4%E8%AF%B7%E6%B1%82%E5%92%8C%E5%93%8D%E5%BA%94/skynet_context_new%E6%89%A7%E8%A1%8C%E9%80%BB%E8%BE%91.png?raw=true" alt="skynet_context_new执行逻辑"></p><p>这里先启动了一个main服务,然后在main服务里面启动了一个db服务。之后在main服务中向db服务发送了一个请求。请求的目的是：希望db服务告诉 <code>zhangsan</code> 的年龄。</p><ol><li>main服务指定的lua文件：</li></ol>   <figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--main.lua</span></span><br><span class="line"><span class="keyword">local</span> skynet = <span class="built_in">require</span> <span class="string">&quot;skynet&quot;</span></span><br><span class="line"></span><br><span class="line">skynet.start(<span class="function"><span class="keyword">function</span><span class="params">()</span></span><span class="comment">--这个匿名函数可以认为是lua服务的入口函数 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> db = skynet.newservice(<span class="string">&quot;db&quot;</span>)<span class="comment">--启动一个db服务</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> key = <span class="string">&quot;zhangsan&quot;</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">local</span> age = skynet.call(db, <span class="string">&quot;lua&quot;</span>, <span class="string">&quot;GET&quot;</span>,key) <span class="comment">--发送 lua类型 的请求给db服务,然后等待对方回应</span></span><br><span class="line"></span><br><span class="line">skynet.<span class="built_in">exit</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span>)</span><br></pre></td></tr></table></figure><ol start="2"><li>db服务指定的lua文件：</li></ol>   <figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--db.lua</span></span><br><span class="line"><span class="keyword">local</span> skynet = <span class="built_in">require</span> <span class="string">&quot;skynet&quot;</span></span><br><span class="line"><span class="built_in">require</span> <span class="string">&quot;skynet.manager&quot;</span><span class="comment">-- import skynet.register</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> db = &#123;<span class="comment">--保存了年龄</span></span><br><span class="line">    zhangsan = <span class="number">12</span>,</span><br><span class="line">    lisi = <span class="number">33</span>,</span><br><span class="line">    wangwu = <span class="number">4</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> command = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">command.GET</span><span class="params">(key)</span></span></span><br><span class="line"><span class="keyword">return</span> db[key]</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">skynet.start(<span class="function"><span class="keyword">function</span><span class="params">()</span></span> <span class="comment">--skynet.start注册一个匿名的入口函数</span></span><br><span class="line"></span><br><span class="line">skynet.dispatch(<span class="string">&quot;lua&quot;</span>, <span class="function"><span class="keyword">function</span><span class="params">(session, address, cmd, ...)</span></span><span class="comment">--这里专门处理 lua类型 的请求</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> f = command[cmd] <span class="comment">--这里收到的 cmd 是&quot;GET&quot; 参数是 &quot;zhangsan&quot;，main服务传入的key</span></span><br><span class="line"><span class="keyword">if</span> f <span class="keyword">then</span></span><br><span class="line">skynet.ret(skynet.pack(f(...)))<span class="comment">--发送响应给main服务，pack打包，ret发回</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span>)</span><br></pre></td></tr></table></figure><p><code>skynet.start(main)</code> 是在注册一个初始化函数。在 <a href="https://barbecue-g.github.io/FrameWork/Skynet/Skynet_%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/Skynet_%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%86%B5">skynet_基本概况</a> 中提到可以往服务队列里面 <code>push</code> 定时器消息。实际上 lua 服务调用 <code>skynet.start</code> 时会主动要求 <code>push</code> 一个定时器消息到 lua 服务自己的队列，定时器消息最终的处理会调用 lua 的初始化函数main。所以可以认为main就是一个服务的入口函数。</p><p> <code>skynet.start</code> 被调用的过程：</p><p> skynet 在底层启动一个 lua 服务的过程中，会先 push 一个消息到服务自己的队列中。（一个 lua 服务处理消息的过程就是调用服务的回调函数，然后在回调函数内部又调用一个 lua 函数。）</p><blockquote><p>特例：处理第一个消息时，直接在回调函数执行务指定的 lua 文件即可。(eg：这里就是 <code>main.lua</code> 文件。那么在执行lua文件时,就会调用到 <code>skynet.start</code> ）</p></blockquote><h2 id="发送请求"><a href="#发送请求" class="headerlink" title="发送请求"></a>发送请求</h2><p>具体 <code>skynet.call</code> 发送请求：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">skynet.call</span><span class="params">(addr, typename, ...)</span></span><span class="comment">--这里是typename是 &quot;lua&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> p = proto[typename]<span class="comment">--根据消息类型获取对应的协议</span></span><br><span class="line"><span class="keyword">local</span> session = c.send(addr, p.id , <span class="literal">nil</span> , p.pack(...))<span class="comment">--seesion是通过当前服务分配的 注意第三个参数是 nil </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> p.<span class="built_in">unpack</span>(yield_call(addr, session))</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>发送消息时要指明消息类型。不同的消息类型对应着不同的协议。请求发送出去是要先打包的，不同的消息类型,对应的协议有不同的打包函数。 lua 协议类型的打包函数 <code>skynet.pack</code> 主要做的事情是把一堆 lua 参数转变成一个 <font color=#0099ff> <strong>指针+长度</strong> </font> 。（具体可以查看 <code>skynet</code> 的 <code>pack</code> 函数 ，一般情况下，有几个协议默认就定义好了）</p><p>注册协议：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">----- register protocol</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line"><span class="keyword">local</span> REG = skynet.register_protocol</span><br><span class="line"></span><br><span class="line">REG &#123;</span><br><span class="line">name = <span class="string">&quot;lua&quot;</span>,<span class="comment">--协议类型名字</span></span><br><span class="line">id = skynet.PTYPE_LUA,<span class="comment">--协议id</span></span><br><span class="line">pack = skynet.pack,<span class="comment">--打包</span></span><br><span class="line"><span class="built_in">unpack</span> = skynet.<span class="built_in">unpack</span>,<span class="comment">--解包</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">REG &#123;</span><br><span class="line">name = <span class="string">&quot;response&quot;</span>,</span><br><span class="line">id = skynet.PTYPE_RESPONSE,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">REG &#123;</span><br><span class="line">name = <span class="string">&quot;error&quot;</span>,</span><br><span class="line">id = skynet.PTYPE_ERROR,</span><br><span class="line"><span class="built_in">unpack</span> = <span class="function"><span class="keyword">function</span><span class="params">(...)</span></span> <span class="keyword">return</span> ... <span class="keyword">end</span>,</span><br><span class="line">dispatch = _error_dispatch,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>发送消息除了指明消息类型,还需要指明 目标服务，以及 <code>session</code> 。</p><p> <code>session</code> ：主要是用来匹配请求和响应用的。可以认为 skynet 的每个 lua 服务内部都有一个产生 <code>session</code> 号的机器。当然唯一性只能在服务内提供保证。（eg：a服务往b服务发送了两个请求requst1， request2，a发送request1 的时候附带了一个session1 ，b服务给出响应的时候也附带了一个session指明了是响应哪个请求的。）</p><p> <code>c.send</code> 函数：主要是把请求 <code>push</code> 到目标服务的队列。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">LUAMOD_API <span class="type">int</span></span><br><span class="line"><span class="title function_">luaopen_skynet_core</span><span class="params">(lua_State *L)</span> &#123;</span><br><span class="line">luaL_checkversion(L);</span><br><span class="line"></span><br><span class="line">luaL_Reg l[] = &#123;</span><br><span class="line">&#123; <span class="string">&quot;send&quot;</span> , lsend &#125;,<span class="comment">//next</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">uint32 address </span></span><br><span class="line"><span class="comment"> string address</span></span><br><span class="line"><span class="comment">integer type</span></span><br><span class="line"><span class="comment">integer session</span></span><br><span class="line"><span class="comment">string message</span></span><br><span class="line"><span class="comment"> lightuserdata message_ptr</span></span><br><span class="line"><span class="comment"> integer len</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">lsend</span><span class="params">(lua_State *L)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> send_message(L, <span class="number">0</span>, <span class="number">2</span>);<span class="comment">//next</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意传递的参数依次是 <code>address type session message_ptr len</code> 下面看看c层是怎么获取lua传递过来的参数的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">send_message</span><span class="params">(lua_State *L, <span class="type">int</span> source, <span class="type">int</span> idx_type)</span> &#123;<span class="comment">//idx_type表示type在传入参数队列中的位置</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">skynet_context</span> * <span class="title">context</span> =</span> lua_touserdata(L, lua_upvalueindex(<span class="number">1</span>));<span class="comment">//获取代表当前所在服务</span></span><br><span class="line"><span class="type">uint32_t</span> dest = (<span class="type">uint32_t</span>)lua_tointeger(L, <span class="number">1</span>);<span class="comment">//获取目标服务地址</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> * dest_string = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (dest == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (lua_type(L,<span class="number">1</span>) == LUA_TNUMBER) &#123;</span><br><span class="line"><span class="keyword">return</span> luaL_error(L, <span class="string">&quot;Invalid service address 0&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">dest_string = get_dest_string(L, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> type = luaL_checkinteger(L, idx_type+<span class="number">0</span>);<span class="comment">//根据指定位置,找到lua层传递的参数,lua类型消息的id</span></span><br><span class="line"><span class="type">int</span> session = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (lua_isnil(L,idx_type+<span class="number">1</span>)) &#123;<span class="comment">//session如果是nil 表示lua层希望分配一个session </span></span><br><span class="line">type |= PTYPE_TAG_ALLOCSESSION;<span class="comment">//向底层申请一个session号</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> mtype = lua_type(L,idx_type+<span class="number">2</span>);<span class="comment">//lua内存块类型</span></span><br><span class="line"><span class="keyword">switch</span> (mtype) &#123;</span><br><span class="line"><span class="keyword">case</span> LUA_TSTRING: &#123;<span class="comment">//LUA_TSTRING表示传递的是lua环境的字符串，上面c.send函数第四个参数是lua的字符串</span></span><br><span class="line"><span class="type">size_t</span> len = <span class="number">0</span>;</span><br><span class="line"><span class="type">void</span> * msg = (<span class="type">void</span> *)lua_tolstring(L,idx_type+<span class="number">2</span>,&amp;len);<span class="comment">//获取lua字符串的指针和长度，但是内存块是lua环境内部的，由lua管理的</span></span><br><span class="line"><span class="keyword">if</span> (len == <span class="number">0</span>) &#123;</span><br><span class="line">msg = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (dest_string) &#123;</span><br><span class="line">session = skynet_sendname(context, source, dest_string, type, session , msg, len);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">session = skynet_send(context, source, dest, type, session , msg, len);<span class="comment">//没有PTYPE_TAG_DONTCOPY表示需要拷贝，因为LUA_TSTRING是lua内部管理，所以需要重新拷贝一份，重新分配内存进行处理</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> LUA_TLIGHTUSERDATA: &#123;<span class="comment">//skynet.call的调用是走这里，LUA_TLIGHTUSERDATA表示已经把lua数据变成内存块+长度的形式</span></span><br><span class="line"><span class="type">void</span> * msg = lua_touserdata(L,idx_type+<span class="number">2</span>);<span class="comment">//拿到内存块指针</span></span><br><span class="line"><span class="type">int</span> size = luaL_checkinteger(L,idx_type+<span class="number">3</span>);<span class="comment">//拿到内存块大小</span></span><br><span class="line"><span class="keyword">if</span> (dest_string) &#123;<span class="comment">//注意这里给 type 还加上了一个 PTYPE_TAG_DONTCOPY 标记 这里source是0</span></span><br><span class="line">session = skynet_sendname(context, source, dest_string, type | PTYPE_TAG_DONTCOPY, session, msg, size);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">session = skynet_send(context, source, dest, type | PTYPE_TAG_DONTCOPY, session, msg, size);<span class="comment">//PTYPE_TAG_DONTCOPY表示不需要拷贝，因为LUA_TLIGHTUSERDATA是C内部管理所以不需要拷贝</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">lua_pushinteger(L,session);</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码给type打了两个标记, <code>PTYPE_TAG_ALLOCSESSION</code> 和 <code>PTYPE_TAG_DONTCOPY</code> 。 <code>PTYPE_TAG_ALLOCSESSION</code> 表示希望服务分配一个 <code>session</code> ， <code>PTYPE_TAG_DONTCOPY</code> 表示是否需要分配新内存。</p><p>由 <code>send_message</code> 代码，接下来调用 <code>skynet_send</code> 函数（最终目的是把消息变成 <code>smsg</code> 的形式，并push到目标服务队列中）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line">_filter_args(<span class="keyword">struct</span> skynet_context * context, <span class="type">int</span> type, <span class="type">int</span> *session, <span class="type">void</span> ** data, <span class="type">size_t</span> * sz) &#123;</span><br><span class="line"><span class="type">int</span> needcopy = !(type &amp; PTYPE_TAG_DONTCOPY);<span class="comment">//检查type里面有没有 PTYPE_TAG_DONTCOPY标签 ，如果有代表不需要拷贝</span></span><br><span class="line"><span class="type">int</span> allocsession = type &amp; PTYPE_TAG_ALLOCSESSION;<span class="comment">//检查type里面有没有 PTYPE_TAG_ALLOCSESSION标记 ，如果有代表需要分配session号</span></span><br><span class="line">type &amp;= <span class="number">0xff</span>;<span class="comment">//只保留低八位  丢弃临时添加的 PTYPE_TAG_DONTCOPY PTYPE_TAG_ALLOCSESSION 这些标记</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (allocsession) &#123;</span><br><span class="line">assert(*session == <span class="number">0</span>);</span><br><span class="line">*session = skynet_context_newsession(context);<span class="comment">//需要分配session的时候 context不能为NULL，session号累加并且唯一</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (needcopy &amp;&amp; *data) &#123;<span class="comment">//直接传递字符串指针是指向lua内部的，需要分配新内存把data数据重新拷贝一份</span></span><br><span class="line"><span class="type">char</span> * msg = skynet_malloc(*sz+<span class="number">1</span>);</span><br><span class="line"><span class="built_in">memcpy</span>(msg, *data, *sz);</span><br><span class="line">msg[*sz] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">*data = msg;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">*sz |= (<span class="type">size_t</span>)type &lt;&lt; MESSAGE_TYPE_SHIFT;<span class="comment">//把type放置到sz的高八位上</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span><span class="comment">//next</span></span><br><span class="line">skynet_send(<span class="keyword">struct</span> skynet_context * context, <span class="type">uint32_t</span> source, <span class="type">uint32_t</span> destination , <span class="type">int</span> type, <span class="type">int</span> session, <span class="type">void</span> * data, <span class="type">size_t</span> sz) &#123;</span><br><span class="line"><span class="keyword">if</span> ((sz &amp; MESSAGE_TYPE_MASK) != sz) &#123;<span class="comment">//sz是当前系统最大无符号数 sz的高8位是给type用 此时高8位必须是全0</span></span><br><span class="line">skynet_error(context, <span class="string">&quot;The message to %x is too large&quot;</span>, destination);</span><br><span class="line"><span class="keyword">if</span> (type &amp; PTYPE_TAG_DONTCOPY) &#123;</span><br><span class="line">skynet_free(data);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-2</span>;</span><br><span class="line">&#125;</span><br><span class="line">_filter_args(context, type, &amp;session, (<span class="type">void</span> **)&amp;data, &amp;sz);<span class="comment">//获取session、分配内存、给type打标记</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (source == <span class="number">0</span>) &#123;<span class="comment">//当前是0</span></span><br><span class="line">source = context-&gt;handle;<span class="comment">//当前服务的handle</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (destination == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (data) &#123;</span><br><span class="line">skynet_error(context, <span class="string">&quot;Destination address can&#x27;t be 0&quot;</span>);</span><br><span class="line">skynet_free(data);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> session;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (skynet_harbor_message_isremote(destination)) &#123;<span class="comment">//判断目标地址是否为远程服务</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">remote_message</span> * <span class="title">rmsg</span> =</span> skynet_malloc(<span class="keyword">sizeof</span>(*rmsg));<span class="comment">// 为远程消息分配一个remote_message结构体</span></span><br><span class="line">rmsg-&gt;destination.handle = destination;<span class="comment">// 设置目标地址</span></span><br><span class="line">rmsg-&gt;message = data;<span class="comment">// 设置消息数据指针</span></span><br><span class="line">rmsg-&gt;sz = sz &amp; MESSAGE_TYPE_MASK;<span class="comment">// 从sz中提取出消息的实际大小（清除高8位类型信息）</span></span><br><span class="line">rmsg-&gt;type = sz &gt;&gt; MESSAGE_TYPE_SHIFT;<span class="comment">// 从sz的高8位提取出消息类型</span></span><br><span class="line">skynet_harbor_send(rmsg, source, session);<span class="comment">// 调用skynet_harbor_send函数将消息发送到远程节点</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">struct</span> skynet_message smsg;<span class="comment">//把处理的lua消息变成skynet_message</span></span><br><span class="line">smsg.source = source;<span class="comment">//当前服务handle</span></span><br><span class="line">smsg.session = session;<span class="comment">//新生成的session</span></span><br><span class="line">smsg.data = data;<span class="comment">//内存块，高8位为消息类型</span></span><br><span class="line">smsg.sz = sz;<span class="comment">//内存块的长度</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (skynet_context_push(destination, &amp;smsg)) &#123;<span class="comment">//把消息push到目标服务的队列</span></span><br><span class="line">skynet_free(data);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> session;<span class="comment">//最后返回session给lua层</span></span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><p> <code>sz</code> 的高八位是预留出来储存 消息类型的。<code>_filter_args</code> 函数做三件事情：</p><ul><li>获取session</li><li>是否需要分配新的内存。</li><li>给 <code>type</code> 打上消息类型的标记，并设置到sz的高八位。</li></ul><h2 id="等待响应"><a href="#等待响应" class="headerlink" title="等待响应"></a>等待响应</h2><p>通过lua层的 <code>skynet.call</code> 得知：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">skynet.call</span><span class="params">(addr, typename, ...)</span></span><span class="comment">--这里是typename是 &quot;lua&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> p = proto[typename]<span class="comment">--根据消息类型获取对应的协议</span></span><br><span class="line"><span class="keyword">local</span> session = c.send(addr, p.id , <span class="literal">nil</span> , p.pack(...))<span class="comment">--seesion是通过当前服务分配的 注意第三个参数是 nil </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> p.<span class="built_in">unpack</span>(yield_call(addr, session))</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>此时session返回了。消息也已经push到目标服务了。接下来就是挂起<strong>当前协程</strong>，等待响应。（<a href="https://barbecue-g.github.io/FrameWork/Skynet/Skynet_%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/Skynet_%E6%9C%8D%E5%8A%A1%E9%97%B4%E8%AF%B7%E6%B1%82%E5%92%8C%E5%93%8D%E5%BA%94/Skynet_%E5%8D%8F%E7%A8%8B">lua协程基础</a> ）</p><blockquote><p>实际上 <code>skynet.call</code> 是在某个协程中被调用的。一般来说，业务代码都是在某个协程中执行的。框架代码就是调度各个协程。</p></blockquote><p>由 <code>skynet.call</code> 代码，调用<code>yield_call(addr, session)</code>：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">yield_call</span><span class="params">(service, session)</span></span></span><br><span class="line"></span><br><span class="line">session_id_coroutine[session] = running_thread <span class="comment">--通过session作为key保存当前协程 </span></span><br><span class="line"><span class="keyword">local</span> succ, msg, sz = coroutine_yield <span class="string">&quot;SUSPEND&quot;</span> <span class="comment">--这里表示挂起当前协程</span></span><br><span class="line">watching_session[session] = <span class="literal">nil</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">return</span> msg,sz</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>在挂起协程前，通过 <code>session</code> 作为key保存当前协程 。等响应消息到来时，通过响应消息里面的 <code>session</code> 可以找到当前协程，然后唤醒这个协程。</p><p>db服务处理main服务发送的请求。（<a href="https://barbecue-g.github.io/FrameWork/Skynet/Skynet_%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/Skynet_%E6%9C%8D%E5%8A%A1%E9%97%B4%E8%AF%B7%E6%B1%82%E5%92%8C%E5%93%8D%E5%BA%94/Skynet_db%E6%9C%8D%E5%8A%A1%E5%A4%84%E7%90%86%E8%AF%B7%E6%B1%82">db服务处理请求</a>）</p><h2 id="收到响应"><a href="#收到响应" class="headerlink" title="收到响应"></a>收到响应</h2><p>收到db发送过来的响应消息后，lua服务会把队列里面的消息转交给lua层的一个函数 <code>skynet.dispatch_message</code> 处理，内部先是调用 <code>raw_dispatch_message</code> 处理。这里是处理响应消息。</p><blockquote><p>每个snlua服务都会调用<code>skynet.start(start_func)</code>函数注册启动函数。<code>skynet.start</code>在内部都会向c层注册一个lua层的回调函数。lua服务会把消息队列里面的消息处理最终交给这个回调函数处理。这个回调函数就是 <code>skynet.dispatch_message</code>。</p></blockquote><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">raw_dispatch_message</span><span class="params">(prototype, msg, sz, session, source)</span></span></span><br><span class="line"><span class="comment">-- skynet.PTYPE_RESPONSE = 1, read skynet.h</span></span><br><span class="line"><span class="keyword">if</span> prototype == <span class="number">1</span> <span class="keyword">then</span> <span class="comment">--这里是处理响应</span></span><br><span class="line"><span class="keyword">local</span> co = session_id_coroutine[session] <span class="comment">--响应消息的处理都是 通过seesion去得到协程 然后执行协程;因为session是本服务分配的 所以具有唯一性</span></span><br><span class="line"></span><br><span class="line">        session_id_coroutine[session] = <span class="literal">nil</span></span><br><span class="line">        suspend(co, coroutine_resume(co, <span class="literal">true</span>, msg, sz, session))<span class="comment">--唤醒协程序yield_call</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>会根据响应消息的 <code>session</code> 找到协程，唤醒协程继续运行：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">skynet.call</span><span class="params">(addr, typename, ...)</span></span><span class="comment">--这里是typename是 &quot;lua&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> p = proto[typename]<span class="comment">--根据消息类型获取对应的协议</span></span><br><span class="line"><span class="keyword">local</span> session = c.send(addr, p.id , <span class="literal">nil</span> , p.pack(...))<span class="comment">--seesion是通过当前服务分配的 注意第三个参数是 nil </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> p.<span class="built_in">unpack</span>(yield_call(addr, session))</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>此时 <code>yield_call</code> 返回，同时 <code>skynet.call</code> 接着返回，得到了想要的年龄信息。</p>]]></content>
      
      
      <categories>
          
          <category> skynet </category>
          
      </categories>
      
      
        <tags>
            
            <tag> skynet </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Skynet_db服务处理请求</title>
      <link href="/FrameWork/Skynet/Skynet_%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/Skynet_%E6%9C%8D%E5%8A%A1%E9%97%B4%E8%AF%B7%E6%B1%82%E5%92%8C%E5%93%8D%E5%BA%94/Skynet_db%E6%9C%8D%E5%8A%A1%E5%A4%84%E7%90%86%E8%AF%B7%E6%B1%82"/>
      <url>/FrameWork/Skynet/Skynet_%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/Skynet_%E6%9C%8D%E5%8A%A1%E9%97%B4%E8%AF%B7%E6%B1%82%E5%92%8C%E5%93%8D%E5%BA%94/Skynet_db%E6%9C%8D%E5%8A%A1%E5%A4%84%E7%90%86%E8%AF%B7%E6%B1%82</url>
      
        <content type="html"><![CDATA[<h1 id="Skynet-db服务处理请求"><a href="#Skynet-db服务处理请求" class="headerlink" title="Skynet_db服务处理请求"></a>Skynet_db服务处理请求</h1><h2 id="db服务处理main服务发送过来的请求"><a href="#db服务处理main服务发送过来的请求" class="headerlink" title="db服务处理main服务发送过来的请求"></a>db服务处理main服务发送过来的请求</h2><p> <code>db</code> 服务指定的lua文件：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--db.lua</span></span><br><span class="line"><span class="keyword">local</span> skynet = <span class="built_in">require</span> <span class="string">&quot;skynet&quot;</span></span><br><span class="line"><span class="built_in">require</span> <span class="string">&quot;skynet.manager&quot;</span><span class="comment">-- import skynet.register</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> db = &#123;<span class="comment">--保存了年龄</span></span><br><span class="line">    zhangsan = <span class="number">12</span>,</span><br><span class="line">    lisi = <span class="number">33</span>,</span><br><span class="line">    wangwu = <span class="number">4</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> command = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">command.GET</span><span class="params">(key)</span></span></span><br><span class="line"><span class="keyword">return</span> db[key]</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">skynet.start(<span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br><span class="line"></span><br><span class="line">skynet.dispatch(<span class="string">&quot;lua&quot;</span>, <span class="function"><span class="keyword">function</span><span class="params">(session, address, cmd, ...)</span></span><span class="comment">--对应lua消息注册任务函数，专门处理 lua类型 的请求</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> f = command[cmd] <span class="comment">--这里收到的 cmd 是&quot;GET&quot; ，参数是 &quot;zhangsan&quot;，main服务传入的key</span></span><br><span class="line"><span class="keyword">if</span> f <span class="keyword">then</span></span><br><span class="line">skynet.ret(skynet.pack(f(...)))<span class="comment">--发送响应给main服务，pack打包，ret发回（ret函数在本文最后面）</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span>)</span><br></pre></td></tr></table></figure><p>lua服务把消息队列的消息取出后，调用c的回调函数，最终是把消息交给一个指定的lua函数处理。</p><p>snlua服务的lua函数就是 <code>skynet.dispatch_message</code> 。处理消息主要分为两大步：</p><ol><li><code>raw_dispatch_message</code>  函数</li><li>不断的从 <code>fork_queue</code> 队列中把协程取出来做处理。</li></ol><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">skynet.dispatch_message</span><span class="params">(...)</span></span></span><br><span class="line"><span class="keyword">local</span> succ, err = <span class="built_in">pcall</span>(raw_dispatch_message,...)</span><br><span class="line"><span class="keyword">while</span> <span class="literal">true</span> <span class="keyword">do</span></span><br><span class="line"><span class="keyword">if</span> fork_queue.h &gt; fork_queue.t <span class="keyword">then</span></span><br><span class="line"><span class="comment">-- queue is empty</span></span><br><span class="line">fork_queue.h = <span class="number">1</span>  <span class="comment">--head</span></span><br><span class="line">fork_queue.t = <span class="number">0</span>  <span class="comment">--tail</span></span><br><span class="line"><span class="keyword">break</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">-- pop queue</span></span><br><span class="line"><span class="keyword">local</span> h = fork_queue.h</span><br><span class="line"><span class="keyword">local</span> co = fork_queue[h]</span><br><span class="line">fork_queue[h] = <span class="literal">nil</span></span><br><span class="line">fork_queue.h = h + <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> fork_succ, fork_err = <span class="built_in">pcall</span>(suspend,co,coroutine_resume(co))</span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="built_in">assert</span>(succ, <span class="built_in">tostring</span>(err))</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>在lua服务中会收到请求消息和响应消息。（a发送一个请求给b，然后等待b回应。b收到的这个请求，就是请求消息。当a收到b的回应消息时，这个消息就是响应消息。此时db服务收到了一个lua类型的消息。）</p><h3 id="raw-dispatch-message-函数"><a href="#raw-dispatch-message-函数" class="headerlink" title="raw_dispatch_message  函数"></a><code>raw_dispatch_message</code>  函数</h3><p>由 <code>skynet.dispatch_message</code> 代码，调用 <code>raw_dispatch_message</code> ：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">raw_dispatch_message</span><span class="params">(prototype, msg, sz, session, source)</span></span></span><br><span class="line">  <span class="comment">-- prototype消息类型（name = &quot;lua&quot;,--协议类型名字；id = skynet.PTYPE_LUA,--协议id），</span></span><br><span class="line">  <span class="comment">-- msg内存块指针，</span></span><br><span class="line">  <span class="comment">-- sz内存块长度，</span></span><br><span class="line">  <span class="comment">-- session是main服务中生成的session号，</span></span><br><span class="line">  <span class="comment">-- source是main服务地址</span></span><br><span class="line"><span class="keyword">if</span> prototype == <span class="number">1</span> <span class="keyword">then</span> <span class="comment">--处理响应-- skynet.PTYPE_RESPONSE = 1, read skynet.h</span></span><br><span class="line"><span class="comment">--db服务这里是请求消息，再次略</span></span><br><span class="line"><span class="keyword">else</span> <span class="comment">--这里主要是处理lua text socket 等消息类型 </span></span><br><span class="line"><span class="keyword">local</span> p = proto[prototype]<span class="comment">--通过传入的prototype类型获取协议，这里的lua类型</span></span><br><span class="line">        </span><br><span class="line"><span class="keyword">local</span> f = p.dispatch<span class="comment">--获取任务函数，在db服务中注册的dispatch任务函数</span></span><br><span class="line"><span class="keyword">if</span> f <span class="keyword">then</span></span><br><span class="line"><span class="keyword">local</span> co = co_create(f)<span class="comment">--获取一个协程对象并设置任务函数f</span></span><br><span class="line">session_coroutine_id[co] = session <span class="comment">--保存session以便找到回去的路;注意这里的session是其他服务独立产生的,所以不同的请求者发过来的session可以是相同的</span></span><br><span class="line">session_coroutine_address[co] = source <span class="comment">--保存source以便找到回去的路 即记录请求者是谁</span></span><br><span class="line"></span><br><span class="line">suspend(co, coroutine_resume(co, session,source, p.<span class="built_in">unpack</span>(msg,sz)))<span class="comment">--unpack解包成lua对象</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>代码逻辑：</p><ol><li>首先根据消息类型找到对应的协议，这里是lua类型。</li><li>获取任务处理函数 <code>f</code> </li><li>获取一个协程，给协程设置 <code>f</code> 函数</li><li>唤醒上面3的协程去处理收到的消息</li></ol><blockquote><p>注意：唤醒协程开始执行前，必须先保存请求者的信息，不然后面处理完请求后，都不知道把结果发送给谁。（这里是以 <code>co</code> 为 <code>key</code> 保存请求者信息的。为什么不用 <code>session</code> ？原因是，不同的请求者发送过来的 <code>session</code> 可能是相同的。因为 <code>session</code> 是每个服务自己产生的。a服务可以产生一个 <code>session</code> 号9527，b服务也可以产生一个 <code>session</code> 号9527。）</p></blockquote><p>当调用 <code>skynet.sleep</code> 或者 <code>skynet.wait</code> 时，会把指定协程加入到 <code>sleep_session</code> 睡眠表中，标识协程是睡眠状态，同时当前协程会挂起。在合适的时机调用 <code>skynet.wakeup</code> 就会把指定的睡眠协程加入到 <code>wakeup_queue</code> 唤醒队列中。之后唤醒队列里面的协程就会被调度，得到执行。</p><blockquote><p>注意：把协程加入唤醒队列，不代表马上就唤醒协程执行。</p></blockquote><p><strong>唤醒协程</strong>是通过 <code>coroutine_resume(co, session,source, p.unpack(msg,sz))</code> 。任务函数 <code>f</code> 是db服务在入口函数里设置的。当db的业务处理完成后，即协程挂起时，就会执行 <code>suspend</code> 。<code>suspend</code> 是一个框架函数，用于管理协程的挂起和恢复状态，会唤醒其他协程。（总结：当lua服务收到一个消息时，就会有一个协程去处理，当协程处理后，挂起时，就会给执行权给其他协程。）</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">suspend</span><span class="params">(co, result, command)</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> command == <span class="string">&quot;SUSPEND&quot;</span> <span class="keyword">then</span></span><br><span class="line"><span class="keyword">return</span> dispatch_wakeup() <span class="comment">--next</span></span><br><span class="line"><span class="keyword">elseif</span> command == <span class="string">&quot;QUIT&quot;</span> <span class="keyword">then</span></span><br><span class="line"><span class="built_in">coroutine</span>.<span class="built_in">close</span>(co)</span><br><span class="line"><span class="comment">-- service exit</span></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>上面的代码一般情况下 ，挂起时都会返回 “”SUSPEND””。</p><p>由 <code>suspend</code> 代码，调用 <code>dispatch_wakeup</code> ：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">dispatch_wakeup</span><span class="params">()</span></span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">true</span> <span class="keyword">do</span></span><br><span class="line"><span class="keyword">local</span> token = tremove(wakeup_queue,<span class="number">1</span>)<span class="comment">--从唤醒队列中不断取出协程</span></span><br><span class="line"><span class="keyword">if</span> token <span class="keyword">then</span></span><br><span class="line"><span class="keyword">local</span> session = sleep_session[token] <span class="comment">-- 从sleep表中查找 注意 这个表和 唤醒队列 具有不同的意义</span></span><br><span class="line"><span class="keyword">if</span> session <span class="keyword">then</span></span><br><span class="line"><span class="keyword">local</span> co = session_id_coroutine[session]<span class="comment">--通过session从映射表中找到之前挂起的协程</span></span><br><span class="line"></span><br><span class="line">session_id_coroutine[session] = <span class="string">&quot;BREAK&quot;</span><span class="comment">--将这个session在映射表中的条目标记为&quot;BREAK&quot;</span></span><br><span class="line"><span class="keyword">return</span> suspend(co, coroutine_resume(co, <span class="literal">false</span>, <span class="string">&quot;BREAK&quot;</span>, <span class="literal">nil</span>, session))</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">break</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">return</span> dispatch_error_queue()<span class="comment">--这里是为了处理这种情况:当前服务在苦苦等待服务x响应,而服务x已经有错误,且已经把错误通知当前服务了 </span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p> <code>dispatch_wakeup</code> 主要的处理过程：</p><ol><li>如果唤醒队列中取出 <code>token</code> 通过sleep表获得 <code>session</code> 。</li><li>通过session从映射表中找到之前挂起的协程,唤醒并执行。</li><li>执行挂起后回到 <code>suspend</code> 再次循环，直到唤醒队列为空。</li><li>跳出循环执行 <code>dispatch_error_queue</code> 。</li></ol><p> <code>dispatch_error_queue</code> 代码：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">dispatch_error_queue</span><span class="params">()</span></span></span><br><span class="line"><span class="keyword">local</span> session = tremove(error_queue,<span class="number">1</span>)</span><br><span class="line"><span class="keyword">if</span> session <span class="keyword">then</span></span><br><span class="line"><span class="keyword">local</span> co = session_id_coroutine[session]</span><br><span class="line">session_id_coroutine[session] = <span class="literal">nil</span></span><br><span class="line"><span class="keyword">return</span> suspend(co, coroutine_resume(co, <span class="literal">false</span>, <span class="literal">nil</span>, <span class="literal">nil</span>, session))</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p> <code>dispatch_error_queue</code> 主要的处理过程：</p><ol><li>当 <code>error_queue</code> 错误队列有错误类型消息时，调用 <code>suspend</code> 进行处理。</li><li>当 <code>error_queue</code> 错误队列也没有消息时，函数调用回到 <code>raw_dispatch_message</code> 。</li></ol><p>以上几个函数的共同特点是最后都会调用 <code>suspend </code>。这里不是递归调用，而是lua的尾调用。调用帧是不会一直递增的。<a href="https://barbecue-g.github.io/FrameWork/Skynet/Skynet_%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/Skynet_%E6%9C%8D%E5%8A%A1%E9%97%B4%E8%AF%B7%E6%B1%82%E5%92%8C%E5%93%8D%E5%BA%94/Skynet_lua%E5%87%BD%E6%95%B0%E5%B0%BE%E8%B0%83%E7%94%A8">lua函数尾调用</a> </p><p>这里的调用逻辑是：</p><p> <code>skynet.dispatch_message</code> -&gt; <code>raw_dispatch_message</code>-&gt; <code>suspend</code> （ <code>suspend</code> 进行尾调用持续唤醒）</p><p> <code>error_queue</code> 错误队列：当协程a发送请求给x服务后，会等待x服务给出响应。如果此时x服务退出或者是处理出现错误，x服务会给a服务发送一个错误类型的消息。针对错误消息的处理函数会把协程a加入错误队列，等待时机唤醒执行，不然协程a就会一直挂起。</p><p>错误消息的处理函数：主要是把之前等待的协程加入错误队列。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">REG &#123;</span><br><span class="line">name = <span class="string">&quot;error&quot;</span>,</span><br><span class="line">id = skynet.PTYPE_ERROR,</span><br><span class="line"><span class="built_in">unpack</span> = <span class="function"><span class="keyword">function</span><span class="params">(...)</span></span> <span class="keyword">return</span> ... <span class="keyword">end</span>,</span><br><span class="line">dispatch = _error_dispatch,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">_error_dispatch</span><span class="params">(error_session, error_source)</span></span></span><br><span class="line">skynet.ignoreret()<span class="comment">-- don&#x27;t return for error</span></span><br><span class="line"><span class="keyword">if</span> error_session == <span class="number">0</span> <span class="keyword">then</span> <span class="comment">--收到一个即将下线的服务x的错误消息 </span></span><br><span class="line"><span class="comment">-- error_source is down, clear unreponse set </span></span><br><span class="line"><span class="keyword">for</span> session, srv <span class="keyword">in</span> <span class="built_in">pairs</span>(watching_session) <span class="keyword">do</span> <span class="comment">--原本发出请求给服务x,等待x响应的协程需要另外处理了</span></span><br><span class="line"><span class="keyword">if</span> srv == error_source <span class="keyword">then</span></span><br><span class="line">tinsert(error_queue, session)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="comment">-- capture an error for error_session</span></span><br><span class="line"><span class="keyword">if</span> watching_session[error_session] <span class="keyword">then</span></span><br><span class="line">tinsert(error_queue, error_session)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h3 id="从-fork-queue-队列取出协程并处理"><a href="#从-fork-queue-队列取出协程并处理" class="headerlink" title="从 fork_queue 队列取出协程并处理"></a>从 <code>fork_queue</code> 队列取出协程并处理</h3><p>处理 <code>fork_queue</code> <strong>次级异步任务</strong>：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">skynet.dispatch_message</span><span class="params">(...)</span></span></span><br><span class="line"><span class="comment">-- 使用pcall保护调用raw_dispatch_message，目的是捕获处理主消息过程中的任何错误</span></span><br><span class="line"><span class="comment">-- raw_dispatch_message 是实际处理消息的内部函数，负责查找对应的回调函数并执行</span></span><br><span class="line"><span class="keyword">local</span> succ, err = <span class="built_in">pcall</span>(raw_dispatch_message,...)</span><br><span class="line"><span class="keyword">while</span> <span class="literal">true</span> <span class="keyword">do</span> <span class="comment">--专门处理fork_queue中等待执行的协程任务</span></span><br><span class="line"><span class="keyword">if</span> fork_queue.h &gt; fork_queue.t <span class="keyword">then</span><span class="comment">-- 检查fork_queue是否为空（头指针h大于尾指针t表示队列空）</span></span><br><span class="line"><span class="comment">-- 队列为空时，重置队列的头尾指针以复用空间，避免表无限增长</span></span><br><span class="line">fork_queue.h = <span class="number">1</span>  <span class="comment">--head 重置头指针到起始位置</span></span><br><span class="line">fork_queue.t = <span class="number">0</span>  <span class="comment">--tail重置尾指针到头指针之前，表示空队列</span></span><br><span class="line"><span class="keyword">break</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">-- pop queue: 以下代码从fork_queue的头部取出一个协程对象</span></span><br><span class="line"><span class="keyword">local</span> h = fork_queue.h<span class="comment">-- 记录当前头指针的位置</span></span><br><span class="line"><span class="keyword">local</span> co = fork_queue[h]<span class="comment">-- 获取头指针位置对应的协程对象</span></span><br><span class="line">fork_queue[h] = <span class="literal">nil</span><span class="comment">-- 将表中该位置的引用置空，帮助垃圾回收</span></span><br><span class="line">fork_queue.h = h + <span class="number">1</span><span class="comment">-- 头指针向后移动一位，指向下一个待处理元素</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">-- 使用pcall保护执行，目的是恢复执行刚取出的协程co，并捕获执行中的错误</span></span><br><span class="line"><span class="keyword">local</span> fork_succ, fork_err = <span class="built_in">pcall</span>(suspend,co,coroutine_resume(co))</span><br><span class="line"><span class="comment">-- 注意：这里没有对fork_succ和fork_err进行处理。即使某个fork任务出错，也不会影响主消息循环和其他fork任务。</span></span><br><span class="line">    <span class="comment">-- 在实际生产环境中，这里可能需要记录错误日志。</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">  <span class="comment">-- 检查主消息处理(raw_dispatch_message)是否成功。若失败，用tostring转换错误信息并断言抛出错误。</span></span><br><span class="line"><span class="comment">-- 这意味着主消息处理过程中的错误是致命的，会导致服务中断。</span></span><br><span class="line"><span class="built_in">assert</span>(succ, <span class="built_in">tostring</span>(err))</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>以上主要是从 <code>fork_queue</code> 队列中不断的取出协程，然后依旧是调用<code>suspend</code>来处理。</p><p><code>fork_queue</code> 里面的协程是怎么来的？一般当在业务层需要协程的时候，会调用 <code>skynet.fork(func,...)</code> 来用于异步创建一个新的执行任务：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">skynet.fork</span><span class="params">(func,...)</span></span><span class="comment">--用于异步创建一个新的执行任务，func是要执行的函数，...是传递给该函数的参数</span></span><br><span class="line"><span class="keyword">local</span> n = <span class="built_in">select</span>(<span class="string">&quot;#&quot;</span>, ...)<span class="comment">-- 获取可变参数的长度（参数个数）</span></span><br><span class="line"><span class="keyword">local</span> co</span><br><span class="line"><span class="keyword">if</span> n == <span class="number">0</span> <span class="keyword">then</span></span><br><span class="line">    <span class="comment">-- 当没有额外参数时，直接使用co_create函数创建执行func的协程</span></span><br><span class="line">    <span class="comment">-- co_create通常从协程池获取空闲协程或创建新协程，并绑定执行函数</span></span><br><span class="line">co = co_create(func)</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">local</span> args = &#123; ... &#125;<span class="comment">-- 当有额外参数时，将可变参数...收集到一个表args中</span></span><br><span class="line">    <span class="comment">-- 创建协程，该协程的执行函数是一个闭包，用于调用func并传入打包好的参数args</span></span><br><span class="line">    <span class="comment">-- table.unpack(args,1,n) 将参数表args解包为参数列表</span></span><br><span class="line">co = co_create(<span class="function"><span class="keyword">function</span><span class="params">()</span></span> func(<span class="built_in">table</span>.<span class="built_in">unpack</span>(args,<span class="number">1</span>,n)) <span class="keyword">end</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">  <span class="comment">-- 计算队列新的尾部位置（当前尾部t + 1）</span></span><br><span class="line"><span class="keyword">local</span> t = fork_queue.t + <span class="number">1</span> <span class="comment">--尾部递增</span></span><br><span class="line">fork_queue.t = t<span class="comment">-- 更新fork_queue的尾指针t</span></span><br><span class="line">fork_queue[t] = co <span class="comment">-- 将新创建的协程co放入fork_queue的尾部（实现FIFO队列的入队操作）</span></span><br><span class="line"><span class="keyword">return</span> co</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>关键机制说明</p><ol><li><strong>两级队列与调度</strong>:<ul><li><code>skynet.dispatch_message</code>首先处理主消息 (<code>raw_dispatch_message</code>)。</li><li>主消息处理完毕后，才集中处理本次消息驱动过程中通过 <code>skynet.fork</code>产生的<strong>次级异步任务</strong>（<code>fork_queue</code>中的协程）。这保证了主消息处理的及时性，并将异步任务积压到同一批次处理，<strong>避免在单个消息处理过程中无限创建和切换协程</strong>，提高了整体性能和处理公平性。</li></ul></li><li><strong>错误处理差异</strong>:<ul><li><strong>主消息处理</strong> (<code>raw_dispatch_message</code>) 的错误通过 <code>assert</code>抛出，通常是<strong>致命</strong>的，可能导致服务处理循环中断。</li><li><strong>Fork 任务</strong>（协程）中的错误被 <code>pcall</code>捕获但仅存储在 <code>fork_err</code>中，<strong>未被处理</strong>。这意味着单个 fork 任务的失败不会影响其他 fork 任务或主消息循环，但可能需要额外的日志记录和监控。</li></ul></li><li><strong>Fork 队列管理</strong>:<ul><li><code>fork_queue</code>是一个<strong>数组模拟的 FIFO 队列</strong>，通过头尾指针 <code>h</code>和 <code>t</code>进行管理。</li><li>队列被处理完毕后（<code>h &gt; t</code>），头尾指针会被<strong>重置</strong>（<code>h=1, t=0</code>），这是为了复用数组空间，防止数组索引无限增长（Lua 表的数组部分大小是动态的，但重用空间是一种优化和良好实践）。</li></ul></li></ol><h2 id="db服务返回响应给main服务"><a href="#db服务返回响应给main服务" class="headerlink" title="db服务返回响应给main服务"></a>db服务返回响应给main服务</h2><p>db服务是在处理完业务后（拿到年龄信息），把信息发送给main服务。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--db.lua</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> skynet = <span class="built_in">require</span> <span class="string">&quot;skynet&quot;</span></span><br><span class="line"><span class="built_in">require</span> <span class="string">&quot;skynet.manager&quot;</span><span class="comment">-- import skynet.register</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> db = &#123;<span class="comment">--保存了年龄</span></span><br><span class="line">    zhangsan = <span class="number">12</span>,</span><br><span class="line">    lisi = <span class="number">33</span>,</span><br><span class="line">    wangwu = <span class="number">4</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> command = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">command.GET</span><span class="params">(key)</span></span></span><br><span class="line"><span class="keyword">return</span> db[key]</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">skynet.start(<span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br><span class="line"></span><br><span class="line">skynet.dispatch(<span class="string">&quot;lua&quot;</span>, <span class="function"><span class="keyword">function</span><span class="params">(session, address, cmd, ...)</span></span><span class="comment">--这里专门处理 lua类型 的请求</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> f = command[cmd] <span class="comment">--这里收到的 cmd 是&quot;GET&quot;</span></span><br><span class="line"><span class="keyword">if</span> f <span class="keyword">then</span></span><br><span class="line">skynet.ret(skynet.pack(f(...)))<span class="comment">--发送响应给main服务</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span>)</span><br></pre></td></tr></table></figure><p> <code>skynet.ret</code> 把返回数据发送给 main服务：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">skynet.ret</span><span class="params">(msg, sz)</span></span></span><br><span class="line">msg = msg <span class="keyword">or</span> <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> co_session = session_coroutine_id[running_thread] <span class="comment">--通过当前的协程找到session</span></span><br><span class="line"></span><br><span class="line">session_coroutine_id[running_thread] = <span class="literal">nil</span><span class="comment">-- 获取到会话ID后，立即清除running_thread对应的记录</span></span><br><span class="line"><span class="keyword">if</span> co_session == <span class="number">0</span> <span class="keyword">then</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span><span class="comment">-- send don&#x27;t need ret</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">local</span> co_address = session_coroutine_address[running_thread] <span class="comment">--通过当前的协程找到请求者地址</span></span><br><span class="line"><span class="keyword">local</span> ret = c.send(co_address, skynet.PTYPE_RESPONSE, co_session, msg, sz) <span class="comment">--注意消息类型是 skynet.PTYPE_RESPONSE响应消息</span></span><br><span class="line"><span class="keyword">if</span> ret <span class="keyword">then</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>当db收到请求时，把请求者的信息保存下来。而且是以”当前协程”为 <code>key</code> ，”请求者信息”为 <code>value</code> 保存的。现在把信息取出来，通过 <code>c.send</code> 发送给给 main 服务的队列。</p>]]></content>
      
      
      <categories>
          
          <category> skynet </category>
          
      </categories>
      
      
        <tags>
            
            <tag> skynet </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Skynet_处理队列消息</title>
      <link href="/FrameWork/Skynet/Skynet_%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/Skynet_logger%E6%9C%8D%E5%8A%A1/Skynet_%E5%A4%84%E7%90%86%E9%98%9F%E5%88%97%E6%B6%88%E6%81%AF"/>
      <url>/FrameWork/Skynet/Skynet_%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/Skynet_logger%E6%9C%8D%E5%8A%A1/Skynet_%E5%A4%84%E7%90%86%E9%98%9F%E5%88%97%E6%B6%88%E6%81%AF</url>
      
        <content type="html"><![CDATA[<h1 id="Skynet-处理队列消息"><a href="#Skynet-处理队列消息" class="headerlink" title="Skynet_处理队列消息"></a>Skynet_处理队列消息</h1><p>工作线程 <code>thread_worker</code> 在设置完参数后，服务队列的消息在 <code>while</code> 循环中不断被处理和分发：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> *</span><br><span class="line"><span class="title function_">thread_worker</span><span class="params">(<span class="type">void</span> *p)</span> &#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">worker_parm</span> *<span class="title">wp</span> =</span> p;</span><br><span class="line"><span class="type">int</span> id = wp-&gt;id;</span><br><span class="line"><span class="type">int</span> weight = wp-&gt;weight;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">monitor</span> *<span class="title">m</span> =</span> wp-&gt;m;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">skynet_monitor</span> *<span class="title">sm</span> =</span> m-&gt;m[id];</span><br><span class="line">skynet_initthread(THREAD_WORKER);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">message_queue</span> * <span class="title">q</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">while</span> (!m-&gt;quit) &#123;</span><br><span class="line">q = skynet_context_message_dispatch(sm, q, weight);<span class="comment">//next</span></span><br><span class="line"><span class="keyword">if</span> (q == <span class="literal">NULL</span>) &#123;<span class="comment">//没有消息处理 就休息一下 等待唤醒</span></span><br><span class="line"><span class="keyword">if</span> (pthread_mutex_lock(&amp;m-&gt;mutex) == <span class="number">0</span>) &#123;</span><br><span class="line">++ m-&gt;sleep;</span><br><span class="line"><span class="comment">// “虚假唤醒”是无害的，</span></span><br><span class="line"><span class="comment">// 因为skynet_context_message_dispatch（）可以随时调用。</span></span><br><span class="line"><span class="keyword">if</span> (!m-&gt;quit)</span><br><span class="line">pthread_cond_wait(&amp;m-&gt;cond, &amp;m-&gt;mutex);<span class="comment">//这个函数调用时释放锁,返回时获取锁 </span></span><br><span class="line">-- m-&gt;sleep;</span><br><span class="line"><span class="keyword">if</span> (pthread_mutex_unlock(&amp;m-&gt;mutex)) &#123;</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;unlock mutex error&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>服务队列的消息被消息分发函数 <code>skynet_context_message_dispatch</code> 进行处理：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">message_queue</span> * //<span class="title">next</span></span></span><br><span class="line"><span class="class"><span class="title">skynet_context_message_dispatch</span>(<span class="keyword">struct</span> <span class="title">skynet_monitor</span> *<span class="title">sm</span>, <span class="keyword">struct</span> <span class="title">message_queue</span> *<span class="title">q</span>, <span class="title">int</span> <span class="title">weight</span>) &#123;</span></span><br><span class="line"><span class="keyword">if</span> (q == <span class="literal">NULL</span>) &#123;</span><br><span class="line">q = skynet_globalmq_pop();<span class="comment">//从全局队列中取出一个服务队列</span></span><br><span class="line"><span class="keyword">if</span> (q==<span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">uint32_t</span> handle = skynet_mq_handle(q);<span class="comment">//通过队列获取他对应的handle</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">skynet_context</span> * <span class="title">ctx</span> =</span> skynet_handle_grab(handle);<span class="comment">//从cxt仓库中获取ctx</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> i,n=<span class="number">1</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">skynet_message</span> <span class="title">msg</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;n;i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (skynet_mq_pop(q,&amp;msg)) &#123;<span class="comment">//skynet_mq_pop返回值为0 表示成功 否则表示队列是空的</span></span><br><span class="line">skynet_context_release(ctx);<span class="comment">//表示服务可能标记退出,如果不是,注意 此时队列没有重新push到全局队列</span></span><br><span class="line"><span class="keyword">return</span> skynet_globalmq_pop();</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (i==<span class="number">0</span> &amp;&amp; weight &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">n = skynet_mq_length(q);<span class="comment">//当前队列等待处理的消息个数</span></span><br><span class="line">n &gt;&gt; = weight;<span class="comment">//假设此时weight是2 队列长度是16 那么此时n==4 即这次要处理4个消息</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> overload = skynet_mq_overload(q);<span class="comment">//overload包含两个意思 1.是否过载 2.当前过载数,也就是当前队列等待处理的消息个数</span></span><br><span class="line"><span class="keyword">if</span> (overload) &#123;<span class="comment">//过载</span></span><br><span class="line">skynet_error(ctx, <span class="string">&quot;May overload, message queue length = %d&quot;</span>, overload);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">skynet_monitor_trigger(sm, msg.source , handle);<span class="comment">//如果339行一直得不到执行 那么 监听管理线程 就会报告消息处理进入死循环</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ctx-&gt;cb == <span class="literal">NULL</span>) &#123;</span><br><span class="line">skynet_free(msg.data);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">dispatch_message(ctx, &amp;msg);<span class="comment">//把消息交给服务内部的回调函数处理 next</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">skynet_monitor_trigger(sm, <span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">assert(q == ctx-&gt;<span class="built_in">queue</span>);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">message_queue</span> *<span class="title">nq</span> =</span> skynet_globalmq_pop();<span class="comment">//再次弹出一个队列</span></span><br><span class="line"><span class="keyword">if</span> (nq) &#123;<span class="comment">//说明全局队列不为空 那么把刚刚处理过的队列push进全局队列 并返回新拿到的队列为下一轮消息处理做准备</span></span><br><span class="line"><span class="comment">// If global mq is not empty , push q back, and return next queue (nq)</span></span><br><span class="line"><span class="comment">// Else (global mq is empty or block, don&#x27;t push q back, and return q again (for next dispatch)</span></span><br><span class="line">skynet_globalmq_push(q);</span><br><span class="line">q = nq;</span><br><span class="line">&#125; </span><br><span class="line">skynet_context_release(ctx);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> q;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>工作线程的每一轮处理过程是：</p><ol><li>从全局队列中取出一个队列，然后取出队列里面的消息进行处理。</li><li>队列处理完成后,把队列重新加入到全局队列的尾部。接着处理下一轮的消息。</li><li>每次拿到一个队列时,可能会处理其中的一个消息,也可能处理其中的几个消息。（这个与当前线程分配的权重有关。这个权重在工作线程启动时就设置好了）。如下所示</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> weight[] = &#123; </span><br><span class="line"><span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line"><span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, </span><br><span class="line"><span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, </span><br><span class="line"><span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, &#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">worker_parm</span> <span class="title">wp</span>[<span class="title">thread</span>];</span></span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;thread;i++) &#123;</span><br><span class="line">wp[i].m = m;</span><br><span class="line">wp[i].id = i;</span><br><span class="line"><span class="keyword">if</span> (i &lt; <span class="keyword">sizeof</span>(weight)/<span class="keyword">sizeof</span>(weight[<span class="number">0</span>])) &#123;<span class="comment">//设置前面32个工作线程的 weight</span></span><br><span class="line">wp[i].weight= weight[i];</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;<span class="comment">//第32个工作线程之后的 weight</span></span><br><span class="line">wp[i].weight = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">create_thread(&amp;pid[i+<span class="number">3</span>], thread_worker, &amp;wp[i]);<span class="comment">//给每个工作线程传递不同参数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>工作线程中，队列消息的权重：</p><p><img src="https://cdn.jsdelivr.net/gh/Barbecue-g/imagehost/FrameWork/Skynet/%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/Skynet_logger%E6%9C%8D%E5%8A%A1/Skynet_%E6%B6%88%E6%81%AF%E6%9D%83%E9%87%8D.png?raw=true" alt="Skynet_消息权重"></p><p>当工作线程确定处理某条消息的时候调用，通过 <code>dispatch_message</code> 函数把消息交给服务内部的回调函数处理：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">dispatch_message</span><span class="params">(<span class="keyword">struct</span> skynet_context *ctx, <span class="keyword">struct</span> skynet_message *msg)</span> &#123;</span><br><span class="line">assert(ctx-&gt;init);</span><br><span class="line">CHECKCALLING_BEGIN(ctx)</span><br><span class="line">pthread_setspecific(G_NODE.handle_key, (<span class="type">void</span> *)(<span class="type">uintptr_t</span>)(ctx-&gt;handle));<span class="comment">//把handle保存到线程局部存储 是为获取当前服务内存情况服务的</span></span><br><span class="line"><span class="type">int</span> type = msg-&gt;sz &gt;&gt; MESSAGE_TYPE_SHIFT;<span class="comment">//获取消息的类型 比如 PTYPE_TEXT PTYPE_SOCKET 等等</span></span><br><span class="line"><span class="type">size_t</span> sz = msg-&gt;sz &amp; MESSAGE_TYPE_MASK; <span class="comment">//获取消息的真实sz 实质上去掉了sz头部的高八位代表的消息类型</span></span><br><span class="line">FILE *f = (FILE *)ATOM_LOAD(&amp;ctx-&gt;logfile);<span class="comment">//每个服务可以有自己专属的日志文件 这个有开关设置 注意这不同于skynet.error这种通用日志</span></span><br><span class="line"><span class="keyword">if</span> (f) &#123;</span><br><span class="line">skynet_log_output(f, msg-&gt;source, type, msg-&gt;session, msg-&gt;data, sz);</span><br><span class="line">&#125;</span><br><span class="line">++ctx-&gt;message_count;<span class="comment">//递增当前服务已经处理的消息个数</span></span><br><span class="line"><span class="type">int</span> reserve_msg;</span><br><span class="line"><span class="keyword">if</span> (ctx-&gt;profile) &#123;</span><br><span class="line">ctx-&gt;cpu_start = skynet_thread_time();</span><br><span class="line">reserve_msg = ctx-&gt;cb(ctx, ctx-&gt;cb_ud, type, msg-&gt;session, msg-&gt;source, msg-&gt;data, sz);<span class="comment">//调用ctx的cb处理</span></span><br><span class="line"><span class="type">uint64_t</span> cost_time = skynet_thread_time() - ctx-&gt;cpu_start;<span class="comment">//计算花费的时间</span></span><br><span class="line">ctx-&gt;cpu_cost += cost_time;<span class="comment">//记录CPU花费的时间</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">reserve_msg = ctx-&gt;cb(ctx, ctx-&gt;cb_ud, type, msg-&gt;session, msg-&gt;source, msg-&gt;data, sz);<span class="comment">//调用ctx的cb处理</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!reserve_msg) &#123;<span class="comment">//reserve_msg是 0 则释放内存</span></span><br><span class="line">skynet_free(msg-&gt;data);</span><br><span class="line">&#125;</span><br><span class="line">CHECKCALLING_END(ctx)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="snlua服务的回调函数"><a href="#snlua服务的回调函数" class="headerlink" title="snlua服务的回调函数"></a>snlua服务的回调函数</h3><p>对于snula服务来说 ，最终的回调函数是在lua层调用 <code>skynet.start</code> 时注册的</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">skynet.start</span><span class="params">(start_func)</span></span></span><br><span class="line">c.callback(skynet.dispatch_message) <span class="comment">-- 这里注册的回调函数</span></span><br><span class="line">init_thread = skynet.timeout(<span class="number">0</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span></span></span><br><span class="line">skynet.init_service(start_func)</span><br><span class="line">init_thread = <span class="literal">nil</span></span><br><span class="line"><span class="keyword">end</span>)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>查看 <code>c.callback(skynet.dispatch_message)</code> 回调函数的注册过程 <code>lcallback</code> </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">lcallback</span><span class="params">(lua_State *L)</span> &#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">skynet_context</span> * <span class="title">context</span> =</span> lua_touserdata(L, lua_upvalueindex(<span class="number">1</span>));</span><br><span class="line"><span class="type">int</span> forward = lua_toboolean(L, <span class="number">2</span>);</span><br><span class="line">luaL_checktype(L,<span class="number">1</span>,LUA_TFUNCTION);</span><br><span class="line">lua_settop(L,<span class="number">1</span>);</span><br><span class="line">lua_rawsetp(L, LUA_REGISTRYINDEX, _cb);<span class="comment">//相当于 注册表[_cb] = fun</span></span><br><span class="line"></span><br><span class="line">lua_rawgeti(L, LUA_REGISTRYINDEX, LUA_RIDX_MAINTHREAD);</span><br><span class="line">lua_State *gL = lua_tothread(L,<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (forward) &#123;</span><br><span class="line">skynet_callback(context, gL, forward_cb);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">skynet_callback(context, gL, _cb);<span class="comment">//lua服务注册回调函数 在回调函数里面会调用lua应用层的消息分发函数skynet.dispatch_message</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终的底层回调函数是 <code>_cb</code> </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line">_cb(<span class="keyword">struct</span> skynet_context * context, <span class="type">void</span> * ud, <span class="type">int</span> type, <span class="type">int</span> session, <span class="type">uint32_t</span> source, <span class="type">const</span> <span class="type">void</span> * msg, <span class="type">size_t</span> sz) &#123;</span><br><span class="line">lua_State *L = ud;<span class="comment">//这里是主协程</span></span><br><span class="line"><span class="type">int</span> trace = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> r;</span><br><span class="line"><span class="type">int</span> top = lua_gettop(L);</span><br><span class="line"><span class="keyword">if</span> (top == <span class="number">0</span>) &#123;</span><br><span class="line">lua_pushcfunction(L, traceback);</span><br><span class="line">lua_rawgetp(L, LUA_REGISTRYINDEX, _cb);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">assert(top == <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line">lua_pushvalue(L,<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">lua_pushinteger(L, type);</span><br><span class="line">lua_pushlightuserdata(L, (<span class="type">void</span> *)msg);</span><br><span class="line">lua_pushinteger(L,sz);</span><br><span class="line">lua_pushinteger(L, session);</span><br><span class="line">lua_pushinteger(L, source);</span><br><span class="line"></span><br><span class="line">r = lua_pcall(L, <span class="number">5</span>, <span class="number">0</span> , trace);<span class="comment">//调用lua层的skynet.dispatch_message 其参数是prototype, msg, sz, session, source</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (r == LUA_OK) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span> * self = skynet_command(context, <span class="string">&quot;REG&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">switch</span> (r) &#123;</span><br><span class="line"><span class="keyword">case</span> LUA_ERRRUN:</span><br><span class="line">skynet_error(context, <span class="string">&quot;lua call [%x to %s : %d msgsz = %d] error : &quot;</span> KRED <span class="string">&quot;%s&quot;</span> KNRM, source , self, session, sz, lua_tostring(L,<span class="number">-1</span>));</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> LUA_ERRMEM:</span><br><span class="line">skynet_error(context, <span class="string">&quot;lua memory error : [%x to %s : %d]&quot;</span>, source , self, session);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> LUA_ERRERR:</span><br><span class="line">skynet_error(context, <span class="string">&quot;lua error in error : [%x to %s : %d]&quot;</span>, source , self, session);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">lua_pop(L,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终的返回值是 0，表示lua层处理完后，底层会释放 msg指向的内存</p>]]></content>
      
      
      <categories>
          
          <category> skynet </category>
          
      </categories>
      
      
        <tags>
            
            <tag> skynet </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C_函数</title>
      <link href="/Language/C/C_%E5%87%BD%E6%95%B0"/>
      <url>/Language/C/C_%E5%87%BD%E6%95%B0</url>
      
        <content type="html"><![CDATA[<h1 id="C-函数"><a href="#C-函数" class="headerlink" title="C_函数"></a>C_函数</h1><p>函数是 C 语言的基本构建组件 (building blocks)，可以把一个大程序划分为小的组件，从而降低程序的复杂度。使用函数还可以避免编写重复的代码，从而提高程序的可维护性。</p><h2 id="函数的定义"><a href="#函数的定义" class="headerlink" title="函数的定义"></a>函数的定义</h2><p>在C语言中，函数的定义：</p><ol><li>返回类型：可以是基本数据类型，也可以是结构体、指针等复合数据类型。不能返回数组，除此之外，函数可以返回任意类型的值。如返回值类型为 <code>void</code>，则函数没有返回值。</li><li>函数名称：用于在程序中调用该函数。</li><li>参数列表：可以是零个或多个，需要在每个形式参数前面指定它的类型，并且参数之间用逗号分隔。如果函数没有形式参数，应该标明为 <code>void</code>。</li><li>函数体：包含声明和语句。在函数体内声明的变量只属于此函数，其它函数不能访问和修改这些变量。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">return-type function-name (parameters) </span><br><span class="line">&#123;</span><br><span class="line"> declarations</span><br><span class="line"> statements</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="函数调用"><a href="#函数调用" class="headerlink" title="函数调用"></a>函数调用</h2><p>函数调用由函数名和实际参数 (argument) 列表组成。如：<code>average(x, y)</code>。</p><p>非 <code>void</code> 函数调用会产生一个值，该值可以存储在变量中，用于测试、显示，或者是用于其它用途：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">avg = average(x, y);</span><br><span class="line"><span class="keyword">if</span> (average(x, y) &gt; <span class="number">0</span>)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Average is positive\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;The average is %lf\n&quot;</span>, average(x, y));</span><br></pre></td></tr></table></figure><p>如果不需要函数的返回值，则可以丢弃；返回值类型为 <code>void</code> 的函数没有返回值，且必须紧跟分号<code>;</code></p><h2 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a>函数声明</h2><p>如果把函数定义放在函数调用之后:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">double</span> x, y;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lf%lf&quot;</span>, &amp;x, &amp;y);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Average of %lf and %lf: %lf\n&quot;</span>, x, y, average(x, y)); </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">double</span> <span class="title function_">average</span><span class="params">(<span class="type">double</span> a, <span class="type">double</span> b)</span> </span><br><span class="line">&#123;<span class="keyword">return</span> (a + b) / <span class="number">2</span>; &#125;</span><br></pre></td></tr></table></figure><p>当编译器在 <code>main</code> 函数中遇到 <code>average</code> 函数调用时，没有 <code>average</code> 函数的信息。此时编译器会为 <code>average</code> 函数创建一个<strong>隐式声明</strong>：编译器会假定函数的返回值类型为 <code>int</code>。但不知道 <code>average</code> 的形参个数以及形参类型，编译器只能进行根据实际参数的类型和个数进行推断。当编译器后面遇到<code>average</code> 函数的定义时，发现函数的返回值类型是 <code>double</code> 而不是 <code>int</code>，从而会给出一条错误信息。</p><p>在调用之前声明函数。<strong>函数声明</strong>(function declaration) 使得编译器能够知道函数的概要信息。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span>-type function-name ( parameters );</span><br></pre></td></tr></table></figure><p><strong>函数的声明必须和函数的定义一致。</strong></p><p>函数声明中可以省略形参的名字，只要给定形参的类型即可。如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> <span class="title function_">average</span><span class="params">(<span class="type">double</span>, <span class="type">double</span>)</span>;</span><br></pre></td></tr></table></figure><h2 id="实际参数"><a href="#实际参数" class="headerlink" title="实际参数"></a>实际参数</h2><p>形式参数出现在函数定义中，表示在函数调用时应该提供哪些值；而实际参数出现在函数调用中。</p><p>实参是<strong>值传递</strong> (passed by value) 的。调用函数时，计算每个实参的值并赋值给相应的形参。在函数调用过程中，对形参的改变不会影响到实参的值，形参中保留的是实参的副本。</p><ul><li><p>形参的改变不会影响到实参，可以把形参当作变量来使用，减少所需变量的数量。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">power</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> n)</span> </span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">int</span> i, result = <span class="number">1</span>;</span><br><span class="line"> <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">     result = result * x;</span><br><span class="line"> <span class="keyword">return</span> result; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>n</code> 只是原始指数的副本，可以在函数体内修改它的值，不需要变量 <code>i</code> 了。</p></li></ul>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">power</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> n)</span> </span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">int</span> result = <span class="number">1</span>;</span><br><span class="line"> <span class="keyword">while</span> (n-- &gt; <span class="number">0</span>)</span><br><span class="line">     result = result * x;</span><br><span class="line"> <span class="keyword">return</span> result; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>变量 <code>a</code> 和变量 <code>b</code> 的值是不会发生修改的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">int</span> temp = a;</span><br><span class="line"> a = b;</span><br><span class="line"> b = temp; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="数组作为参数"><a href="#数组作为参数" class="headerlink" title="数组作为参数"></a>数组作为参数</h3><p>当形式参数为一维数组时，可以不指定数组的长度：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> a[])</span> &#123;</span><br><span class="line"> ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font color=#0099ff><strong>数组作为参数传递时，会退化成指向数组第一个元素的指针。</strong> </font></p><p>实参可以是元素类型匹配的任意一维数组。C 语言没有提供任何简便的方法供函数确定数组的长度。可以额外提供一个长度参数。</p><blockquote><p>虽然可以使用 <code>sizeof</code> 运算符计算数组的长度，但在这种情况下不适用。</p></blockquote><p>下面的函数说明了数组参数的常用用法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sum_array</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> n)</span> </span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">int</span> i, sum = <span class="number">0</span>;</span><br><span class="line"> <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">     sum += a[i];</span><br><span class="line"> <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数调用时，第一个参数是数组名，第二个参数是数组的长度。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> LEN 100</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> </span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">int</span> b[LEN], total;</span><br><span class="line"> ...</span><br><span class="line"> total = sum_array(b, LEN);</span><br><span class="line"> ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数是无法确认数组的实际长度的。可以传入一个比实际长度小的值：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">total = sum_array(b, <span class="number">50</span>);<span class="comment">//这就只会对数组的前 50 个元素求和。</span></span><br></pre></td></tr></table></figure><blockquote><p>注意：不能传入一个比数组长度更大的值，这会导致数组索引越界，从而发生未定义的行为。</p></blockquote><p>关于数组参数另一个值得注意的点是：<font color=#0099ff>函数通过传入的数组，可以改变数组的元素。</font></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">clear</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> n)</span> </span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">int</span> i;</span><br><span class="line"> <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">     a[i] = <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>数组的前 <code>n</code>个元素将会清零，因为<font color=#0099ff><strong>数组作为参数传递时，会退化成指向数组第一个元素的指针</strong></font>。</p><blockquote><p>注意!!!：形式参数是多维数组时，声明参数时只能省略第一个维度的长度。可以不指定行的数量，但是必须指定列的数量：</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> LEN 10                              </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sum_array</span><span class="params">(<span class="type">int</span> a[][LEN], <span class="type">int</span> n)</span></span><br><span class="line">&#123;        </span><br><span class="line"> <span class="type">int</span> i, j, sum = <span class="number">0</span>;</span><br><span class="line"> <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">     <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; LEN; j++)</span><br><span class="line">         sum += a[i][j];</span><br><span class="line"> <span class="keyword">return</span> sum; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>省略第一个维度时，表示函数可以接受任意行数的数组。如<code>arr[][4]</code>，可以接受 <code>int[2][4]</code> 、 <code>int[5][4]</code>  。</p></li><li><p>不省略第一个维度，表示函数明确指定了数组的行数，只能接受特定大小的数组。如 <code>arr[3][4]</code> ，必须接受一个 <code>3×4</code> 的二维数组。</p></li></ol><h2 id="局部变量全局变量"><a href="#局部变量全局变量" class="headerlink" title="局部变量全局变量"></a>局部变量全局变量</h2><p>在函数体内声明的变量称为该函数的<strong>局部变量</strong>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sum_digits</span><span class="params">(<span class="type">int</span> n)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;       <span class="comment">/*local variable*/</span></span><br><span class="line">    <span class="keyword">while</span> (n &gt; <span class="number">0</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        sum += n % <span class="number">10</span>;</span><br><span class="line">        n /= <span class="number">10</span>;</span><br><span class="line">   &#125;</span><br><span class="line">    <span class="keyword">return</span> sum; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>默认情况下，局部变量具有下列性质：</p><ol><li><strong>作用域（Scope）：</strong> 局部变量只在声明它们的函数或代码块内部可见和可用。超出范围，其它函数或代码块无法直接访问这些局部变量。块作用域通常与花括号 <code>&#123;&#125;</code> 内部的代码块相对应。</li><li><strong>生存期（Lifetime）：</strong> 局部变量的生命周期仅限于声明它们的函数或代码块的执行过程中。一旦函数或代码块执行结束，这些局部变量就会被销毁，释放其所占用的内存空间。</li><li><strong>不被默认初始化：</strong> 局部变量不会被默认初始化，它们的值是不确定的，除非显式地赋予初始值。在使用局部变量之前，必须先对其进行初始化操作，否则会导致未定义行为。</li><li><strong>隐藏性（Shadowing）：</strong> 当在内部作用域中声明一个与外部作用域同名的局部变量时，内部作用域的变量会隐藏外部作用域的同名变量。意味着在内部作用域中使用该变量时，实际上使用的是内部作用域的变量，而不是外部作用域的。</li><li><strong>栈上分配：</strong> 大多数编程语言中，局部变量通常在栈上分配内存。意味着内存分配和释放是自动进行的，无需程序员手动管理。</li></ol><h3 id="静态局部变量"><a href="#静态局部变量" class="headerlink" title="静态局部变量"></a>静态局部变量</h3><p>在局部变量声明中使用 <code>static</code> 关键字，可以使局部变量具有<strong>静态存储期限</strong>。</p><p>静态局部变量具有以下特点：</p><ol><li>具有静态存储期，生命周期与程序运行期间相同。</li><li>仅在第一次进入函数时被初始化，之后的调用不会重新初始化。</li><li>作用域仅限于声明它的函数内部，但在函数调用之间保持其值不变。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">foo</span><span class="params">(<span class="type">void</span>)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p: %d\n&quot;</span>, &amp;i, i++);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>静态局部变量始终具有块作用域，它对其它函数是不可见的。</p></blockquote><p>静态局部变量可以保存上一次函数调用时的状态，在某些应用中非常有用。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 0, 1, 1, 2, 3, 5, 8, 13, 21...</span></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> <span class="title function_">next_fib</span><span class="params">(<span class="type">void</span>)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">long</span> <span class="type">long</span> a = <span class="number">0</span>;<span class="comment">//仅在第一次进入函数时被初始化，之后的调用不会重新初始化。</span></span><br><span class="line">    <span class="type">static</span> <span class="type">long</span> <span class="type">long</span> b = <span class="number">1</span>;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> tmp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = a + tmp;</span><br><span class="line">    <span class="keyword">return</span> a; </span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, next_fib()); <span class="comment">// 1</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, next_fib()); <span class="comment">// 1</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, next_fib()); <span class="comment">// 2</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, next_fib()); <span class="comment">// 3</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h3><p>全局变量就是声明在任何函数体外的变量，全局变量的性质不同于局部变量：</p><ul><li><strong>静态存储期限</strong>。具有静态存储期限的变量拥有永久的存储单元，所以在整个程序执行期间都会保留变量的值。</li><li><strong>文件作用域</strong>。从变量声明开始，一直到文件的末尾。在全局变量声明之后的函数都可以访问(并修改)它。</li></ul><p>在多个函数必须共享一个变量时，全局变量是很有用的。但是函数之间通过形式参数进行通信会比共享外部变量更好。<font color=#0099ff><strong>使用全局变量不利于程序的排错和维护。</strong> </font></p><h2 id="return语句"><a href="#return语句" class="headerlink" title="return语句"></a>return语句</h2><p>非 <code>void</code> 函数必须使用 <code>return</code> 语句来指定函数要返回的值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> expr;</span><br></pre></td></tr></table></figure><p>如果 <code>return</code> 语句中表达式的类型和函数的返回值类型不匹配，系统将会把表达式的类型<code>隐式转换</code>为返回值类型。</p><p><code>void</code> 函数也可以使用 <code>return</code> 语句，使函数立刻返回，只是 <code>return</code> 后面不能接表达式。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">print_positive</span><span class="params">(<span class="type">int</span> n)</span> </span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">if</span> (n &lt;= <span class="number">0</span>)</span><br><span class="line">     <span class="keyword">return</span> ;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="程序终止"><a href="#程序终止" class="headerlink" title="程序终止"></a>程序终止</h2><p><code>main</code> 函数的返回值类型为 <code>int</code>，表示程序返回时的状态码。如果程序正常终止，<code>main</code> 函数应该返回 <code>0</code>；如果程序异常终止，应该返回非 <code>0</code> 的值。</p><h3 id="exit函数"><a href="#exit函数" class="headerlink" title="exit函数"></a><code>exit</code>函数</h3><p><code>exit</code>函数包含在 <code>&lt;stdlib.h&gt;</code> 头文件中。传递给<code>exit</code>函数的参数和 <code>main</code>函数的返回值具有相同的含义：两种都表示程序终止时的状态。</p><p>正常结束时：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>C 语言允许使用 <code>EXIT_SUCCESS</code> 来替代：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">exit</span>(EXIT_SUCCESS);</span><br></pre></td></tr></table></figure><p>如果异常退出：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">exit</span>(EXIT_FAILURE);</span><br></pre></td></tr></table></figure><p><code>EXIT_SUCCESS</code>和<code>EXIT_FAILURE</code>都是定义在 <code>&lt;stdlib.h&gt;</code> 中的宏，值是由实现决定的，通常分别为 <code>0</code> 和 <code>1</code>。</p><p><code>return</code>语句和<code>exit</code>函数之间的差异是：不管哪个函数调用<code>exit</code>函数都会导致程序终止，<code>return</code>语句<strong>仅当</strong>在<code>main</code>函数中执行时才会导致程序的终止。</p><blockquote><p>Tips: 一些程序员仅使用 exit 函数终止程序，好处是方便以后定位程序的全部退出点。</p></blockquote><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><p>一个函数调用它本身，那么这个函数就是递归的。</p><h3 id="递归使用"><a href="#递归使用" class="headerlink" title="递归使用"></a>递归使用</h3><ol><li>问题具有递归结构：<ul><li>大问题可以分解成若干个子问题，子问题的求解方式和大问题一致，只是问题规模不一致。</li><li>子问题的解可以合并成大问题的解。</li></ul></li><li>如果不存在重复计算问题，且递归的层次不是很深时，就可以使用递归。</li><li>写递归：边界条件、递归公式</li></ol><h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><p>动态规划是一种自底向上的方法，通过存储已解决的子问题的解来避免重复计算。</p><p>基本思想：</p><ul><li><strong>最优子结构：</strong> 原问题的最优解可以通过其子问题的最优解来构建。</li><li><strong>重叠子问题：</strong> 在解决问题的过程中，需要解决相同的子问题多次。</li></ul><p>动态规划的解决步骤：</p><ol><li><strong>定义子问题：</strong> 确定问题的最优子结构，以及问题可以被分解成的子问题。</li><li><strong>建立状态转移方程：</strong> 找到子问题之间的关系，建立递推式或状态转移方程。</li><li><strong>确定边界条件：</strong> 确定递归或迭代过程中的边界条件，即最小的子问题的解。</li><li><strong>自底向上求解：</strong> 使用迭代或递归方法自底向上求解问题，确保每个子问题的解只计算一次，并且以正确的顺序计算。</li></ol><p>动态规划的特性：</p><ul><li><strong>记忆化搜索：</strong> 使用数组或哈希表等数据结构来存储已解决的子问题的解，以避免重复计算。</li><li><strong>状态压缩：</strong> 在某些情况下，可以通过仅保留必要的状态信息来减少存储空间。</li></ul><p>使用场景：</p><ol><li><strong>优化问题：</strong> 动态规划通常用于解决优化问题，例如找到最大值、最小值或最优解。</li><li><strong>最短路径问题：</strong> 诸如最短路径或最短编辑距离之类的问题通常可以使用动态规划来解决。</li><li><strong>组合优化问题：</strong> 动态规划可用于解决组合优化问题，如子集求和、子序列最大值等。</li><li><strong>资源分配问题：</strong> 例如背包问题是动态规划经常用于解决的资源分配问题的一个示例。</li><li><strong>排列组合问题：</strong> 当需要考虑元素之间的排列和组合时，动态规划可能是一个合适的选择。</li><li><strong>树或图问题：</strong> 某些树形和图形问题可以使用动态规划来解决，例如最长递增子序列等。</li></ol><p>使用条件：</p><ol><li><strong>重叠子问题：</strong> 原问题可以被分解成若干个规模较小的子问题，并且这些子问题之间存在重叠，即相同的子问题可能被多次求解。</li><li><strong>最优子结构：</strong> 问题的最优解可以通过子问题的最优解来求解。换句话说，问题的最优解可以通过子问题的最优解进行组合而得到。</li><li><strong>状态转移方程：</strong> 存在一个状态转移方程，用于描述如何从一个阶段的状态转移到下一个阶段的状态。这是动态规划问题的核心。</li><li><strong>问题可分解：</strong> 原始问题可以被分解成几个子问题，这些子问题相对较小，可以被有效地求解。</li><li><strong>问题具有确定性：</strong> 问题的状态和转移是可确定的，不存在随机因素或不确定性。</li></ol><p>注意事项：</p><ul><li><strong>状态定义：</strong> 状态的定义对问题的解决方案至关重要，需要仔细考虑问题的本质。</li><li><strong>状态转移方程：</strong> 建立正确的状态转移方程是解决动态规划问题的关键，需要深入理解问题的结构和特性。</li></ul><h3 id="Fibonacci数列"><a href="#Fibonacci数列" class="headerlink" title="Fibonacci数列"></a><code>Fibonacci</code>数列</h3><p>具体函数：<code>F(n)=F(n-2)+F(n-1)</code>，<code>F(1)=1</code>，<code>F(0)=0</code></p><p>利用公式求解：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 0, 1, 1, 2</span></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> <span class="title function_">fib</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span> || n == <span class="number">1</span>) <span class="keyword">return</span> n;</span><br><span class="line">    <span class="keyword">return</span> fib(n<span class="number">-2</span>) + fib(n<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种求解方式的效率很低，会存在大量重复的计算。</p><p>动态规划：并不需要保存前面所有项的值，只需要保存最近两项即可。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="type">long</span> <span class="title function_">fib</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span> || n == <span class="number">1</span>) <span class="keyword">return</span> n;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> a = <span class="number">0</span>, b = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;<span class="comment">// 计算fib(i)的值</span></span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> tmp = a + b;</span><br><span class="line">        a = b;</span><br><span class="line">        b = tmp;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C_历史</title>
      <link href="/Language/C/C_%E5%8E%86%E5%8F%B2"/>
      <url>/Language/C/C_%E5%8E%86%E5%8F%B2</url>
      
        <content type="html"><![CDATA[<h1 id="C-历史"><a href="#C-历史" class="headerlink" title="C_历史"></a>C_历史</h1><h2 id="C语言的起源"><a href="#C语言的起源" class="headerlink" title="C语言的起源"></a>C语言的起源</h2><p>C 语言是贝尔实验室的Ken Thompson、  Dennis Ritchie等人开发的UNIX 操作系统的  “副产品”。Thompson独自编写出了最初版本的 UNIX 操作系统，这套系统运行在只有 16KB内存的 DEC PDP -7计算机上。</p><p>UNIX系统最初是用汇编语言编写的，用汇编语言编写的程序往往难以调试和扩展。   Thompson意识到需要用一种更加高级的编程语言来完成 UNIX 系统未来的开发，于是 他设计了一种小型语言—— B语言。  B语言是在BCPL语言(20世纪60年代中期产生的一 种系统编程语言)的基础上开发的，而BCPL语言又可以追溯到最早的语言之一 ——   Algol 60。</p><p>不久，  Ritchie也加入到UNIX项目中，并且开始着手用B语言编写程序。  1970年，贝尔 实验室为UNIX项目争取到一台PDP -11计算机。当B语言经过改进并能够在PDP -11计 算机上运行后， Thompson用B语言重新编写了部分UNIX代码。到了1971年，  B语言已 经明显不适合PDP -11计算机了，于是Ritchie着手开发B语言的升级版。最初，他将新 开发的语言命名为NB语言(意为“New B”)，但是后来新语言越来越偏离B语言，于是  他将其改名为C语言。</p><p>到了1973年，  C语言已经足够稳定，  可以用来重新编写UNIX系统了。改用C语言编写 程序有一个非常重要的好处：可移植性。只要为其它计算机编写C语言编译器，  UNIX系统就能运行在那些机器上。</p><p>特性：</p><ol><li>能直接和硬件打交道</li><li>C语言追求最高的运行时效率：a.不会检查数组是否越界 b.没有异常机制</li><li>和汇编语言有很强的对应关系。</li></ol>]]></content>
      
      
      <categories>
          
          <category> C </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C_基本数据类型</title>
      <link href="/Language/C/C_%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"/>
      <url>/Language/C/C_%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B</url>
      
        <content type="html"><![CDATA[<h1 id="C-基本数据类型"><a href="#C-基本数据类型" class="headerlink" title="C_基本数据类型"></a>C_基本数据类型</h1><p>基本数据类型主要包括：<strong>整数类型</strong>，<strong>浮点数类型</strong>和<strong>字符类型</strong>，其中字符类型也可以看作是整数类型中的一种。</p><h2 id="整数类型"><a href="#整数类型" class="headerlink" title="整数类型"></a>整数类型</h2><p>整数类型可以分为两大类：<strong>有符号整数</strong>和<strong>无符号整数</strong>。</p><p>默认情况下，C 语言的整数类型都是有符号的；若要声明为无符号整数，则需要加 <code>unsigned</code> 关键字。C 语言的整数类型有以下这些：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">short</span> (<span class="type">int</span>)</span><br><span class="line"><span class="type">unsigned</span> <span class="title function_">short</span> <span class="params">(<span class="type">int</span>)</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">unsigned</span> <span class="params">(<span class="type">int</span>)</span>  </span><br><span class="line"><span class="title function_">long</span> <span class="params">(<span class="type">int</span>)</span></span><br><span class="line"><span class="type">unsigned</span> <span class="title function_">long</span> <span class="params">(<span class="type">int</span>)</span></span><br><span class="line"><span class="type">long</span> <span class="title function_">long</span> <span class="params">(<span class="type">int</span>)</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="title function_">long</span> <span class="params">(<span class="type">int</span>)</span></span><br></pre></td></tr></table></figure><p><font color=#0099ff><strong>C</strong> <strong>语言整数类型的取值范围根据机器的不同而不同。</strong></font>但是编译器都必须遵循的原则：</p><ol><li><p>C 标准规定了 short(2), int(2), long(4), long long(8) 的最小字节长度。</p></li><li><p>C 标准规定了各个整数类型的字节长度满足下面的关系：</p><blockquote><p>short &lt;&#x3D; int &lt;&#x3D; long &lt;&#x3D; long long</p></blockquote></li></ol><p>下表是64 位机器上整数类型的常见取值范围：</p><table><thead><tr><th align="center">类型</th><th align="center">字节长度</th><th align="center">最小值</th><th align="center">最大值</th></tr></thead><tbody><tr><td align="center">short</td><td align="center">2</td><td align="center">-32768</td><td align="center">32767</td></tr><tr><td align="center">unsigned short</td><td align="center">2</td><td align="center">0</td><td align="center">65535</td></tr><tr><td align="center">int</td><td align="center">4</td><td align="center">-2147483 648</td><td align="center">2147483647</td></tr><tr><td align="center">unsigned int</td><td align="center">4</td><td align="center">0</td><td align="center">4294967295</td></tr><tr><td align="center">long</td><td align="center">8</td><td align="center">-9223372036854775808</td><td align="center">9223372036854775807</td></tr><tr><td align="center">unsigned long</td><td align="center">8</td><td align="center">0</td><td align="center">18446744073709551615</td></tr><tr><td align="center">long long</td><td align="center">8</td><td align="center">-9223372036854775808</td><td align="center">9223372036854775807</td></tr><tr><td align="center">unsigned long long</td><td align="center">8</td><td align="center">0</td><td align="center">18446744073709551615</td></tr></tbody></table><h3 id="整数字面值"><a href="#整数字面值" class="headerlink" title="整数字面值"></a>整数字面值</h3><p>C 语言允许使用十进制 (decimal)，八进制 (octal) 或者十六进制 (hexadecimal) 来书写整数字面值。</p><ul><li><p>十进制字面值包含数字 0~9，但是<strong>不能</strong>以 <code>0</code> 开头。如：15, 255, 32767</p></li><li><p>八进制字面值包含数字 0~7，而且<strong>必须</strong>以 <code>0</code> 开头。如：017, 0377, 077777。</p></li><li><p>十六进制字面值包含数字 0<del>9 和字母 a</del>f，而且总以 <code>0x</code> 开头。如：0xf, 0xff, 0x7ff。</p><p>十六进制字面值中的字母即可以是大写也可以是小写，如：0xff, 0xfF, 0xFF, 0Xff, 0XfF, 0XFF。</p></li></ul><p><font color=#0099ff><strong>注意：整数字面值也是有类型的</strong></font></p><p>十进制整数字面值的类型通常是<code>int</code>，但如果该字面值超出了<code>int</code>的表示范围，那么它的类型是 <code>int</code>, <code>long</code> 和 <code>long long</code> 中能表示该值的 “最小” 类型。</p><p>对八进制和十六进制整数字面值来说，可能的类型顺序为：<code>int</code>, <code>unsigned int</code> ，<code>long, unsigned long</code>, <code>long long</code> 和 <code>unsigned long long</code>。</p><p>要指明某个整数字面值为一个 long 类型，需要在后面加字母 L (或 l)：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">15L</span>, <span class="number">0377L</span>, <span class="number">0x7fff</span>L</span><br></pre></td></tr></table></figure><p>要指明整数字面值是 long long 类型，需要在后面加 LL (或 ll)：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">15LL</span>, <span class="number">0377LL</span>, <span class="number">0x7fff</span>LL</span><br></pre></td></tr></table></figure><p>要指明整数常量是无符号的，需要在后面加字母 U (或 u)： </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">15U</span>, <span class="number">0377U</span>, <span class="number">0x7fff</span>U</span><br></pre></td></tr></table></figure><p>L、LL还可以和 U 结合使用，且字母 L, LL 和 U 的顺序可以颠倒。如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0xffffffff</span>UL, <span class="number">0x12345678</span>ULL</span><br></pre></td></tr></table></figure><h3 id="读-写整数"><a href="#读-写整数" class="headerlink" title="读&#x2F;写整数"></a>读&#x2F;写整数</h3><p>使用 <code>scanf</code> 和 <code>printf</code> 函数读写无符号整数、短整数和长整数，则需要其它的转换说明符。(<code>%d </code>只适用于读写 <code>int</code> 类型的数据。)</p><ul><li><p>读写 <code>unsigned int</code> 时，使用字母 <code>u</code>, <code>o</code> 或 <code>x</code> 替代<strong>转换说明符</strong>中的 <code>d</code>。其中 <code>u</code> 表明无符号整数是十进制形式；<code>o</code> 表明无符号整数是八进制形式；<code>x</code>表明是十六进制形式。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> n;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%u&quot;</span>, &amp;n); <span class="comment">/* reads n in base 10 */</span> </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%u&quot;</span>, n); <span class="comment">/* writes n in base 10 */</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%o&quot;</span>, &amp;n); <span class="comment">/* reads n in base 8 */</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%o&quot;</span>, n); <span class="comment">/* writes n in base 8 */</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%x&quot;</span>, &amp;n); <span class="comment">/* reads n in base 16 */</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%x&quot;</span>, n); <span class="comment">/* writes n in base 16 */</span></span><br></pre></td></tr></table></figure></li><li><p>读写 <code>short</code> 时，在 <code>d</code>, <code>u</code>, <code>o</code> 或着 <code>x</code> 前面加字母 <code>h</code> (s<strong>h</strong>ort)：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">short</span> n;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%hd&quot;</span>, &amp;n);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%hd&quot;</span>, n);</span><br></pre></td></tr></table></figure></li><li><p>读写 <code>long</code> 时，在<code>d</code>, <code>u</code>, <code>o</code> 或者 <code>x</code> 前面加字母 <code>l</code> (<strong>l</strong>ong)：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> n;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%ld&quot;</span>, &amp;n);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%ld&quot;</span>, n);</span><br></pre></td></tr></table></figure></li><li><p>读写 <code>long long</code> 时，在 <code>d</code>, <code>u</code>, <code>o</code> 或者 <code>x</code> 前面加字母 <code>ll</code> (<strong>l</strong>ong<strong>l</strong>ong)： </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="type">long</span> n;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;n);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>, n);</span><br></pre></td></tr></table></figure></li></ul><h3 id="整数类型编码"><a href="#整数类型编码" class="headerlink" title="整数类型编码"></a>整数类型编码</h3><p>无符号整数和有符号整数的编码是不一样的。</p><p><strong>无符号整数的编码</strong>：无符号整数采用二进制编码，只需要将二进制转换成十进制。</p><p><strong>有符号整数的编码</strong>：有符号整数的编码方式为<strong>补码</strong>。利用加法器做运算时候更方便。</p><h2 id="浮点数类型"><a href="#浮点数类型" class="headerlink" title="浮点数类型"></a>浮点数类型</h2><p>C 语言提供了三种浮点数类型，对应三种不同的浮点数格式：</p><ul><li>float</li><li>double</li><li>long double</li></ul><p>当对精度要求不高时 (一位小数的运算)，可以使用 <code>float</code> 类型；大多数情况下，会使用 <code>double</code> 类型；在极少数对精度要求非常高的情况下，才会使用 <code>long double</code>。</p><p>C 语言标准并没有规定 <code>float</code>, <code>double</code>, <code>long double</code> 类型精度,但大多数计算机都遵循 IEEE 754标准 。<code>long double</code> 类型没有显示在此表中，最常见的是 80 位和 128 位。</p><p>下表展示了遵循 IEEE 标准的浮点数的特征：</p><table><thead><tr><th align="center">类型</th><th align="center">规范化的最小正值</th><th align="center">最大值</th><th align="center">精度</th></tr></thead><tbody><tr><td align="center">float</td><td align="center">1.175 49 x 10^-38</td><td align="center">3.402 82 x 10^38</td><td align="center">6位数字</td></tr><tr><td align="center">double</td><td align="center">2.225 07 x 10^-308</td><td align="center">1.797 69 x 10^308</td><td align="center">15位数字</td></tr></tbody></table><h3 id="浮点数字面值"><a href="#浮点数字面值" class="headerlink" title="浮点数字面值"></a>浮点数字面值</h3><p>浮点数常量有多种书写方式。例如，下面都是 <code>57.0</code> 的有效表示方式：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">57.0</span>  <span class="number">57.</span>  <span class="number">57.0e0</span>  <span class="number">57E0</span>  <span class="number">5.7e1</span>  <span class="number">5.7e+1</span> <span class="number">.57e2</span>  <span class="number">570.e-1</span></span><br></pre></td></tr></table></figure><p>浮点数必须包含小数点或者是指数；字母 E (或 e) 后面的数字表示以 10 为底的指数。</p><p>默认情况下，浮点常量是 <code>double</code> 类型。单精度方式存储可以在末尾加字母 <code>F</code> 或 <code>f</code>，如 <code>57.0F</code> 。以 <code>long double</code> 方式存储，则在后面加 <code>L</code> 或 <code>l</code>，如 <code>57.0L</code> 。 </p><h3 id="读-写浮点数"><a href="#读-写浮点数" class="headerlink" title="读&#x2F;写浮点数"></a>读&#x2F;写浮点数</h3><p>读写 <code>double</code>和 <code>long double</code> 类型所需的说明符与 float 略有不同。</p><ul><li><p>读写 <code>float</code> 类型的值时：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> d;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%f&quot;</span>, &amp;d);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%f&quot;</span>, d);</span><br></pre></td></tr></table></figure></li><li><p>读写 <code>double</code> 类型的值时，需要在 <code>f</code> 前面添加字母 <code>l</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> d;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%lf&quot;</span>, &amp;d);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%lf&quot;</span>, d);</span><br></pre></td></tr></table></figure></li><li><p>读写 <code>long double</code> 类型的值时，需要在 <code>f</code> 前面添加字母 <code>L</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="type">double</span> ld;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%Lf&quot;</span>, &amp;ld);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%Lf&quot;</span>, ld);</span><br></pre></td></tr></table></figure></li></ul><h2 id="字符类型"><a href="#字符类型" class="headerlink" title="字符类型"></a>字符类型</h2><p>不同的机器可能使用不同的字符集，char类型的值可能不同。<strong>ASCII</strong>(American Standard Code for Information Interchange) 字符集使用 7 位来表示 128 个字符，如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/Barbecue-g/imagehost/Language/C/C_%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/ASCII.png" alt="ASCII"></p><blockquote><p>需要记住的：<code>&#39; &#39;</code> &#x3D; 32, <code>&#39;0&#39;</code> &#x3D; 48, <code>&#39;A&#39;</code> &#x3D; 65, <code>&#39;a&#39;</code> &#x3D; 97。</p></blockquote><p>char 类型的变量可以存储单个字符，注意：字符字面值应该用单引号括起来。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> ch;</span><br><span class="line">ch = <span class="string">&#x27;a&#x27;</span>; </span><br><span class="line">ch = <span class="string">&#x27;A&#x27;</span>; </span><br><span class="line">ch = <span class="string">&#x27;0&#x27;</span>; </span><br><span class="line">ch = <span class="string">&#x27; &#x27;</span>;</span><br></pre></td></tr></table></figure><h3 id="字符操作"><a href="#字符操作" class="headerlink" title="字符操作"></a>字符操作</h3><p><font color=#0099ff><strong>C</strong> <strong>语言是把字符当作小的整数进行处理的</strong></font>。C 语言会使用字符对应的整数值，如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> ch;</span><br><span class="line"><span class="type">int</span> i; </span><br><span class="line"></span><br><span class="line">i = <span class="string">&#x27;a&#x27;</span>; <span class="comment">/* i is now 97 */</span></span><br><span class="line">ch = <span class="number">65</span>; <span class="comment">/* ch is now &#x27;A&#x27; */</span></span><br><span class="line">ch = ch + <span class="number">1</span>; <span class="comment">/* ch is now &#x27;B&#x27; */</span></span><br><span class="line">ch++; <span class="comment">/* ch is now &#x27;C&#x27; */</span></span><br></pre></td></tr></table></figure><p>下面的代码可以把小写字母变成大写字母：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 不推荐。toupper()，tolower()更好，在&lt;ctype.h&gt;头文件中*/</span></span><br><span class="line"><span class="keyword">if</span> (ch &gt;= <span class="string">&#x27;a&#x27;</span> &amp;&amp; ch &lt;= <span class="string">&#x27;z&#x27;</span>)</span><br><span class="line">    ch = ch - <span class="string">&#x27;a&#x27;</span> + <span class="string">&#x27;A&#x27;</span>;</span><br></pre></td></tr></table></figure><p>下面使用 for 循环遍历所有的大写字母：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (ch = <span class="string">&#x27;A&#x27;</span>; ch &lt;= <span class="string">&#x27;Z&#x27;</span>; ch++) ...</span><br></pre></td></tr></table></figure><p>把字符当作整数来处理，但也可以导致写出无意义的表达式：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;a&#x27;</span> * <span class="string">&#x27;b&#x27;</span> / <span class="string">&#x27;c&#x27;</span>;   <span class="comment">/* 不要这么做 */</span></span><br></pre></td></tr></table></figure><h3 id="转义字符"><a href="#转义字符" class="headerlink" title="转义字符"></a>转义字符</h3><p>转义序列分为两种：字符转义序列和数字转义序列。下表给出了字符转义序列的完整集合：</p><table><thead><tr><th align="center"><strong>Name</strong></th><th align="center"><strong>Escape Sequence</strong></th><th align="center"><strong>Name</strong></th><th align="center"><strong>Escape Sequence</strong></th></tr></thead><tbody><tr><td align="center">Alert (bell)</td><td align="center">\a</td><td align="center">Vertical tab</td><td align="center">\v</td></tr><tr><td align="center">Backspace</td><td align="center">\b</td><td align="center">Backslash</td><td align="center">\</td></tr><tr><td align="center">Form feed</td><td align="center">\f</td><td align="center">Question mark</td><td align="center">?</td></tr><tr><td align="center">New line</td><td align="center">\n</td><td align="center">Single quote</td><td align="center">&#39;</td></tr><tr><td align="center">Carriage return</td><td align="center">\r</td><td align="center">Double quote</td><td align="center">&quot;</td></tr><tr><td align="center">Horizontal tab</td><td align="center">\t</td><td align="center"></td><td align="center"></td></tr></tbody></table><p>字符转义序列：没有包含所有的不可打印的 ASCII 字符，而且它也不能表示 ASCII 以外的字符。</p><p>数字转义序列：可以表示任意一个字符。可以使用<code>八进制</code>或者<code>十六进制</code>来书写数字转义序列。</p><ul><li><p><strong>八进制转义序列</strong>：由 <code>\</code> 和一个<code>最多 3 位</code>的八进制数字组成。例如 <code>ESC</code> 的编码为<code>27</code>，用八进制表示就是 <code>33</code>，因此 <code>ESC</code> 可以表示成<code>\33</code>或者<code>\033</code>。</p><blockquote><p>转义字符中的八进制数不需要以<code>0</code>开头，但八进制整数需要。</p></blockquote></li><li><p><strong>十六进制转义序列</strong>：由 <code>\x</code> 和十六进制数组成。例如<code>ESC</code>的编码为<code>27</code>，用十六进制表示就是<code>1b</code>，因此 <code>ESC</code>字符可以写成<code>\x1b</code>或<code>\x1B</code>的形式。</p><blockquote><p>转义字符中的十六进制数需要以<code>x</code>开头，且<code>x</code>必须小写，但是后面的十六进制数字不限大小写。</p></blockquote></li></ul><blockquote><p>当转义序列作为字符常量使用时，必须用一对单引号括起来。比如：<code>&#39;\n&#39;</code>, <code>&#39;\33&#39;</code>或<code>&#39;\x1B&#39;</code>。 </p></blockquote><h3 id="空白字符"><a href="#空白字符" class="headerlink" title="空白字符"></a>空白字符</h3><p>空白字符是指在文本中不可见的字符，空白字符不会在屏幕上显示，但可以影响文本的布局和解释。</p><p>空白字符的说明：</p><ul><li>空格符（<code> </code>）：用于在文本中分隔单词或语句。</li><li>制表符（<code>\t</code>）：用于在文本中垂直方向上对齐文本或者在代码中用来缩进。</li><li>换行符（<code>\n</code>）：表示文本中的换行，将光标移动到下一行开头。</li><li>回车符（<code>\r</code>）：在某些操作系统中用来表示换行，用来实现回车换行的效果。</li><li>垂直制表符（<code>\v</code>）：在某些系统中，用于在文本中垂直方向上对齐文本。</li><li>换页符（<code>\f</code>）：在打印输出中用于分页，通常在控制台输出中不常见。</li></ul><h3 id="字符处理函数"><a href="#字符处理函数" class="headerlink" title="字符处理函数"></a>字符处理函数</h3><p>头文件 <code>&lt;ctype.h&gt;</code> 中声明了许多字符处理函数，主要分为两大类：字符分类函数和大小写转换函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 字符分类函数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">isalnum</span><span class="params">(<span class="type">int</span> c)</span>; <span class="comment">/* Is c alphanumeric? */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">isalpha</span><span class="params">(<span class="type">int</span> c)</span>; <span class="comment">/* Is c alphabetic? */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">isblank</span><span class="params">(<span class="type">int</span> c)</span>; <span class="comment">/* Is c a blank? i.e. &#x27; &#x27; or &#x27;\t&#x27; */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">iscntrl</span><span class="params">(<span class="type">int</span> c)</span>; <span class="comment">/* Is c a control character? */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">isdigit</span><span class="params">(<span class="type">int</span> c)</span>; <span class="comment">/* Is c a decimal digit? */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">isgraph</span><span class="params">(<span class="type">int</span> c)</span>; <span class="comment">/* Is c a printing character (other than a space)? */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">islower</span><span class="params">(<span class="type">int</span> c)</span>; <span class="comment">/* Is c a lower-case letter? */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">isprint</span><span class="params">(<span class="type">int</span> c)</span>; <span class="comment">/* Is c a printing character (including a space)? */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">ispunct</span><span class="params">(<span class="type">int</span> c)</span>; <span class="comment">/* Is c punctuation? */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">isspace</span><span class="params">(<span class="type">int</span> c)</span>; <span class="comment">/* Is c a white-space character? */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">isupper</span><span class="params">(<span class="type">int</span> c)</span>; <span class="comment">/* Is c an upper-case letter? */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">isxdigit</span><span class="params">(<span class="type">int</span> c)</span>; <span class="comment">/* Is c a hexadecimal digit? */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">tolower</span><span class="params">(<span class="type">int</span> c)</span>;<span class="comment">// 大小写转换函数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">toupper</span><span class="params">(<span class="type">int</span> c)</span>;<span class="comment">// 大小写转换函数</span></span><br></pre></td></tr></table></figure><h3 id="读-写字符"><a href="#读-写字符" class="headerlink" title="读&#x2F;写字符"></a>读&#x2F;写字符</h3><h4 id="scanf-和-printf-读-写字符"><a href="#scanf-和-printf-读-写字符" class="headerlink" title="scanf 和 printf 读&#x2F;写字符"></a><code>scanf</code> 和 <code>printf</code> 读&#x2F;写字符</h4><p><code>scanf</code> 和 <code>printf</code> 可以使用转换说明符 %c 对单个字符进行读写操作：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> ch;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>, &amp;ch); <span class="comment">/* reads a single character */</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, ch); <span class="comment">/* writes a single character */</span></span><br></pre></td></tr></table></figure><p><code>scanf</code> 函数在读字符时，不会跳过前面的空白字符。需要跳过前面的空白字符，则要在转换说明符 <code>%c</code> 前面加一个空格:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot; %c&quot;</span>, &amp;ch); <span class="comment">/* skip white-space characters, then reads ch */</span></span><br></pre></td></tr></table></figure><blockquote><p><code>scanf</code> 格式串中的空格意味着”跳过”零个或着多个空白字符。</p></blockquote><h4 id="getchar-和-putchar-读-写字符"><a href="#getchar-和-putchar-读-写字符" class="headerlink" title="getchar 和 putchar 读&#x2F;写字符"></a><code>getchar</code> 和 <code>putchar</code> 读&#x2F;写字符</h4><p><code>getchar</code> 用于读单个字符：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">getchar</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure><p>从 <code>stdin</code> 中读入一个字符，并且把读入的字符返回。读到文件的末尾，或者在读的过程中发生错误，返回 <code>EOF</code>。</p><p><code>putchar</code> 用于写单个字符：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">putchar</span><span class="params">(<span class="type">int</span> c)</span>;</span><br></pre></td></tr></table></figure><p>向标准输出 <code>stdout</code> 写入一个字符。写入成功，则返回写入的字符，否则返回 <code>EOF</code>。</p><blockquote><p><code>putchar</code> 和 <code>getchar</code> 函数的执行效率要高于 <code>printf</code> 和 <code>scanf</code>。</p></blockquote><p>getchar 函数常用于一些惯用法中。如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (getchar() != <span class="string">&#x27;\n&#x27;</span>) <span class="comment">/* skips rest of line */</span></span><br><span class="line"> ;</span><br></pre></td></tr></table></figure><h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><p>C 语言则允许在表达式中混合使用基本类型，表达式中可以组合整数、浮点数甚至是字符。C 编译器生成指令将某些操作数转换成其它类型的数据，使得硬件可以对表达式进行求值。</p><p>类型转换分为两种：<strong>隐式转换</strong>和<strong>显式转换</strong></p><p><font color=#0099ff>发生下列情况时，C 语言会进行<strong>隐式转换</strong></font>：</p><ul><li><p>当算术表达式或逻辑表达式中操作数的类型不相同时。</p></li><li><p>当赋值运算符右侧表达式的类型和左侧变量的类型不匹配时。</p></li><li><p>当函数调用中的实参类型和其对应的行参类型不匹配时。</p></li><li><p>当 return 语句中表达式的类型和函数返回值的类型不匹配时</p></li></ul><blockquote><p>注意：尽量减少或禁止隐式转换，当给定的类型与需要的类型不同时，就可能发生隐式转换。</p></blockquote><h3 id="常用算术转换"><a href="#常用算术转换" class="headerlink" title="常用算术转换"></a>常用算术转换</h3><p>C99 给每个整数类型都定义了”整数转换等级”，从高到低依次为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(1) long long int, unsigned long long int</span><br><span class="line">(2) long int, unsigned long int</span><br><span class="line">(3) int, unsigned int</span><br><span class="line">(4) short int, unsigned short int</span><br><span class="line">(5) char, signed char, unsigned char</span><br></pre></td></tr></table></figure><p>C 语言常用算术转换：</p><ol><li><p><strong>整数提升</strong>：操作数中有任何低于 <code>int</code> 和 <code>unsigned int</code> 的类型，会首先将该操作数转换为 <code>int</code>类型或者 <code>unsigned int</code> 类型。</p></li><li><pre><code>int -&gt; long -&gt; long long -&gt; float -&gt; double -&gt; long double<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">3. **同一转换等级**的有符号整数和无符号整数一起参与运算时：有符号整数会转换成对应的无符号整数。</span><br><span class="line"></span><br></pre></td></tr></table></figure>signed -&gt; unsigned<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   最好尽量避免使用无符号整数，特别是不要把它和有符号整数混合使用。(无符号整数一般用于底层开发中，在应用层面很少会使用)。</span><br><span class="line"></span><br><span class="line">### 赋值过程中的转换</span><br><span class="line"></span><br><span class="line">**赋值运算规则**：把赋值运算右边的表达式转换为左边变量的类型。</span><br><span class="line"></span><br><span class="line">当变量的类型至少和表达式类型一样&quot;宽&quot;，转换是没有任何问题的。</span><br><span class="line"></span><br><span class="line">```c</span><br><span class="line">char c;int i;float f;double d;</span><br><span class="line">i = c;f = i;d = f;</span><br></pre></td></tr></table></figure></code></pre></li></ol><p>把浮点数赋值给整型变量会丢失小数部分：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i;</span><br><span class="line">i = <span class="number">842.97</span>; <span class="comment">/* i is now 842 */</span></span><br><span class="line">i = <span class="number">-842.97</span>; <span class="comment">/* i is now -842 */</span></span><br></pre></td></tr></table></figure><p>值在变量类型的表示范围之外，将会得到无意义的结果 (甚至更糟)：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> c;<span class="type">int</span> i;<span class="type">float</span> f;</span><br><span class="line">c = <span class="number">10000</span>; <span class="comment">/* WRONG */</span></span><br><span class="line">i = <span class="number">1.0e20</span>; <span class="comment">/* WRONG */</span></span><br><span class="line">f = <span class="number">1.0e100</span>; <span class="comment">/* WRONG */</span></span><br></pre></td></tr></table></figure><p>将浮点常量赋值给 <code>float</code> 类型变量时，可以在常量后面加字符 <code>f</code>，如：<code>f = 3.14f </code>。如果没有后缀 <code>f</code>，常量 3.14 是 <code>double</code> 类型，会引发<code>隐式转换</code>。(尽量减少或禁止隐式转换)</p><h3 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h3><p>强制类型转换的格式如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(type-name) expression</span><br></pre></td></tr></table></figure><p>C 语言把 (type_name) 看作是一元运算符，一元运算符的优先级是高于二元运算符。</p><ul><li><p>使用强制类型转换计算浮点数的小数部分：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> f, frac_part;</span><br><span class="line">frac_part = f - (<span class="type">int</span>) f;</span><br></pre></td></tr></table></figure></li><li><p>使用强制类型转换显示表明肯定会发生的转换：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">i = (<span class="type">int</span>) f;</span><br></pre></td></tr></table></figure></li><li><p>使用强制类型转换进行需要的类型转换：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> quotient;</span><br><span class="line"><span class="type">int</span> dividend, divisor;</span><br><span class="line">quotient = dividend / divisor;</span><br><span class="line">quotient = (<span class="type">float</span>) dividend / divisor;</span><br></pre></td></tr></table></figure></li><li><p>使用强制类型转换来避免溢出：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> i;</span><br><span class="line"><span class="type">int</span> j = <span class="number">1000</span>; </span><br><span class="line">i = j * j; <span class="comment">/* overflow may occur */</span></span><br><span class="line">i = (<span class="type">long</span>) (j * j); <span class="comment">/* overflow may occur */</span></span><br><span class="line">i = (<span class="type">long</span>) j * j;</span><br></pre></td></tr></table></figure></li></ul><h2 id="定义别名"><a href="#定义别名" class="headerlink" title="定义别名"></a>定义别名</h2><p>使用 typedef 给类型定义别名：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> 类型 别名;</span><br></pre></td></tr></table></figure><p>使用 typedef 定义别名，编译器会把别名加入其所能识别的类型名列表中。可以像使用内置类型一样使用别名。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> Bool;</span><br><span class="line">...</span><br><span class="line">Bool flag; <span class="comment">/* same as int flag */</span></span><br></pre></td></tr></table></figure><p>编译器会把 <code>Bool</code> 看作 <code>int</code> 的同义词；<code>flag</code> 是一个普通的 <code>int</code> 类型变量。</p><p>使用别名主要有以下两个优点：</p><ol><li>增加代码的可读性 (前提是选择合适的类型名)。</li><li>增加代码的可移植性。</li></ol><p>C 语言库也经常使用 <code>typedef</code> 去定义一些类型；这些类型名经常以 _t 结尾，<code>_t</code>是一个结构的标注，可以理解为<code>type</code>&#x2F;<code>typedef</code>的缩写，表示它是通过<code>typedef</code>定义的，而不是其它数据类型。</p><p>如：<code>size_t</code>, <code>ptrdiff_t</code> 和 <code>wchar_t</code>，类型的定义可能不同(增加代码的可移植性)。下面是它们的典型定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">int</span> <span class="type">ptrdiff_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> <span class="type">size_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> <span class="type">wchar_t</span>;</span><br></pre></td></tr></table></figure><p><code>size_t</code> 是一种无符号整数类型，通常被定义为能够表示系统中最大可能的对象大小的无符号整数类型。在大多数情况下 <code>size_t</code> 和 <code>unsigned long</code> 在大小上相似。</p><h3 id="uint8-t-uint16-t-uint32-t-uint64-t"><a href="#uint8-t-uint16-t-uint32-t-uint64-t" class="headerlink" title="uint8_t, uint16_t, uint32_t, uint64_t"></a>uint8_t, uint16_t, uint32_t, uint64_t</h3><p>按照<code>posix</code>标准，一般整形对应的*_t类型为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1字节     uint8_t</span><br><span class="line">2字节     uint16_t</span><br><span class="line">4字节     uint32_t</span><br><span class="line">8字节     uint64_t</span><br></pre></td></tr></table></figure><h2 id="sizeof运算符"><a href="#sizeof运算符" class="headerlink" title="sizeof运算符"></a>sizeof运算符</h2><p><code>sizeof</code> 运算符可以计算某一类型变量所需的内存空间大小 (以字节为单位)。其格式为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sizeof</span>(type_name)</span><br></pre></td></tr></table></figure><p><code>sizeof</code> 表达式的值为 <code>size_t</code> 类型(无符号长整形)。</p><p><code>sizeof</code> 运算符也可以应用于常量、变量和表达式。如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i, j;</span><br><span class="line"><span class="keyword">sizeof</span>(<span class="number">10</span>);</span><br><span class="line"><span class="keyword">sizeof</span>(i);</span><br><span class="line"><span class="keyword">sizeof</span>(i + j);</span><br></pre></td></tr></table></figure><p>在一个典型的 32-bit 和 64-bit 的机器上，上面三个表达式的值都为 <code>4</code>。</p>]]></content>
      
      
      <categories>
          
          <category> C </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C_指针</title>
      <link href="/Language/C/C_%E6%8C%87%E9%92%88"/>
      <url>/Language/C/C_%E6%8C%87%E9%92%88</url>
      
        <content type="html"><![CDATA[<h1 id="C-指针"><a href="#C-指针" class="headerlink" title="C_指针"></a>C_指针</h1><h2 id="指针基础"><a href="#指针基础" class="headerlink" title="指针基础"></a>指针基础</h2><h3 id="指针变量"><a href="#指针变量" class="headerlink" title="指针变量"></a>指针变量</h3><p>现代计算机都将内存分割为字节，每个字节都有唯一的地址。程序中的每一个变量占一个或多个字节的内存，第一个字节的地址称为是变量的地址。</p><p><font color=#0099ff><strong>指针就是地址，而指针变量就是存储地址的变量。(有时候也把指针变量称作为指针)</strong> </font></p><p>当指针变量 <code>p</code> 存储变量 <code>i</code> 的地址时， <code>p</code> 指向了 <code>i</code>。</p><p><img src="https://cdn.jsdelivr.net/gh/Barbecue-g/imagehost/Language/C/C_%E6%8C%87%E9%92%88/%E6%8C%87%E9%92%88%E5%8F%98%E9%87%8F.png" alt="指针变量"></p><h4 id="指针变量的声明"><a href="#指针变量的声明" class="headerlink" title="指针变量的声明"></a>指针变量的声明</h4><p>指针变量的声明与普通变量的声明基本一样，唯一不同的就是必须在指针变量名的前面加上星号：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *p;</span><br></pre></td></tr></table></figure><blockquote><p>注意：</p><ol><li><p>指针变量名为 <code>p</code> 而非 <code>* p</code></p></li><li><p>指针变量的类型为 <code>int*</code> ，而非 <code>int</code> 类型。</p></li></ol></blockquote><p>指针变量可以和其它变量一起出现在声明中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i, j, a[<span class="number">10</span>], b[<span class="number">20</span>], *p, *q;</span><br></pre></td></tr></table></figure><h3 id="和"><a href="#和" class="headerlink" title="&amp; 和 *"></a><code>&amp;</code> 和 <code>*</code></h3><p>获取变量的地址，取地址运算符 <code>&amp;</code> 。访问指针变量所指向的对象，解引用运算符 <code>*</code> 。 <code>p</code> 是指针， <code>*p</code> 就表示 <code>p</code> 当前指向的对象。</p><h4 id="取地址运算符"><a href="#取地址运算符" class="headerlink" title="取地址运算符 &amp;"></a>取地址运算符 <code>&amp;</code></h4><p> <code>&amp;</code> 运算符可以获取变量的地址，并可以把变量的地址赋值给指针变量：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i, *p;</span><br><span class="line">...</span><br><span class="line">p = &amp;i;</span><br></pre></td></tr></table></figure><h4 id="解引用运算符"><a href="#解引用运算符" class="headerlink" title="解引用运算符 *"></a>解引用运算符 <code>*</code></h4><p>一旦指针变量指向了对象，就可以使用 * 运算符访问被指向的对象。</p><p> <code>p</code> 指向了 <code>i</code> ，下面的语句将显示 <code>i</code> 的值：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, *p);</span><br></pre></td></tr></table></figure><p> <code>p</code> 指向了 <code>i</code>， <code>*p</code> 就是 <code>i</code> 的<strong>别名</strong>。<code>*p</code> 不仅拥有和 <code>i</code> 相同的值，而且对 <code>*p</code> 的改变也会改变 <code>i</code> 的值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">i: 直接访问，读取内存一次 </span><br><span class="line">*p: 间接访问，读取内存两次</span><br></pre></td></tr></table></figure><p>可以把 <code>&amp;</code> 和 <code>*</code> 看作是一对逆运算。</p><p>优先级顺序：自增自减运算符 &gt; 解引用 <code>*</code> *和取地址 <code>&amp;</code> &gt; 算术运算</p><h4 id="警惕野指针问题"><a href="#警惕野指针问题" class="headerlink" title="警惕野指针问题"></a><strong>警惕野指针问题</strong></h4><p><strong>野指针</strong>：指针变量 <code>p</code> 未被初始化或者指向了一个未知的区域。对野指针使用解引用运算符会导致未定义的行为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *p;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, *p); <span class="comment">/*** WRONG ***/</span></span><br><span class="line">*p = <span class="number">1</span>; <span class="comment">/*** WRONG ***/</span></span><br></pre></td></tr></table></figure><h3 id="指针赋值"><a href="#指针赋值" class="headerlink" title="指针赋值"></a>指针赋值</h3><ol><li>把变量的地址赋值给指针变量：</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i, j, *p, *q;</span><br><span class="line">p = &amp;i;</span><br></pre></td></tr></table></figure><ol start="2"><li>通过另一个指针变量进行赋值：</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">q = p;</span><br></pre></td></tr></table></figure><ol start="3"><li><code>q = p</code> 和 <code>*q = *p</code> 的区别</li></ol><ul><li><p><code>q = p</code> 是将指针的值进行复制，两个指针指向相同的内存位置。</p></li><li><p><code>*q = *p</code> 是将指针所指向的内存位置的值进行复制，两个指针可以指向不同的内存位置。</p></li></ul><h3 id="指针作为参数"><a href="#指针作为参数" class="headerlink" title="指针作为参数"></a>指针作为参数</h3><p>C 语言函数调用时，是进行值传递的，在函数调用中，无法改变实参的值。</p><p>解决方法：不传递 a 和 b 作为函数的实际参数，而是传递 <code>&amp;a</code> 和 <code>&amp;b</code>。形式参数声明为对应的指针类型。函数参数列表中<code>*p</code> 和 <code>*q</code> 分别为变量 a 和 b 的别名，因此可以通过 <code>*p</code> 和 <code>*q</code> 改变变量 a 和 b 的值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>* p, <span class="type">int</span>* q)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> temp = *p;</span><br><span class="line">    *p = *q;</span><br><span class="line">    *q = temp; </span><br><span class="line">&#125;</span><br><span class="line">swap(&amp;a, &amp;b);</span><br></pre></td></tr></table></figure><p> <code>scanf</code> 函数格式串之后的参数必须是指针，但并不是必须使用 <code>&amp;</code> 运算符。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i, *p;</span><br><span class="line">p = &amp;i;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, p);</span><br></pre></td></tr></table></figure><h3 id="指针作为返回值"><a href="#指针作为返回值" class="headerlink" title="指针作为返回值"></a>指针作为返回值</h3><p>返回指针的函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* <span class="title function_">find_middle</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> n)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;a[n/<span class="number">2</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font color=#0099ff><strong>注意：永远不要返回指向当前栈帧区域的指针：</strong> </font>一旦当前函数执行完毕，其所在的栈帧会被释放。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*** 错误 ***/</span></span><br><span class="line"><span class="comment">//int* f(void) </span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//    int i;</span></span><br><span class="line"><span class="comment">//    return &amp;i; </span></span><br><span class="line"><span class="comment">//&#125;</span></span><br></pre></td></tr></table></figure><h2 id="指针与数组"><a href="#指针与数组" class="headerlink" title="指针与数组"></a>指针与数组</h2><h3 id="指针的算术运算"><a href="#指针的算术运算" class="headerlink" title="指针的算术运算"></a>指针的算术运算</h3><p>指针可以指向数组的元素</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">10</span>], *p;</span><br><span class="line">p = &amp;a[<span class="number">0</span>];</span><br></pre></td></tr></table></figure><img src="https://cdn.jsdelivr.net/gh/Barbecue-g/imagehost/Language/C/C_%E6%8C%87%E9%92%88/%E6%8C%87%E9%92%88%E6%8C%87%E5%90%91%E6%95%B0%E7%BB%84.png" alt="指针指向数组" style="zoom:67%;" /><p>通过对指针 <code>p</code> 执行指针算术运算，可以访问数组 a 的其它所有元素。</p><p>C 语言支持 3 种格式的指针算术运算：</p><ul><li><p>指针加上一个整数，结果是指针</p></li><li><p>指针减去一个整数，结果是指针</p></li><li><p>两个指针相减，结果是整数</p></li></ul><h4 id="指针加上整数"><a href="#指针加上整数" class="headerlink" title="指针加上整数"></a>指针加上整数</h4><p> <code>p</code> 指向数组元素 <code>a[i]</code>， <code>p + j</code> 将指向 <code>a[i+j]</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">10</span>], *p, *q;</span><br><span class="line">p = &amp;a[<span class="number">2</span>];</span><br><span class="line">q = p + <span class="number">3</span>;</span><br><span class="line">p += <span class="number">6</span>;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Barbecue-g/imagehost/Language/C/C_%E6%8C%87%E9%92%88/%E6%8C%87%E9%92%88%E5%8A%A0%E4%B8%8A%E6%95%B4%E6%95%B0.png" alt="指针加上整数"></p><h4 id="指针减去整数"><a href="#指针减去整数" class="headerlink" title="指针减去整数"></a>指针减去整数</h4><p> <code>p</code> 指向数组元素 <code>a[i]</code>， <code>p - j</code> 指向 <code>a[i-j]</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">10</span>], *p, *q;</span><br><span class="line">p = &amp;a[<span class="number">8</span>];</span><br><span class="line">q = p - <span class="number">3</span>;</span><br><span class="line">p -= <span class="number">6</span>;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Barbecue-g/imagehost/Language/C/C_%E6%8C%87%E9%92%88/%E6%8C%87%E9%92%88%E5%87%8F%E5%8E%BB%E6%95%B4%E6%95%B0.png" alt="指针减去整数"></p><h4 id="两个指针相减"><a href="#两个指针相减" class="headerlink" title="两个指针相减"></a>两个指针相减</h4><p>当两个指针相减时，结果为指针之间的距离。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">p = &amp;a[<span class="number">5</span>];</span><br><span class="line">q = &amp;a[<span class="number">1</span>];</span><br><span class="line">i = p - q; <span class="comment">/* i is 4 */</span></span><br><span class="line">i = q - p; <span class="comment">/* i is -4 */</span></span><br></pre></td></tr></table></figure><blockquote><ol><li>对一个不指向数组元素的指针执行算术运算会导致未定义的行为。</li><li>只有在两个指针指向同一个数组时，相减才有意义。</li></ol></blockquote><h4 id="指针比较"><a href="#指针比较" class="headerlink" title="指针比较"></a>指针比较</h4><p>可以用关系运算符 (<code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code> 和 <code>&gt;=</code>) 和判等运算符 (<code>==</code> 和 <code>!=</code>) 对指针进行比较。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">p &lt; q 等价于 p - q &lt; 0</span><br><span class="line">p = q 等价于 p - q = 0</span><br><span class="line">p &gt; q 等价于 p - q &gt; 0</span><br></pre></td></tr></table></figure><p>只有当两个指针指向同一数组时，比较才有意义。如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">p = &amp;a[<span class="number">5</span>];</span><br><span class="line">q = &amp;a[<span class="number">1</span>];</span><br><span class="line">p &lt;= q; <span class="comment">/* 0 */</span></span><br><span class="line">p &gt;= q; <span class="comment">/* 1 */</span></span><br></pre></td></tr></table></figure><h3 id="指针用于处理数组"><a href="#指针用于处理数组" class="headerlink" title="指针用于处理数组"></a>指针用于处理数组</h3><p>通过对指针变量进行重复的自增来遍历数组中的元素。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> N 10</span></span><br><span class="line"><span class="type">int</span> a[N], *p, sum;</span><br><span class="line">sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(p = &amp;a[<span class="number">0</span>]; p &lt; &amp;a[N]; p++)</span><br><span class="line">    sum += *p;</span><br></pre></td></tr></table></figure><blockquote><p>尽管 <code>a[N]</code> 这个元素不存在，但是对它使用取地址运算符是合法的。因为 <code>&amp;a[N]</code> 只会计算地址，而不会尝试访问 <code>a[N]</code> 的值。</p></blockquote><h4 id="与-的组合"><a href="#与-的组合" class="headerlink" title="*与 ++ 的组合"></a><code>*</code>与 <code>++</code> 的组合</h4><p>对某个元素进行赋值，然后前进到下一个元素：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a[i++] = j;</span><br></pre></td></tr></table></figure><p>当 <code>p</code> 指向 <code>a[i]</code>，对某个元素进行赋值，然后前进到下一个元素：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*p++ = j;</span><br></pre></td></tr></table></figure><p> <code>*</code>与 <code>++</code> 的其它组合方式（常见的还是 <code>*p++</code>）：</p><p>优先级顺序：自增自减运算符 &gt; 解引用 <code>*</code> *和取地址 <code>&amp;</code> &gt; 算术运算</p><table><thead><tr><th align="center">表达式</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center"><code>*p++</code> 或 <code>*(p++)</code></td><td align="center">返回指针当前指向的值，指针指向下一个元素</td></tr><tr><td align="center"><code>(*p)++</code></td><td align="center">返回指针当前指向的值，指针指向的值自增</td></tr><tr><td align="center"><code>*++p</code> 或 <code>*(++p)</code></td><td align="center">返回指针下一个元素的值，指针指向下一个元素</td></tr><tr><td align="center"><code>++*p</code> 或 <code>++(*p)</code></td><td align="center">返回指针当前指向的值自增后的新值，指针指向的值自增</td></tr></tbody></table><p>数组元素求和时</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (p = &amp;a[<span class="number">0</span>]; p &lt; &amp;a[N]; p++)</span><br><span class="line">    sum += *p;</span><br></pre></td></tr></table></figure><p>改写成</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">p = &amp;a[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">while</span> (p &lt; &amp;a[N])</span><br><span class="line">    sum += *p++;</span><br></pre></td></tr></table></figure><h3 id="用数组名作为指针"><a href="#用数组名作为指针" class="headerlink" title="用数组名作为指针"></a>用数组名作为指针</h3><p>数组名可以被隐式转换为指向数组第一个元素的指针：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">10</span>];</span><br><span class="line">*a = <span class="number">7</span>; <span class="comment">/* a[0] = 7 */</span></span><br><span class="line">*(a + <span class="number">1</span>) = <span class="number">12</span>; <span class="comment">/* a[1] = 12 */</span></span><br></pre></td></tr></table></figure><p><code>a+i</code> 等同于 <code>&amp;a[i]</code>，<code>*(a+i)=a[i]</code>。</p><p>数组名作为指针的场景：</p><ul><li><p>遍历数组元素：通过递增指针来访问数组的每个元素。</p><p>以下遍历数组元素：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (p = &amp;a[<span class="number">0</span>]; p &lt; &amp;a[N]; p++)</span><br><span class="line">    sum += *p;</span><br></pre></td></tr></table></figure><p>可以改写成：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* idiom */</span></span><br><span class="line"><span class="keyword">for</span> (p = a; p &lt; a + N; p++)</span><br><span class="line">    sum += *p;</span><br></pre></td></tr></table></figure><blockquote><p>虽然可以把数组名当作指针，但是不能给数组名赋新的值，也就是说数组名是一个<code>指针常量</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> &gt;<span class="keyword">while</span> (*a != <span class="number">0</span>)</span><br><span class="line">a++; <span class="comment">/*** 错误 ***/</span></span><br></pre></td></tr></table></figure></blockquote></li><li><p>传递数组给函数：函数参数可以接受数组类型或指向数组的指针。数组名在传递给函数时，会<code>退化成指针</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">find_largest</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> max = a[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">        <span class="keyword">if</span> (a[i] &gt; max)</span><br><span class="line">            max = a[i];</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br><span class="line">largest = find_largest(b, N);</span><br></pre></td></tr></table></figure><p>在调用 <code>find_largest</code> 函数时，会把指向数组 <code>b</code> 第一个元素的指针赋值给 <code>a</code>，数组本身并没有复制。</p><ul><li><p>传递数组时，只是传递一个指针，可以把数组类型的形式参数声明为指针类型。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">find_largest</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span> n)</span>;</span><br></pre></td></tr></table></figure><blockquote><ol><li>对于形式参数而言，声明数组和声明指针是一样的。</li><li>对于变量而言，声明数组和声明指针是不同的。（声明 <code>int a[10]</code>; 会导致编译器预留 10 个整数的空间。但声明 <code>int *a</code>; ，编译器只会为一个整数的空间。 ）</li></ol></blockquote></li><li><p>形式参数为数组，可以给函数传递一个数组片段。(数组片段：数组的某个连续部分)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">largest = find_largest(b + <span class="number">5</span>, <span class="number">10</span>);</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="用指针作为数组名"><a href="#用指针作为数组名" class="headerlink" title="用指针作为数组名"></a>用指针作为数组名</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> N 10</span></span><br><span class="line"><span class="type">int</span> a[N], sum = <span class="number">0</span>, *p = a;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">    sum += p[i];</span><br></pre></td></tr></table></figure><p>编译器会把 <code>p[i]</code> 看作是 <code>*(p+i)</code>。</p><p>用指针作为数组名的情况：</p><ul><li>动态分配内存：使用指针来管理动态分配的数组，比使用固定大小的静态数组更灵活。</li><li>处理多维数组：在多维数组的情况下，指针的灵活性比数组名更有用。</li></ul>]]></content>
      
      
      <categories>
          
          <category> C </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C_字符串</title>
      <link href="/Language/C/C_%E5%AD%97%E7%AC%A6%E4%B8%B2"/>
      <url>/Language/C/C_%E5%AD%97%E7%AC%A6%E4%B8%B2</url>
      
        <content type="html"><![CDATA[<h1 id="C-字符串"><a href="#C-字符串" class="headerlink" title="C_字符串"></a>C_字符串</h1><h2 id="字符串字面值"><a href="#字符串字面值" class="headerlink" title="字符串字面值"></a>字符串字面值</h2><p>字符串字面值是用一对双引号括起来的字符序列：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;To C or not to C, that&#x27;s the question.\n&quot;</span></span><br></pre></td></tr></table></figure><p>字符串字面值太长而无法放置在一行内，可以用字符 <code>\</code> 结尾，然后在下一行的<strong>开始处</strong>延续字符串字面值：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;When you come to a fork in the road, take it. \</span></span><br><span class="line"><span class="string">——Yogi Berra&quot;</span>);</span><br></pre></td></tr></table></figure><p>字符 <code>\</code> 可以把两行或者更多行连接成一行。但使用 <code>\</code> 有一个缺陷：字符串字面值必须从下一行的开始位置书写，破环了程序的<strong>缩进结构</strong>。</p><p>C 语言中当两个或更多个字符串字面值相邻时 (仅用<strong>空白字符分割</strong>)，编译器会把它们合并成一个：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;When you come to a fork in the road, take it. &quot;</span></span><br><span class="line">    <span class="string">&quot;——Yogi Berra&quot;</span>);</span><br></pre></td></tr></table></figure><h3 id="字符串字面值的存储方式"><a href="#字符串字面值的存储方式" class="headerlink" title="字符串字面值的存储方式"></a>字符串字面值的存储方式</h3><p>C 语言是把字符串字面值作为字符数组来处理的。C 语言会为长度为 <code>n</code> 的字符串字面值分配长度为 <code>n+1</code> 的内存空间。这块内存空间将用来存储字符串字面值中的字符，以及一个用来标志字符串末尾的标记字符 (空字符 <code>\0</code> )。</p><p>字符串字面量是用数组存储的，当作为参数传递的时候，编译器会把它看成是 <code>char *</code> 类型的指针。例如， <code>printf </code>和 <code>scanf</code> 的第一个参数都是 <code>char *</code> 类型。当调用 <code>printf</code> 时，会传递 “abc” 的地址。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;abc&quot;</span>);</span><br></pre></td></tr></table></figure><h3 id="字符串字面量的操作"><a href="#字符串字面量的操作" class="headerlink" title="字符串字面量的操作"></a>字符串字面量的操作</h3><p>字符串字面值在C中被视为指向字符数组的指针，可以赋值给一个指向常量字符的指针(<code>const char *</code>)，指针本身也是常量的话，可以使用 <code>const char * const</code> 类型。 例如，字符串字面值可以出现在赋值运算符的右边：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *p;</span><br><span class="line">p = <span class="string">&quot;abc&quot;</span>;</span><br></pre></td></tr></table></figure><blockquote><p> 这个赋值操作不是复制 “abc” 中的字符，而是使 p 指向字符串的第一个字符。</p></blockquote><p>C 语言允许对指针取下标，因此也可以对字符串字面值取下标：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> ch; </span><br><span class="line">ch = <span class="string">&quot;abc&quot;</span>[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//01~15转换成16进制</span></span><br><span class="line"><span class="type">char</span> <span class="title function_">digit_to_hex_char</span><span class="params">(<span class="type">int</span> digit)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;0123456789ABCDEF&quot;</span>[digit];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>字符串字面值是不可以修改的，修改字符串字面量会导致未定义的行为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *p = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">*p = <span class="string">&#x27;A&#x27;</span>;         <span class="comment">/*** 错误 ***/</span></span><br></pre></td></tr></table></figure><h2 id="字符串变量"><a href="#字符串变量" class="headerlink" title="字符串变量"></a>字符串变量</h2><p>c语言规定：任何一维的字符数组都可以用来存储字符串，只要保证以空字符 <code>\0</code> 结尾即可。处理方式：</p><ol><li>无法确定一个字符数组是否表示字符串。</li><li>需要正确地处理空字符 <code>\0</code>。</li><li>确定字符串的长度可以遍历字符串。</li></ol><h3 id="初始化字符串变量"><a href="#初始化字符串变量" class="headerlink" title="初始化字符串变量"></a>初始化字符串变量</h3><p>字符串变量可以在声明的同时进行初始化：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> date1[<span class="number">8</span>] = <span class="string">&quot;June 14&quot;</span>;</span><br></pre></td></tr></table></figure><p>编译器会把字符串 “June 14” 中的字符复制到数组 date1 中，然后追加一个空字符。</p><img src="https://cdn.jsdelivr.net/gh/Barbecue-g/imagehost/Language/C/C_%E5%AD%97%E7%AC%A6%E4%B8%B2/%E5%88%9D%E5%A7%8B%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8F%98%E9%87%8F_1.png" alt="初始化字符串变量_1" style="zoom:50%;" /><p>C 编译器会把”June 14”看成是数组初始化式的缩写形式。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> date1[<span class="number">8</span>] = &#123;<span class="string">&#x27;J&#x27;</span>, <span class="string">&#x27;u&#x27;</span>, <span class="string">&#x27;n&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27; &#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;4&#x27;</span>, <span class="string">&#x27;\0&#x27;</span>&#125;;</span><br></pre></td></tr></table></figure><p>初始化式太短不能填满字符串变量编译器会把后面的字符都初始化为 <code>\0</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> date2[<span class="number">9</span>] = <span class="string">&quot;June 14&quot;</span>;</span><br></pre></td></tr></table></figure><img src="https://cdn.jsdelivr.net/gh/Barbecue-g/imagehost/Language/C/C_%E5%AD%97%E7%AC%A6%E4%B8%B2/%E5%88%9D%E5%A7%8B%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8F%98%E9%87%8F_2.png" alt="初始化字符串变量_2" style="zoom:50%;" /><p>初始化式 (不包括空字符) 和字符数组具有相同的长度</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> date3[<span class="number">7</span>] = <span class="string">&quot;June 14&quot;</span>;</span><br></pre></td></tr></table></figure><img src="https://cdn.jsdelivr.net/gh/Barbecue-g/imagehost/Language/C/C_%E5%AD%97%E7%AC%A6%E4%B8%B2/%E5%88%9D%E5%A7%8B%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8F%98%E9%87%8F_3.png" alt="image-20240401165748691" style="zoom:50%;" /><p>由于没有给空字符留空间，所以编译器不会试图存储空字符。</p><blockquote><p>注意：一定要确保字符数组的长度大于初始化式的长度，否则，编译器将忽略空字符，字符数组无法作为字符串使用。</p></blockquote><p>字符串变量在声明时可以省略它的长度 (推荐使用)，编译器会自动计算长度，为其分配对应字符个数的字符空间和一个空字符：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> date4[] = <span class="string">&quot;June 14&quot;</span>;</span><br></pre></td></tr></table></figure><img src="https://cdn.jsdelivr.net/gh/Barbecue-g/imagehost/Language/C/C_%E5%AD%97%E7%AC%A6%E4%B8%B2/%E5%88%9D%E5%A7%8B%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8F%98%E9%87%8F_4.png" alt="初始化字符串变量_4" style="zoom:50%;" /><h3 id="字符串数组和字符串指针"><a href="#字符串数组和字符串指针" class="headerlink" title="字符串数组和字符串指针"></a>字符串数组和字符串指针</h3><p>以下第一个 date 是一个字符数组 ，第二个 date 是一个字符指针，都可以用作字符串。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> date[] = <span class="string">&quot;June 14&quot;</span>;</span><br><span class="line"><span class="type">char</span> *date = <span class="string">&quot;June 14&quot;</span>;</span><br></pre></td></tr></table></figure><p>字符数组和字符指针的差异：</p><ul><li>声明为数组时，可以修改存储在date中的字符。声明为指针时，date 指向字符串字面值，字符串字面值是不能修改。</li><li>声明为数组时，date是数组名。声明为指针时，date是指针变量，指针变量可以在程序执行期间指向其它字符串。</li></ul><p>把字符指针作为字符串使用之前，需要把字符指针指向一个字符数组，不能使用未初始化的字符指针变量。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> str[STR_LEN + <span class="number">1</span>], *p;</span><br><span class="line">p = str;</span><br></pre></td></tr></table></figure><h2 id="读写字符串"><a href="#读写字符串" class="headerlink" title="读写字符串"></a>读写字符串</h2><h3 id="使用printf和puts写字符串"><a href="#使用printf和puts写字符串" class="headerlink" title="使用printf和puts写字符串"></a>使用printf和puts写字符串</h3><p>转换说明 <code>%s</code> 允许 <code>printf</code> 写字符串。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> str[] = <span class="string">&quot;Are we having fun yet?&quot;</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, str);</span><br></pre></td></tr></table></figure><p><code>printf</code> 函数会逐个写字符串中的字符，直到遇到空字符。(如果字符数组中没有空字符， <code>printf</code> 会一直写，直到在内存的某个位置找到空字符为止)。</p><p>转换说明符 <code>%.ps</code>，其中的 <code>p</code> 表示要显示的字符数量，也称为精度（precision）。格式化输出字符串时，显示字符串的前 <code>p</code> 个字符。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> str[] = <span class="string">&quot;Hello, world!&quot;</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%.5s\n&quot;</span>, str); <span class="comment">// Output: &quot;Hello&quot;，只显示字符串的前 5 个字符</span></span><br></pre></td></tr></table></figure><p>转换说明符 <code>%ms</code>，其中的 <code>m</code> 代表最大字段宽度（maximum field width）。格式化输出字符串时，该字段会被限制在最多 <code>m</code> 个字符的宽度内。字符串的长度超过 <code>m</code>，则会显示整个字符串，而不会截断。字符串长度少于 <code>m</code>，则会在字段内右对齐，即空白字符会在字符串左侧填充，以达到总宽度为 m。左对齐，则在 <code>m</code> 前面添加一个减号。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> str[] = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%10s\n&quot;</span>, str);  <span class="comment">// Output: &quot;     Hello&quot;，在宽度为 10 的字段内右对齐</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%-10s\n&quot;</span>, str); <span class="comment">// Output: &quot;Hello     &quot;，在宽度为 10 的字段内左对齐</span></span><br></pre></td></tr></table></figure><p>C 函数库还提供了 <code>puts</code> 函数，用来输出字符串，<code>puts</code> 会在后面添加一个额外的换行符。如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">puts</span>(str);</span><br></pre></td></tr></table></figure><h3 id="使用scanf和gets读字符串"><a href="#使用scanf和gets读字符串" class="headerlink" title="使用scanf和gets读字符串"></a>使用scanf和gets读字符串</h3><p>转换说明 <code>%s</code> 允许 <code>scanf</code> 把字符串读入字符数组：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, str);</span><br></pre></td></tr></table></figure><p>在 <code>scanf</code> 函数调用中，不需要在<code>str</code> 前添加运算符 <code>&amp;</code> 。 <code>str</code> 是数组名，编译器在把它传递给函数时会把它当作指针来处理。</p><p>读字符串时， <code>scanf</code> 会跳过前面的<strong>空白字符</strong>，然后读入字符并存储到 <code>str</code> 中，直到遇到<strong>空白字符</strong>为止。 <code>scanf</code> 始终会在字符串末尾存储一个<strong>空字符</strong>。<strong>空格符</strong>和<strong>制表符</strong>会使 <code>scanf</code> 停止读入。</p><p>为了读入一整行输入，可以使用 <code>gets</code> 函数。类似于 <code>scanf</code> ， <code>gets</code> 会把读入的字符存储到<strong>字符数组</strong>中，然后存储一个<strong>空字符</strong>。但两个函数在其它方面有很大的不同：</p><ul><li><p><code>gets</code> 不会跳过前面的<strong>空白字符</strong> (<code>scanf</code> 会跳过)。</p></li><li><p><code>gets</code> 会一直读入直到遇到<strong>换行符</strong> <code>\n</code> 才停止 (<code>scanf</code> 会在任意<strong>空白字符</strong>处停止)。此外，<code>gets</code> 函数会忽略掉<strong>换行符</strong>，用<strong>空字符</strong>代替<strong>换行符</strong>。</p></li></ul><blockquote><p>注意： <code>scanf</code> 和 <code>puts</code> 函数都不会检查数组是否越界。使用这两类函数是不安全的。</p></blockquote><h2 id="C语言字符串库"><a href="#C语言字符串库" class="headerlink" title="C语言字符串库"></a>C语言字符串库</h2><p>C 语言提供了丰富的字符串函数。函数的原型都包含在 <code>string.h</code> 头文件中。</p><h3 id="strcpy-函数"><a href="#strcpy-函数" class="headerlink" title="strcpy 函数"></a><code>strcpy</code> 函数</h3><p> <code>strcpy</code> 函数用于将一个字符串复制到另一个字符串中，其原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">strcpy</span><span class="params">(<span class="type">char</span> *dest, <span class="type">const</span> <span class="type">char</span> *src)</span>;</span><br></pre></td></tr></table></figure><p><code>strcpy</code> 函数用于将源字符串 <code>src</code> 复制到目标字符串 <code>dest</code> 中（不会改变 <code>src</code> 指向的字符串），直到遇到源字符串的空字符 <code>\0</code> （包括空字符 <code>\0</code> 也会复制）。目标字符串必须有足够的空间来容纳源字符串，否则会导致缓冲区溢出。返回指向目标字符串的指针 <code>dest</code> (大部分情况下忽略返回值)。这一过程不会改变 <code>src</code> 指向的字符串，因此将其声明为 <code>const</code> 。</p><p> <code>strcpy</code> 是不安全的，不会检查 <code>dest</code> 指向的数组是否能容纳字符串 <code>src</code> 中的所有字符。</p><p> <code>strncpy</code> 函数也是用于字符串复制，能够限制复制的字符数。原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">strncpy</span><span class="params">(<span class="type">char</span> *dest, <span class="type">const</span> <span class="type">char</span> *src, <span class="type">size_t</span> n)</span>;</span><br></pre></td></tr></table></figure><p><code>dest</code>是目标字符串的指针，<code>src</code>是源字符串的指针，<code>n</code>是要复制的最大字符数。该函数会把 <code>src</code> 指向的字符串的前<code>n</code>个字符复制到<code>dest</code>指向的字符串中。如果源字符串的长度小于<code>n</code>，则会在目标字符串的剩余空间用 <code>\0</code> 来填充。</p><p>当 <code>src</code> 的长度大于 <code>dest</code> 的长度， <code>dest</code> 将不会以空字符结尾。更安全的做法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">strncpy</span>(dest, src, <span class="keyword">sizeof</span>(dest) - <span class="number">1</span>);</span><br><span class="line">dest[<span class="keyword">sizeof</span>(dest) - <span class="number">1</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br></pre></td></tr></table></figure><h3 id="strlen-函数"><a href="#strlen-函数" class="headerlink" title="strlen 函数"></a><code>strlen</code> 函数</h3><p> <code>strlen</code> 函数用于计算字符串的长度，其原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span> <span class="title function_">strlen</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str)</span>;</span><br></pre></td></tr></table></figure><p> <code>strlen</code> 函数返回字符串 <code>str</code> 的长度：<code>str</code> 中第一个空字符之前的字符个数(不包括空字符<code>\0</code>)。</p><h3 id="strcat-函数"><a href="#strcat-函数" class="headerlink" title="strcat 函数"></a><code>strcat</code> 函数</h3><p> <code>strcat</code> 函数用于将一个字符串追加到另一个字符串的末尾，其原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">strcat</span><span class="params">(<span class="type">char</span> *dest, <span class="type">const</span> <span class="type">char</span> *src)</span>;</span><br></pre></td></tr></table></figure><p> <code>dest</code> 是目标字符串的指针，<code>src</code> 是要追加的源字符串的指针。函数会把 <code>src</code> 指向的字符串追加到 <code>dest</code> 指向的字符串的末尾。返回指向目标字符串的指针 <code>dest</code> (大部分情况下忽略返回值)。这一过程不会改变 <code>src</code> 指向的字符串，因此将其声明为 <code>const</code> 。</p><p><code>strcat</code> 是不安全的，不会检查 <code>dest</code> 指向的数组是否能容纳所有的字符。</p><p><code>strncat</code>函数也用于连接字符串，允许指定最大连接的字符数。其原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">strncat</span><span class="params">(<span class="type">char</span> *dest, <span class="type">const</span> <span class="type">char</span> *src, <span class="type">size_t</span> n)</span>;</span><br></pre></td></tr></table></figure><p><code>dest</code> 是目标字符串的指针，<code>src</code> 是要连接的源字符串的指针，<code>n</code> 是要连接的最大字符数。<code>strncat</code> 函数会将 <code>src </code>指向的字符串中的最多 <code>n</code> 个字符连接到 <code>dest</code> 指向的字符串的末尾，并返回 <code>dest</code> 的值。</p><h3 id="strcmp-函数"><a href="#strcmp-函数" class="headerlink" title="strcmp 函数"></a><code>strcmp</code> 函数</h3><p><code>strcmp</code>函数用于比较两个字符串，其原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">strcmp</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str1, <span class="type">const</span> <span class="type">char</span> *str2)</span>;</span><br></pre></td></tr></table></figure><p>其中，<code>str1</code>和<code>str2</code>分别是要比较的两个字符串的指针。该函数返回值为整数，表示比较结果的大小关系：</p><ul><li>如果 <code>str1</code> 小于 <code>str2</code> ，则返回负数；</li><li>如果 <code>str1</code> 等于 <code>str2</code> ，则返回0；</li><li>如果 <code>str1</code> 大于 <code>str2</code> ，则返回正数。</li></ul><p><code>strcmp</code>函数是按照字典顺序逐个比较两个字符串的字符，直到遇到不同的字符或者其中一个字符串的结束符<code>\0</code>为止。 <code>strcmp</code>  函数小于的判定：</p><ul><li><code>str1</code> 与 <code>str2</code> 的前 i 个字符一致，但是 <code>str1</code> 的第 i + 1 个字符小于 <code>str2</code> 的第 i + 1个字符。（”abc” 小于 “bcd” ；”abd” 小于 “abe”）</li><li><code>str1</code> 的所有字符与 <code>str2</code> 的字符一致，但是 <code>str1</code> 比 <code>str2</code> 短。（”abc” 小于 “abcd”）</li></ul><p>忽略大小写进行比较，可以使用<code>strcasecmp</code>函数（Linux&#x2F;Unix系统）或者<code>_stricmp</code>函数（Windows系统）。</p><h3 id="strdup-函数"><a href="#strdup-函数" class="headerlink" title="strdup 函数"></a><code>strdup</code> 函数</h3><p><code>strdup</code>函数在C语言中用于复制字符串，并返回一个指向新复制的字符串的指针。它的原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">strdup</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str)</span>;</span><br></pre></td></tr></table></figure><p><code>str</code>是要复制的字符串的指针。<code>strdup</code>函数会动态分配足够的内存来存储复制的字符串，并将原始字符串的内容复制到新分配的内存中，然后返回新分配内存的指针。使用完后需要手动释放内存，以避免内存泄漏。</p><h3 id="其它函数"><a href="#其它函数" class="headerlink" title="其它函数"></a>其它函数</h3><ul><li><code>strchr</code>：在字符串中查找指定字符的第一个匹配，并返回指向该字符的指针。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">strchr</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str, <span class="type">int</span> c)</span>;</span><br></pre></td></tr></table></figure><ul><li><code>strrchr</code>：在字符串中查找指定字符的最后一个匹配，并返回指向该字符的指针。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">strrchr</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str, <span class="type">int</span> c)</span>;</span><br></pre></td></tr></table></figure><ul><li><code>strstr</code>：在字符串中查找子串的第一个匹配，并返回指向该子串的指针。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">strstr</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *haystack, <span class="type">const</span> <span class="type">char</span> *needle)</span>;</span><br></pre></td></tr></table></figure><ul><li><code>strtok</code>：将字符串分解为一系列子字符串，并返回指向下一个子字符串的指针。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">strtok</span><span class="params">(<span class="type">char</span> *str, <span class="type">const</span> <span class="type">char</span> *delim)</span>;</span><br></pre></td></tr></table></figure><ul><li><code>strspn</code>：返回字符串中连续匹配给定字符集的字符的长度。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span> <span class="title function_">strspn</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str, <span class="type">const</span> <span class="type">char</span> *accept)</span>;</span><br></pre></td></tr></table></figure><ul><li><code>strcspn</code>：返回字符串中连续不匹配给定字符集的字符的长度。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span> <span class="title function_">strcspn</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str, <span class="type">const</span> <span class="type">char</span> *reject)</span>;</span><br></pre></td></tr></table></figure><ul><li><code>strncpy</code>：复制字符串的一部分到另一个字符串，可以指定要复制的最大字符数。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">strncpy</span><span class="params">(<span class="type">char</span> *dest, <span class="type">const</span> <span class="type">char</span> *src, <span class="type">size_t</span> n)</span>;</span><br></pre></td></tr></table></figure><ul><li><code>strncasecmp</code>：忽略大小写比较两个字符串的前n个字符。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">strncasecmp</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s1, <span class="type">const</span> <span class="type">char</span> *s2, <span class="type">size_t</span> n)</span>;</span><br></pre></td></tr></table></figure><h2 id="字符串数组"><a href="#字符串数组" class="headerlink" title="字符串数组"></a>字符串数组</h2><p>存储一组字符串的两种方法：</p><ul><li><p><strong>二维字符数组：</strong> 在二维字符数组中，每一行都是一个字符串，而数组中的每个元素都是一个字符数组，用于存储一个字符串。这种方式在内存中是连续存储的，例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> planets[][<span class="number">8</span>] = &#123; <span class="string">&quot;Mercury&quot;</span>, <span class="string">&quot;Venus&quot;</span>, <span class="string">&quot;Earth&quot;</span>, <span class="string">&quot;Mars&quot;</span>,</span><br><span class="line">                     <span class="string">&quot;Jupiter&quot;</span>, <span class="string">&quot;Saturn&quot;</span>, <span class="string">&quot;Uranus&quot;</span>, <span class="string">&quot;Neptune&quot;</span>&#125;;</span><br></pre></td></tr></table></figure><img src="https://cdn.jsdelivr.net/gh/Barbecue-g/imagehost/Language/C/C_%E5%AD%97%E7%AC%A6%E4%B8%B2/%E4%BA%8C%E7%BB%B4%E5%AD%97%E7%AC%A6%E6%95%B0%E7%BB%84.png" alt="二维字符数组" style="zoom:67%;" /><p>弊端：</p><ol><li>字符串之间长度差异很大，就会浪费内存空间。</li><li>不灵活。对字符串进行排序，就需要复制整个字符串里面的内容。</li></ol></li><li><p><strong>字符指针数组：</strong> 在字符指针数组中，数组的每个元素都是一个指向字符数组的指针，每个指针指向一个字符串。这种方式在内存中不一定是连续存储的，例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>* planets[] = &#123; <span class="string">&quot;Mercury&quot;</span>, <span class="string">&quot;Venus&quot;</span>, <span class="string">&quot;Earth&quot;</span>, <span class="string">&quot;Mars&quot;</span>,</span><br><span class="line">                     <span class="string">&quot;Jupiter&quot;</span>, <span class="string">&quot;Saturn&quot;</span>, <span class="string">&quot;Uranus&quot;</span>, <span class="string">&quot;Neptune&quot;</span>&#125;;</span><br></pre></td></tr></table></figure><img src="https://cdn.jsdelivr.net/gh/Barbecue-g/imagehost/Language/C/C_%E5%AD%97%E7%AC%A6%E4%B8%B2/%E5%AD%97%E7%AC%A6%E6%8C%87%E9%92%88%E6%95%B0%E7%BB%84.png" alt="字符指针数组" style="zoom: 55%;" /><p>虽然必须为字符串数组中的指针分配空间，但是字符串中不再有任何浪费的字符。存储方式很灵活，对字符串数组进行排序的时候，只需要交换指针即可，不需要复制整个字符串。</p></li></ul><h3 id="命令行参数"><a href="#命令行参数" class="headerlink" title="命令行参数"></a>命令行参数</h3><p>命令行参数是指在运行程序时通过命令行传递给程序的参数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span><br></pre></td></tr></table></figure><p><code>argc</code>(argument count)是命令行参数的数量，<code>argv</code>(argument vector)是一个指向字符指针数组的指针，每个指针指向一个命令行参数字符串。操作系统都是以<strong>字符串</strong>的形式传递参数的，<code>argv[0]</code>存储的是程序的名称，<code>argv[1]</code>、<code>argv[2]</code>等存储的是传递给程序的参数字符串。</p>]]></content>
      
      
      <categories>
          
          <category> C </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C_指针的应用</title>
      <link href="/Language/C/C_%E6%8C%87%E9%92%88%E7%9A%84%E5%BA%94%E7%94%A8"/>
      <url>/Language/C/C_%E6%8C%87%E9%92%88%E7%9A%84%E5%BA%94%E7%94%A8</url>
      
        <content type="html"><![CDATA[<h1 id="C-指针的应用"><a href="#C-指针的应用" class="headerlink" title="C_指针的应用"></a>C_指针的应用</h1><h2 id="动态内存分配"><a href="#动态内存分配" class="headerlink" title="动态内存分配"></a>动态内存分配</h2><p>动态内存分配是链式结构的基础。可以把动态分配的内存链接在一起，形成链表、树、图等灵活的数据结构。</p><h3 id="内存分配函数"><a href="#内存分配函数" class="headerlink" title="内存分配函数"></a>内存分配函数</h3><p>在 <code>&lt;stdlib.h&gt;</code> 头文件中，三个函数可以进行动态内存分配：</p><ul><li><pre><code class="c">void* malloc(size_t size)<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   分配 `size` 个字节的内存块，不对内存块进行清零；如果无法分配指定大小的内存块，返回空指针。</span><br><span class="line"></span><br><span class="line">-  ```c</span><br><span class="line">   void* calloc(size_t nmemb, size_t size) </span><br></pre></td></tr></table></figure>为有 `nmemb` 个元素的数组分配内存块，其中每个元素占 `size` 个字节，并且对内存块进行清零；如果无法分配指定大小的内存块，返回空指针。</code></pre></li><li><pre><code class="c">void* realloc(void *ptr, size_t size)<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   调整先前分配内存块的大小。如果重新分配内存大小成功，返回指向新内存块的指针，否则返回空指针。</span><br><span class="line"></span><br><span class="line"> `malloc` 效率最高， `malloc` 和 `realloc` 函数的`size`是数组总大小，`calloc` 函数的`size`是数组中一个元素的大小。</span><br><span class="line"></span><br><span class="line">返回 `void*` 类型的指针。 `void*` 类型的值是&quot;通用&quot;指针。 `void* `类型的指针可以转换成其它类型的指针，其它类型的指针也可以转换成 `void*` 类型的指针。</span><br><span class="line"></span><br><span class="line">### 空指针</span><br><span class="line"></span><br><span class="line">调用内存分配函数时，找不到足够大的内存空间，函数就会返回空指针。空指针是&quot;不指向任何对象的指针&quot;。通常是将它指向一个特殊的地址(0x00000000)，并且用宏 `NULL` 表示。</span><br><span class="line"></span><br><span class="line">&gt;对空指针进行解引用，其行为是未定义的。不过在实现上，一般会报空指针异常，导致程序崩溃。</span><br><span class="line"></span><br><span class="line">当函数可能返回空指针的时候，在使用指针之前，应该进行判断。</span><br><span class="line"></span><br><span class="line">```c</span><br><span class="line">void *p = malloc(1024);</span><br><span class="line">if (p == NULL) &#123;</span><br><span class="line">/* allocation failed; take appropriate action */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre></li></ul><p><code>if (p == NULL)</code> 可以写成<code>if (!p)</code> ； <code>if (p != NULL)</code> 也可以写成 <code>if (p) </code>。</p><h3 id="动态分配字符串"><a href="#动态分配字符串" class="headerlink" title="动态分配字符串"></a>动态分配字符串</h3><p>需要给有 <code>n</code> 个字符的字符串分配内存空间：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *p = <span class="built_in">malloc</span>(n + <span class="number">1</span>);</span><br></pre></td></tr></table></figure><blockquote><p>注意：</p><ol><li><p>在 C 语言中，字符串是以 <code>\0</code> 结尾的，因此参数为 <code>n+1</code> 而非 <code>n</code>。</p></li><li><p>通用指针类型<code>void*</code> 可以自动转换为任意指针类型，因此可以<strong>不</strong>需要强制类型转换。(强制力类型转换如下)</p></li></ol> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;p = (<span class="type">char</span> *) <span class="built_in">malloc</span>(n + <span class="number">1</span>);</span><br></pre></td></tr></table></figure></blockquote><h3 id="动态分配数组"><a href="#动态分配数组" class="headerlink" title="动态分配数组"></a>动态分配数组</h3><ol><li><p>使用 <code>malloc</code> 为数组分配内存空间</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *arr = <span class="built_in">malloc</span>(size * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br></pre></td></tr></table></figure><p>用 <code>sizeof</code> 运算符计算所需的内存空间，同一类型在不同平台上所占内存大小可能是不相同的。</p><p>申请内存成功后，可以像使用普通数组一样使用动态数组</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">arr[i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用 <code>calloc</code> 为数组分配内存空间</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *arr = <span class="built_in">calloc</span>(size, <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br></pre></td></tr></table></figure><p>数组在需要初始化为 <code>0</code> 的情况下，<code>calloc</code> 比 <code>malloc</code> 效率更高。结构体需要清零操作，可以使用 <code>calloc</code> 为结构体变量申请内存空间：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line"> <span class="type">int</span> x;</span><br><span class="line"> <span class="type">int</span> y;</span><br><span class="line">&#125; Point;</span><br><span class="line">p = <span class="built_in">calloc</span>(<span class="number">1</span>, <span class="keyword">sizeof</span>(Point));</span><br></pre></td></tr></table></figure></li><li><p>使用 <code>realloc</code> 重新调整数组的大小</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *arr = (<span class="type">int</span> *)<span class="built_in">malloc</span>(size * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">arr = <span class="built_in">realloc</span>(arr, size * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br></pre></td></tr></table></figure><p>在需要调整数组大小的情况下，<code>realloc</code> 比手动释放和重新分配内存空间更高效。调用 <code>realloc</code> 函数时，<code>ptr</code> 必须指向先前通过 <code>malloc</code> , <code>calloc</code> 或者 <code>realloc</code> 获得的内存块(即堆内存空间)。</p><p>C 标准没有明确指明 <code>realloc</code> 的工作原理，但实际上会比较高效：</p><ol><li>当新内存块比旧内存块小的时候，会直接截断旧内存块。</li><li>当新内存块比旧内存块大的时候，会试图原地扩大旧内存块，如果不可行，再在别处申请内存块，并把旧内存块里的数据复制到新内存块，同时释放旧内存块。</li></ol><p>关于 <code>realloc</code> 函数的规则：</p><ol><li>申请新内存块不成功， <code>realloc</code> 函数会返回空指针；并且旧内存块的数据不会发生改变。</li><li>新内存块比旧内存块大，超过的部分内存是不会被初始化的。</li><li><code>realloc</code> 的第一个参数为空指针，它的行为和 <code>malloc</code> 一样。</li><li><code>realloc</code> 的第二个参数为 0，它会释放 ptr 指向的内存块。</li></ol></li></ol><p><font color=#0099ff><strong>注意： <code>realloc</code> 可能会移动内存块，所以一定要记得更新所有指向旧内存块的指针。</strong></font></p><h2 id="释放内存空间"><a href="#释放内存空间" class="headerlink" title="释放内存空间"></a>释放内存空间</h2><p><code>malloc</code> , <code>calloc</code> 和 <code>realloc</code> 函数都是在堆上申请内存空间。丢失了对内存块的跟踪就会产生内存泄漏。</p><p>内存泄漏：程序在动态分配内存后，无法释放已经不再需要的内存，导致系统中的可用内存不断减少，直至耗尽，造成程序性能下降甚至崩溃的问题。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">p = <span class="built_in">malloc</span>(...);</span><br><span class="line">q = <span class="built_in">malloc</span>(...);</span><br><span class="line">p = q;</span><br></pre></td></tr></table></figure><img src="https://github.com/Barbecue-g/Imagehost/blob/master/Language/C/C_%E6%8C%87%E9%92%88/%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E5%8E%9F%E7%90%86.png?raw=true" alt="内存泄漏" style="zoom:67%;" /><p> C 语言要求负责垃圾的回收，提供了 <code>free</code> 函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">free</span><span class="params">(<span class="type">void</span> *ptr)</span>;</span><br></pre></td></tr></table></figure><p>指向不再需要的内存块的指针传递给 <code>free</code> 函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">p = <span class="built_in">malloc</span>(...);</span><br><span class="line">q = <span class="built_in">malloc</span>(...);</span><br><span class="line"><span class="built_in">free</span>(p);</span><br><span class="line">p = q;</span><br></pre></td></tr></table></figure><img src="https://cdn.jsdelivr.net/gh/Barbecue-g/imagehost/Language/C/C_%E6%8C%87%E9%92%88/free%E5%87%BD%E6%95%B0.png" alt="free函数" style="zoom:67%;" /><blockquote><p>使用 <code>free</code> 函数注意：</p><ol><li>传递给 <code>free</code> 的参数必须是由内存分配函数返回的指针，否则 <code>free</code> 函数的行为是未定义的。</li><li>同一片内存空间不能被 <code>free</code> 两次，否则会出现 <code>double-free</code> 现象。</li></ol></blockquote><p><strong>悬空指针问题</strong></p><p>悬空指针是指指向已经释放的内存地址的指针，或者指向未分配的内存区域的指针，程序会导致未定义的行为。因为释放后的内存，可能被重新分配。调用 <code>free(p)</code> 会释放 <code>p</code> 指向的内存空间，但并不会改变 <code>p</code> 的值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *p = <span class="built_in">malloc</span>(<span class="number">10</span>);</span><br><span class="line"><span class="type">char</span> *q = p;</span><br><span class="line"><span class="built_in">free</span>(p); <span class="comment">// free之后，p和q都成为了悬空指针</span></span><br><span class="line"><span class="built_in">strcpy</span>(p, <span class="string">&quot;abc&quot;</span>); <span class="comment">/* 错误! */</span></span><br><span class="line"><span class="built_in">strcat</span>(q, <span class="string">&quot;def&quot;</span>); <span class="comment">/* 错误! */</span></span><br></pre></td></tr></table></figure><p>当能有几个指针指向相同的内存块，在释放该内存块后，所有的指针都”悬空”了。</p><h2 id="动态分配的结构体"><a href="#动态分配的结构体" class="headerlink" title="动态分配的结构体"></a>动态分配的结构体</h2><p>动态分配的结构体对构建链表、树、图等其它链式结构是非常有用的。</p><p>定义结点类型：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span>* <span class="title">next</span>;</span><span class="comment">//next是一个指针，指向与当前结构体相同类型的另一个结构体对象。</span></span><br><span class="line">&#125;Node;</span><br></pre></td></tr></table></figure><p>定义一个 addNode 方法，它可以在链表的前面添加一个结点。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Node* <span class="title function_">addNode</span><span class="params">(Node* <span class="built_in">list</span>, <span class="type">int</span> data)</span> &#123;</span><br><span class="line">    <span class="comment">// 动态分配一个结点</span></span><br><span class="line">   Node* newNode = (Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    <span class="keyword">if</span> (newNode == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Error: malloc failed in addNode\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">   &#125;</span><br><span class="line">    <span class="comment">// 初始化结点</span></span><br><span class="line">    newNode-&gt;data = data;</span><br><span class="line">    <span class="comment">// 头插法</span></span><br><span class="line">    newNode-&gt;next = <span class="built_in">list</span>;  <span class="comment">// 指针变量的赋值：类似p = q</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> newNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 main 方法中进行调用：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    Node* <span class="built_in">list</span> = <span class="literal">NULL</span>; <span class="comment">// 空链表</span></span><br><span class="line">    <span class="built_in">list</span> = addNode(<span class="built_in">list</span>, <span class="number">3</span>); <span class="comment">// 3</span></span><br><span class="line">    <span class="built_in">list</span> = addNode(<span class="built_in">list</span>, <span class="number">2</span>); <span class="comment">// 2 --&gt; 3</span></span><br><span class="line">    <span class="built_in">list</span> = addNode(<span class="built_in">list</span>, <span class="number">1</span>); <span class="comment">// 1 --&gt; 2 --&gt; 3</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二级指针"><a href="#二级指针" class="headerlink" title="二级指针"></a>二级指针</h2><p>二级指针（Double Pointer）是指向指针的指针。它是指针变量的地址。一级指针指向一个变量，二级指针则是指向一级指针的指针。基本格式：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> **p;<span class="comment">//type **pp;</span></span><br></pre></td></tr></table></figure><p> <code>p</code> 是一个二级指针， <code>p</code> 指向一个一级指针，该一级指针再指向一个整数。基本使用示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> *p = &amp;a;   <span class="comment">// 一级指针，指向整数变量a</span></span><br><span class="line">    <span class="type">int</span> **pp = &amp;p; <span class="comment">// 二级指针，指向指针变量p</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a = %d\n&quot;</span>, a);          <span class="comment">// 输出：a = 10</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;*p = %d\n&quot;</span>, *p);        <span class="comment">// 输出：*p = 10</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;**pp = %d\n&quot;</span>, **pp);    <span class="comment">// 输出：**pp = 10</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="进阶使用方法："><a href="#进阶使用方法：" class="headerlink" title="进阶使用方法："></a>进阶使用方法：</h3><ol><li><p>二级指针的动态内存分配<br>二级指针常用于动态分配二维数组。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> rows = <span class="number">3</span>, cols = <span class="number">4</span>;</span><br><span class="line"><span class="type">int</span> **arr = (<span class="type">int</span> **)<span class="built_in">malloc</span>(rows * <span class="keyword">sizeof</span>(<span class="type">int</span> *));  </span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; rows; i++) &#123;</span><br><span class="line">    arr[i] = (<span class="type">int</span> *)<span class="built_in">malloc</span>(cols * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>二级指针作为函数参数<br>二级指针经常用于修改指针的指向，特别是在函数内部动态分配内存时。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">allocateMemory</span><span class="params">(<span class="type">int</span> **p, <span class="type">int</span> size)</span> &#123;</span><br><span class="line">    *p = (<span class="type">int</span> *)<span class="built_in">malloc</span>(size * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="特殊使用方法："><a href="#特殊使用方法：" class="headerlink" title="特殊使用方法："></a>特殊使用方法：</h3><ol><li><p>操作链表或树等复杂数据结构：以下是链表头插法，前者是错误的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">addNode</span><span class="params">(Node* <span class="built_in">list</span>, <span class="type">int</span> data)</span> &#123;</span><br><span class="line">    <span class="comment">// 动态分配一个结点</span></span><br><span class="line">    Node* newNode = (Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    <span class="keyword">if</span> (newNode == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Error: malloc failed in addNode\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 初始化结点</span></span><br><span class="line">    newNode-&gt;data = data;</span><br><span class="line">    <span class="comment">// 头插法</span></span><br><span class="line">    newNode-&gt;next = <span class="built_in">list</span>;</span><br><span class="line">    <span class="built_in">list</span> = newNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> <code>list</code> 是一个指向 <code>Node</code> 的指针，即一级指针。在函数内部修改<code>list</code>的值（ <code>list = newNode;</code> ）时，修改的是 <code>list</code> 复制的实体参数，并没有改变函数外部 <code>list</code> 指针的值。当函数执行完后，外部的链表并没有真正更新，新的节点也没有插入到链表中。函数的修改只对函数内部的<code>list</code>有效。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">addNode</span><span class="params">(Node** plist, <span class="type">int</span> data)</span> &#123;</span><br><span class="line">    <span class="comment">// 动态分配一个结点</span></span><br><span class="line">    Node* newNode = (Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    <span class="keyword">if</span> (newNode == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Error: malloc failed in addNode\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    newNode-&gt;data = data;</span><br><span class="line">    newNode-&gt;next = *plist;</span><br><span class="line">    *plist = newNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> <code>plist</code> 是一个二级指针（ <code>Node**</code> ），指向的是一级指针 <code>Node*</code> 的地址。虽然也是实体参数，但是解引用符号*，修改的是二级指针解引用后的一级指针地址，通过使用 <code>*plist</code> ，能够直接修改外部链表指针的值。在函数内部对 <code>*plist</code>  的修改会反映到函数外部。</p></li><li><p>处理多维数组</p><p>在处理高维数组时，二级指针及以上级别的指针可以方便地管理数组内存。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> depth = <span class="number">2</span>, rows = <span class="number">3</span>, cols = <span class="number">4</span>;</span><br><span class="line"><span class="type">int</span> ***arr = (<span class="type">int</span> ***)<span class="built_in">malloc</span>(depth * <span class="keyword">sizeof</span>(<span class="type">int</span> **));</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; depth; i++) &#123;</span><br><span class="line">    arr[i] = (<span class="type">int</span> **)<span class="built_in">malloc</span>(rows * <span class="keyword">sizeof</span>(<span class="type">int</span> *));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; rows; j++) &#123;</span><br><span class="line">        arr[i][j] = (<span class="type">int</span> *)<span class="built_in">malloc</span>(cols * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>指向字符串数组的指针</p><p>二级指针可以用于指向字符串数组，例如命令行参数 <code>argv</code> 。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; argc; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Argument %d: %s\n&quot;</span>, i, argv[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> <code>argv</code> 是一个指向字符串数组的指针，每个元素是一个字符串（即字符指针 <code>char *</code> ）。</p></li></ol><h2 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h2><h3 id="函数指针："><a href="#函数指针：" class="headerlink" title="函数指针："></a>函数指针：</h3><p>函数指针是指向函数的指针变量。通过函数指针，可以调用函数并传递参数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">返回类型 (*指针变量)(参数列表);</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> (*funcPtr)(<span class="type">int</span>, <span class="type">int</span>);</span><br><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line">funcPtr = add;</span><br><span class="line"><span class="type">int</span> result = funcPtr(<span class="number">2</span>, <span class="number">3</span>); <span class="comment">// 调用 add 函数，结果为 5</span></span><br></pre></td></tr></table></figure><h3 id="指针函数："><a href="#指针函数：" class="headerlink" title="指针函数："></a>指针函数：</h3><p>指针函数是返回值为指针类型的函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">返回类型* 函数名(参数列表);</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* <span class="title function_">getPointer</span><span class="params">(<span class="type">int</span>* p)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> value = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span>* ptr = getPointer(&amp;value); <span class="comment">// 返回指向 value 的指针</span></span><br></pre></td></tr></table></figure><h3 id="进阶内容"><a href="#进阶内容" class="headerlink" title="进阶内容"></a>进阶内容</h3><ul><li><p><strong>函数指针数组</strong>：可以定义一个函数指针数组，用来存储多个函数的地址。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> (*funcArr[<span class="number">2</span>])(<span class="type">int</span>, <span class="type">int</span>) = &#123;add, subtract&#125;;</span><br><span class="line"><span class="type">int</span> result1 = funcArr[<span class="number">0</span>](<span class="number">5</span>, <span class="number">3</span>); <span class="comment">// 调用 add 函数</span></span><br><span class="line"><span class="type">int</span> result2 = funcArr[<span class="number">1</span>](<span class="number">5</span>, <span class="number">3</span>); <span class="comment">// 调用 subtract 函数</span></span><br></pre></td></tr></table></figure></li><li><p><strong>回调函数</strong>：函数指针常用于实现回调机制，将函数作为参数传递给另一个函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">execute</span><span class="params">(<span class="type">int</span> (*func)(<span class="type">int</span>, <span class="type">int</span>), <span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Result: %d\n&quot;</span>, func(a, b));</span><br><span class="line">&#125;</span><br><span class="line">execute(add, <span class="number">2</span>, <span class="number">3</span>); <span class="comment">// 输出 Result: 5</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="特殊使用方法"><a href="#特殊使用方法" class="headerlink" title="特殊使用方法"></a>特殊使用方法</h3><ul><li><p><strong>返回函数指针的函数</strong>：可以定义一个返回函数指针的函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> (*getFunc(<span class="type">char</span> op))(<span class="type">int</span>, <span class="type">int</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (op == <span class="string">&#x27;+&#x27;</span>) <span class="keyword">return</span> add;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> subtract;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> (*func)(<span class="type">int</span>, <span class="type">int</span>) = getFunc(<span class="string">&#x27;+&#x27;</span>);</span><br><span class="line"><span class="type">int</span> result = func(<span class="number">10</span>, <span class="number">5</span>); <span class="comment">// 调用 add 函数，结果为 15</span></span><br></pre></td></tr></table></figure></li><li><p><strong>指向指针函数的指针</strong>：可以定义一个指向返回值为指针的函数的指针。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* (*funcPtr)(<span class="type">int</span>*);</span><br><span class="line">funcPtr = getPointer;</span><br><span class="line"><span class="type">int</span>* ptr = funcPtr(&amp;value); <span class="comment">// 返回指向 value 的指针</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="两者的对比"><a href="#两者的对比" class="headerlink" title="两者的对比"></a>两者的对比</h3><ul><li><strong>功能差异</strong>：<ul><li>函数指针主要用于引用和调用函数，常用于回调、函数表等场景。</li><li>指针函数主要用于返回指针类型的数据，常用于动态内存分配、链表操作等场景。</li></ul></li><li><strong>语法差异</strong>：<ul><li>函数指针的定义中，<code>*</code>和函数名在括号内，表示变量是一个指向函数的指针。</li><li>指针函数的定义中，<code>*</code>在返回类型之前，表示返回类型是指针。</li></ul></li></ul><h3 id="qsort-函数"><a href="#qsort-函数" class="headerlink" title="qsort 函数"></a><code>qsort</code> 函数</h3><p> <code>qsort</code> 声明在 <code>&lt;stdlib.h&gt;</code> 头文件中，是可以给任意数组排序的通用函数。数组的元素也可以是任意类型，甚至可以是结构体或者指针，但必须告诉 qsort 函数如何比较数组元素的大小。传入一个<strong>比较函数</strong>可以提供信息。</p><p> <code>qsort</code> 函数的原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">qsort</span><span class="params">(<span class="type">void</span>* base, <span class="type">size_t</span> nmemb, <span class="type">size_t</span> size, <span class="type">int</span> (*compar)(<span class="type">const</span> <span class="type">void</span> *, <span class="type">const</span> <span class="type">void</span> *))</span>;</span><br></pre></td></tr></table></figure><ul><li><p><code>base</code> 指向数组中要排序的第一个元素 (一般是数组的第一个元素)。</p></li><li><p><code>nmemb</code> 是要排序元素的数量 (可以小于或等于数组中元素的个数)。</p></li><li><p><code>size</code> 表示数组元素的大小。</p></li><li><p><code>compar</code> 是比较函数，第一个参数比第二个参数小则返回负数，相等则返回零，第一个参数大于第二个参数则返回正数。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> C </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C_排序与查找</title>
      <link href="/Language/C/C_%E6%8E%92%E5%BA%8F%E4%B8%8E%E6%9F%A5%E6%89%BE"/>
      <url>/Language/C/C_%E6%8E%92%E5%BA%8F%E4%B8%8E%E6%9F%A5%E6%89%BE</url>
      
        <content type="html"><![CDATA[<h1 id="C-排序与查找"><a href="#C-排序与查找" class="headerlink" title="C_排序与查找"></a>C_排序与查找</h1><p>排序的前提是”比较”，排序的目的往往是”查找”。</p><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><h3 id="评估排序算法"><a href="#评估排序算法" class="headerlink" title="评估排序算法"></a>评估排序算法</h3><h4 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><ul><li><strong>最坏时间复杂度</strong>：在最不利的情况下，算法执行的时间。通常使用大O符号表示，如O(n²)、O(n log n)等。</li><li><strong>平均时间复杂度</strong>：算法在随机数据情况下的平均执行时间。通常作为衡量算法效率的主要指标。</li><li><strong>最好时间复杂度</strong>：在最理想情况下的执行时间，例如，当数组已排序时，算法的复杂度可能更低。</li></ul><h4 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h4><ul><li><strong>原地排序</strong>：算法是否需要额外的空间来完成排序，影响空间复杂度。</li><li><strong>辅助空间</strong>：需要额外的存储空间进行辅助处理。</li></ul><h4 id="稳定性"><a href="#稳定性" class="headerlink" title="稳定性"></a>稳定性</h4><ul><li><p><strong>稳定排序</strong>：两个元素相等，它们在排序后的顺序与排序前相同，称为稳定排序。</p><p><strong>稳定排序算法</strong>：冒泡排序、插入排序、归并排序、计数排序、基数排序。</p><p><strong>不稳定排序算法</strong>：选择排序、快速排序、堆排序。</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/Barbecue-g/imagehost/Language/C/C_%E6%8E%92%E5%BA%8F%E4%B8%8E%E6%9F%A5%E6%89%BE/%E6%8E%92%E5%BA%8F.png" alt="排序算法"></p><h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><h4 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h4><h5 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h5><p>构建有序序列。对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。（类似扑克牌）</p><p>具体步骤如下：</p><ul><li>从数组的第二个元素开始（第一个元素默认是有序的）。</li><li>将当前元素与前面已经排好序的元素进行比较，找到适当的位置插入。</li><li>重复以上步骤，直到整个数组有序。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Barbecue-g/imagehost/Language/C/C_%E6%8E%92%E5%BA%8F%E4%B8%8E%E6%9F%A5%E6%89%BE/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F.png" alt="插入排序"></p><h5 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">qvoid <span class="title function_">insertionSort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> n)</span> &#123;  </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;<span class="comment">// 从数组的第二个元素开始处理</span></span><br><span class="line">        <span class="type">int</span> key = arr[i];  <span class="comment">// 当前需要插入的元素</span></span><br><span class="line">        <span class="type">int</span> j = i - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; arr[j] &gt; key) &#123;<span class="comment">// 将前面已经排好序的元素与key比较，找到插入位置</span></span><br><span class="line">            arr[j + <span class="number">1</span>] = arr[j];  <span class="comment">// 将大于key的元素向后移</span></span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[j + <span class="number">1</span>] = key;  <span class="comment">// 在找到的位置插入key</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h5><ol><li><p><strong>时间复杂度</strong></p><ul><li>最优时间复杂度：**O(n)**。当输入数组已经有序时，只需要逐个扫描，每次比较一次即可。</li><li>最坏时间复杂度：**O(n²)**：当输入数组是逆序排列时，每插入一个元素，都需要将已排序部分的所有元素向右移动，比较次数和移动次数都达到最大，时间复杂度为 <code>O(n²)</code> 。</li><li>平均时间复杂度：**O(n²)**：在随机排列的数组中，插入排序的平均时间复杂度也是 <code>O(n²)</code> 。</li></ul></li><li><p>空间复杂度：**O(1)**。插入排序只需要常量级的额外空间用于临时存储key变量。</p></li><li><p>稳定性：<strong>稳定</strong>。相等元素在排序过程中不会交换顺序。</p></li></ol><h4 id="折半排序"><a href="#折半排序" class="headerlink" title="折半排序"></a>折半排序</h4><h5 id="算法思想-1"><a href="#算法思想-1" class="headerlink" title="算法思想"></a>算法思想</h5><p>折半排序算法是<strong>插入排序算法</strong>的一种改进。通常，插入排序在插入新元素时需要从头到尾进行线性搜索，找到适当的位置。而<strong>折半插入排序</strong>通过在已排序的序列中使用<strong>二分查找</strong>（也称折半查找）来确定插入位置，从而减少比较次数。</p><p>折半插入排序的基本步骤如下：</p><ul><li><strong>排序过程</strong>与插入排序相似：依次将每个元素插入到前面已经排好序的子数组中。</li><li><strong>查找插入位置</strong>时使用二分查找法来代替逐一比较，从而减少查找的时间复杂度。</li></ul><h5 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">binaryInsertionSort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="type">int</span> key = arr[i];  <span class="comment">// 待插入的元素</span></span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = i - <span class="number">1</span>;   </span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;<span class="comment">// 二分查找插入位置</span></span><br><span class="line">            <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (arr[mid] &gt; key)</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i - <span class="number">1</span>; j &gt;= left; j--) &#123;<span class="comment">// 移动元素以腾出位置</span></span><br><span class="line">            arr[j + <span class="number">1</span>] = arr[j];</span><br><span class="line">        &#125;       </span><br><span class="line">        arr[left] = key; <span class="comment">// 插入元素</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="算法分析-1"><a href="#算法分析-1" class="headerlink" title="算法分析"></a>算法分析</h5><ol><li><p><strong>时间复杂度</strong></p><ul><li>最优时间复杂度：**O(n)**。当输入数组已经有序时，只需要找到正确位置而无需移动，查找时间为 <code>O(logn)</code>，但由于元素移动的过程仍然是线性的，所以最好的时间复杂度仍然是 <code>O(n²)</code>。虽然折半插入排序减少了比较次数，但由于元素插入时需要移动数据，其时间复杂度并没有降低太多。</li><li>最坏时间复杂度：**O(n²)**：当输入数组是逆序排列时，需要每次都将新元素插入到最前面，此时查找的复杂度为 <code>O(logn)</code>，但移动元素的复杂度为 <code>O(n)</code>，最坏的时间复杂度仍然是 <code>O(n²)</code>。</li><li>平均时间复杂度：**O(n²)**：查找和移动元素的综合开销不会大幅减少。</li></ul></li><li><p>空间复杂度：**O(1)**。插入排序只需要常量级的额外空间用于临时存储key变量。</p></li><li><p>稳定性：<strong>稳定</strong>。相等元素在排序过程中不会交换顺序。</p></li></ol><h4 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h4><h5 id="算法思想-2"><a href="#算法思想-2" class="headerlink" title="算法思想"></a>算法思想</h5><p>希尔排序（Shell Sort）是插入排序的一种优化版本，旨在减少数据移动次数来提高排序效率。希尔排序通过引入“<strong>增量分组</strong>”的方式，对原数组进行分组，使每组内部进行插入排序。随着增量的不断缩小，分组越来越少，直到增量缩小为1时，整个数组变为有序。</p><p>希尔排序的关键是<strong>增量序列</strong>的选择，常用的增量序列是<code>n/2, n/4, ..., 1</code>，即每次将间隔减半。</p><p><img src="https://cdn.jsdelivr.net/gh/Barbecue-g/imagehost/Language/C/C_%E6%8E%92%E5%BA%8F%E4%B8%8E%E6%9F%A5%E6%89%BE/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F.png" alt="希尔排序"></p><h5 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">shellSort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> gap = n / <span class="number">2</span>; gap &gt; <span class="number">0</span>; gap /= <span class="number">2</span>) &#123;<span class="comment">// 初始间隔 gap 设为数组长度的一半，然后每次减半</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = gap; i &lt; n; i++) &#123;<span class="comment">// 从 gap 开始逐步对每个子序列进行插入排序</span></span><br><span class="line">            <span class="type">int</span> temp = arr[i];  <span class="comment">// 保存当前元素</span></span><br><span class="line">            <span class="type">int</span> j;</span><br><span class="line">            <span class="keyword">for</span> (j = i; j &gt;= gap &amp;&amp; arr[j - gap] &gt; temp; j -= gap) &#123;<span class="comment">//将 arr[i] 插入到子序列中</span></span><br><span class="line">                arr[j] = arr[j - gap];  <span class="comment">// 将较大的元素后移</span></span><br><span class="line">            &#125;</span><br><span class="line">            arr[j] = temp;  <span class="comment">// 将当前元素放入正确位置</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="算法分析-2"><a href="#算法分析-2" class="headerlink" title="算法分析"></a>算法分析</h5><ol><li>时间复杂度：希尔排序的时间复杂度与增量序列的选择有关。常见的增量序列为 <code>n/2</code>, <code>n/4</code>, …, <code>1</code>。<ul><li><strong>最优情况：</strong> **O(nlogn)**。实际运行中常显著优于插入排序。</li><li><strong>最坏情况：</strong> **O(n²)**。使用更优化的增量序列（如Hibbard增量序列）时，最坏时间复杂度可以降低到 <code>O(n^3/2)</code> 或更低。</li><li><strong>平均时间复杂度：</strong> **O(n^1.3)**，具体取决于增量序列的选择。</li></ul></li><li>空间复杂度：<strong>O(1)<strong>。希尔排序是</strong>原地排序算法</strong>，不需要额外的存储空间。</li><li>稳定性：<strong>不稳定</strong>。相同元素在不同的增量分组时可能会被打乱其相对顺序。</li></ol><h3 id="交换排序"><a href="#交换排序" class="headerlink" title="交换排序"></a>交换排序</h3><h4 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h4><h5 id="算法思想-3"><a href="#算法思想-3" class="headerlink" title="算法思想"></a>算法思想</h5><p>通过多次遍历待排序的数组，每一轮比较相邻的两个元素，将较大的元素逐步“冒泡”到数组的末尾。整个过程重复进行，直到所有元素按从小到大的顺序排列。</p><p>具体步骤如下：</p><ul><li>从第一个元素开始，比较相邻的两个元素。</li><li>如果前一个元素比后一个大，则交换两者的位置。</li><li>每一轮遍历后，最大元素会移动到数组末尾。</li><li>重复上述步骤，直到所有元素有序。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Barbecue-g/imagehost/Language/C/C_%E6%8E%92%E5%BA%8F%E4%B8%8E%E6%9F%A5%E6%89%BE/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F.png" alt="冒泡排序"></p><h5 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">bubbleSort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> n)</span> &#123; </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;<span class="comment">// 外层循环控制遍历的轮数       </span></span><br><span class="line">        <span class="type">int</span> swapped = <span class="number">0</span>;<span class="comment">// 标志变量，检测本轮是否有元素交换</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n - i - <span class="number">1</span>; j++) &#123;<span class="comment">// 内层循环比较相邻元素并交换</span></span><br><span class="line">            <span class="comment">// 如果前一个元素比后一个大，则交换</span></span><br><span class="line">            <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="type">int</span> temp = arr[j];</span><br><span class="line">                arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">                arr[j + <span class="number">1</span>] = temp;     </span><br><span class="line">                swapped = <span class="number">1</span>;<span class="comment">// 标记有元素发生交换</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (swapped == <span class="number">0</span>) &#123;<span class="comment">// 如果没有发生交换，说明数组已排序，提前结束</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="算法分析-3"><a href="#算法分析-3" class="headerlink" title="算法分析"></a>算法分析</h5><ol><li>时间复杂度：<ul><li><strong>最优情况（已排序的数组）：</strong> **O(n)**。数组本身就是有序的，冒泡排序只需进行一轮比较，无需交换。</li><li><strong>最坏情况（逆序数组）：</strong> **O(n²)**。在数组完全逆序的情况下，算法需要进行 <code>n-1</code> 轮排序，每轮排序需要 <code>n-1-i</code> 次比较和交换</li><li><strong>平均时间复杂度：</strong> **O(n²)**。大部分排序情况都需要多轮比较和交换。在没有特殊信息的情况下，平均情况下冒泡排序的时间复杂度仍为O(n²)。</li></ul></li><li>空间复杂度：<strong>O(1)<strong>。冒泡排序是</strong>原地排序算法</strong>，不需要额外的存储空间。</li><li>稳定性：<strong>稳定</strong>。相等元素在排序过程中不会交换顺序。</li></ol><h4 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h4><h5 id="算法思想-4"><a href="#算法思想-4" class="headerlink" title="算法思想"></a>算法思想</h5><p>快速排序（Quicksort）是一种<strong>分治法</strong>排序算法。其基本思想是：</p><ol><li>选择一个<strong>基准元素</strong>（Pivot），可以是数组的第一个元素、中间元素或随机选择。</li><li>将数组划分成两部分：<ul><li><strong>左部分</strong>包含所有小于基准元素的数；</li><li><strong>右部分</strong>包含所有大于基准元素的数。</li></ul></li><li>对左、右两部分递归地进行快速排序。</li><li>合并结果，即可得到一个有序数组。</li></ol><p><strong>关键步骤：</strong></p><ul><li>分区（Partition）：每次根据基准元素将数组分为两部分。</li><li>递归（Recursion）：对左右子数组分别进行快速排序。</li></ul><p><img src="https://github.com/Barbecue-g/Imagehost/blob/master/Language/C/C_%E6%8E%92%E5%BA%8F%E4%B8%8E%E6%9F%A5%E6%89%BE/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F.png?raw=true" alt="快速排序"></p><h5 id="代码实现-4"><a href="#代码实现-4" class="headerlink" title="代码实现"></a>代码实现</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 快速排序的分区函数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">partition</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> low, <span class="type">int</span> high)</span> &#123;</span><br><span class="line">    <span class="type">int</span> pivot = arr[high];  <span class="comment">// 选择最右边元素作为基准</span></span><br><span class="line">    <span class="type">int</span> i = low - <span class="number">1</span>;  <span class="comment">// i 是小于 pivot 的元素的索引</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = low; j &lt; high; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[j] &lt; pivot) &#123;  <span class="comment">// 若当前元素小于基准</span></span><br><span class="line">            i++;  <span class="comment">// 增加小于 pivot 区域的索引</span></span><br><span class="line">            <span class="comment">// 交换 arr[i] 和 arr[j]</span></span><br><span class="line">            <span class="type">int</span> temp = arr[i];</span><br><span class="line">            arr[i] = arr[j];</span><br><span class="line">            arr[j] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将基准元素放到正确的位置</span></span><br><span class="line">    <span class="type">int</span> temp = arr[i + <span class="number">1</span>];</span><br><span class="line">    arr[i + <span class="number">1</span>] = arr[high];</span><br><span class="line">    arr[high] = temp;</span><br><span class="line">    <span class="keyword">return</span> i + <span class="number">1</span>;  <span class="comment">// 返回基准的最终位置</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 快速排序函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">quickSort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> low, <span class="type">int</span> high)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (low &lt; high) &#123;       </span><br><span class="line">        <span class="type">int</span> pi = partition(arr, low, high);<span class="comment">// 获取分区位置     </span></span><br><span class="line">        quickSort(arr, low, pi - <span class="number">1</span>);<span class="comment">// 递归排序左半部分</span></span><br><span class="line">        quickSort(arr, pi + <span class="number">1</span>, high);<span class="comment">// 递归排序右半部分</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="算法分析-4"><a href="#算法分析-4" class="headerlink" title="算法分析"></a>算法分析</h5><ol><li>时间复杂度：<ul><li><strong>最优情况：</strong> **O(nlogn)**。每次划分正好将数组一分为二。</li><li><strong>最坏情况：</strong> **O(n²)**。每次划分不平衡（如每次选择的基准恰好是数组的最大或最小值）</li><li><strong>平均时间复杂度：</strong> **O(nlogn)**。其中 <code>n</code> 是数组的元素个数，<code>logn</code> 是递归调用的层数。</li></ul></li><li>空间复杂度：<strong>O(nlogn)<strong>。快速排序是</strong>原地排序算法</strong>，递归调用栈的深度为 <code>logn</code>。最坏情况下，递归深度为 <code>O(n)</code>，最坏空间复杂度为 **O(n)**。</li><li>稳定性：<strong>不稳定</strong>。在划分过程中，可能会交换相同元素的相对位置。</li></ol><h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><h4 id="简单选择排序"><a href="#简单选择排序" class="headerlink" title="简单选择排序"></a>简单选择排序</h4><h5 id="算法思想-5"><a href="#算法思想-5" class="headerlink" title="算法思想"></a>算法思想</h5><p>在未排序的序列中找到最小（或最大）的元素，将其放到序列的起始位置。然后，继续在剩余未排序的序列中重复该操作，直到整个序列有序。</p><p>具体步骤如下：</p><p>​1.从未排序的部分中选择最小的元素。</p><p>​2.将该元素与未排序部分的第一个元素交换位置。</p><p>​3.重复上述过程，直到所有元素排序完毕。</p><p><img src="https://cdn.jsdelivr.net/gh/Barbecue-g/imagehost/Language/C/C_%E6%8E%92%E5%BA%8F%E4%B8%8E%E6%9F%A5%E6%89%BE/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F.png" alt="选择排序"></p><h5 id="代码实现-5"><a href="#代码实现-5" class="headerlink" title="代码实现"></a>代码实现</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">selectionSort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i, j, minIdx, temp;    </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;<span class="comment">// 遍历数组中的每一个元素</span></span><br><span class="line">        minIdx = i;<span class="comment">// 假设当前i位置的元素是未排序部分中的最小值   </span></span><br><span class="line">        <span class="keyword">for</span> (j = i + <span class="number">1</span>; j &lt; n; j++) &#123;<span class="comment">// 在未排序的部分中寻找最小值</span></span><br><span class="line">            <span class="keyword">if</span> (arr[j] &lt; arr[minIdx]) &#123;</span><br><span class="line">                minIdx = j;  <span class="comment">// 记录最小值的索引</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">if</span> (minIdx != i) &#123;<span class="comment">// 如果找到的最小值不是当前i位置的元素，则交换</span></span><br><span class="line">            <span class="comment">// 交换 arr[i] 和 arr[minIdx]</span></span><br><span class="line">            temp = arr[i];</span><br><span class="line">            arr[i] = arr[minIdx];</span><br><span class="line">            arr[minIdx] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="算法分析-5"><a href="#算法分析-5" class="headerlink" title="算法分析"></a>算法分析</h5><ol><li>时间复杂度：<ul><li><strong>最优情况（已排序的数组）：</strong> **O(n²)**。选择排序每次都需要遍历未排序部分的元素 ，最好情况也需要执行 <code>n</code> 次选择操作，每次操作时间为 O(n-i) 次比较</li><li><strong>最坏情况（逆序数组）：</strong> **O(n²)**。无论数据原始顺序如何，算法都需要遍历每一个元素。</li><li><strong>平均时间复杂度：</strong> **O(n²)**。由于选择排序与输入的顺序无关，每次都要遍历未排序部分。</li></ul></li><li>空间复杂度：<strong>O(nlogn)<strong>。选择排序是</strong>原地排序</strong>算法，只需要常量级的额外空间来存储临时变量（用于交换）。</li><li>稳定性：<strong>不稳定</strong>。选择排序在选择最小元素并交换时，可能会破坏原本的相对顺序。</li></ol><h4 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h4><h5 id="算法思想-6"><a href="#算法思想-6" class="headerlink" title="算法思想"></a>算法思想</h5><p>堆排序是一种基于<strong>二叉堆</strong>的数据结构的排序算法。堆是一种特殊的完全二叉树，可以分为<strong>最大堆</strong>和<strong>最小堆</strong>。在最大堆中，父节点的值总是大于等于其子节点的值；在最小堆中，父节点的值总是小于等于其子节点的值。</p><p>堆排序的基本思想是：</p><p>​1.<strong>构建最大堆</strong>：将无序数组调整为最大堆，使得堆顶元素（即根节点）为整个数组的最大值。</p><p>​2.<strong>交换堆顶元素和末尾元素</strong>：将堆顶元素（最大值）与堆的最后一个元素交换，最大元素就位于数组的最后，并从堆中移除。</p><p>​3.<strong>调整堆</strong>：对剩余的元素进行堆调整，重复上述步骤，直到所有元素有序。</p><h5 id="代码实现-6"><a href="#代码实现-6" class="headerlink" title="代码实现"></a>代码实现</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 堆调整函数：调整以 i 为根节点的子树，使其满足最大堆的性质</span></span><br><span class="line"><span class="comment">// n 是数组的长度，i 是当前根节点的索引</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">heapify</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> n, <span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="type">int</span> largest = i;     <span class="comment">// 初始化 largest 为根节点 i</span></span><br><span class="line">    <span class="type">int</span> left = <span class="number">2</span> * i + <span class="number">1</span>; <span class="comment">// 左子节点索引</span></span><br><span class="line">    <span class="type">int</span> right = <span class="number">2</span> * i + <span class="number">2</span>; <span class="comment">// 右子节点索引</span></span><br><span class="line">    <span class="comment">// 如果左子节点存在且大于根节点</span></span><br><span class="line">    <span class="keyword">if</span> (left &lt; n &amp;&amp; arr[left] &gt; arr[largest])</span><br><span class="line">        largest = left;</span><br><span class="line">    <span class="comment">// 如果右子节点存在且大于当前 largest</span></span><br><span class="line">    <span class="keyword">if</span> (right &lt; n &amp;&amp; arr[right] &gt; arr[largest])</span><br><span class="line">        largest = right;</span><br><span class="line">    <span class="comment">// 如果 largest 不是根节点</span></span><br><span class="line">    <span class="keyword">if</span> (largest != i) &#123;</span><br><span class="line">        <span class="comment">// 交换根节点和最大值节点</span></span><br><span class="line">        <span class="type">int</span> temp = arr[i];</span><br><span class="line">        arr[i] = arr[largest];</span><br><span class="line">        arr[largest] = temp;</span><br><span class="line">        <span class="comment">// 递归调整子树</span></span><br><span class="line">        heapify(arr, n, largest);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 堆排序函数：对数组 arr 进行堆排序</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">heapSort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="comment">// 构建最大堆</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        heapify(arr, n, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 逐步将堆顶元素（最大值）移动到数组末尾</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="comment">// 将堆顶元素与当前未排序部分的最后一个元素交换</span></span><br><span class="line">        <span class="type">int</span> temp = arr[<span class="number">0</span>];</span><br><span class="line">        arr[<span class="number">0</span>] = arr[i];</span><br><span class="line">        arr[i] = temp;</span><br><span class="line">        <span class="comment">// 调整剩余元素形成新的最大堆</span></span><br><span class="line">        heapify(arr, i, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="算法分析-6"><a href="#算法分析-6" class="headerlink" title="算法分析"></a>算法分析</h5><ul><li><strong>构建堆</strong>：构建最大堆的过程需要遍历所有非叶子节点，对每个节点进行堆调整。调整一个节点的时间复杂度为 <code>O(logn)</code>，总的构建堆时间复杂度为 <code>O(n)</code>。</li><li><strong>排序过程</strong>：在堆排序过程中，每次取出堆顶元素（最大值），然后对剩余的元素进行堆调整，整个排序过程需要进行 <code>n-1</code> 次堆调整，每次调整的时间复杂度为 <code>O(logn)</code>，总的排序时间复杂度为 <code>O(nlogn)</code>。</li></ul><ol><li><p>时间复杂度：</p><ul><li><p><strong>最坏情况：<code>O(nlogn)</code></strong></p></li><li><p><strong>平均情况：<code>O(nlogn)</code></strong></p></li><li><p><strong>最好情况：<code>O(nlogn)</code></strong></p></li></ul></li><li><p>空间复杂度：**O(1)**。 堆排序在排序过程中只需要常数级别的额外空间来进行交换操作和递归调用。</p></li><li><p>稳定性： <strong>不稳定</strong>。在堆调整过程中，元素之间的相对顺序可能会被改变。当父节点和子节点交换时，原本相同的两个元素可能会被打乱顺序。</p></li></ol><h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><h4 id="算法思想-7"><a href="#算法思想-7" class="headerlink" title="算法思想"></a>算法思想</h4><p>归并排序（Merge Sort）是一种<strong>分治算法</strong>。其核心思想是将待排序数组递归地<strong>分成两半</strong>，分别对左右两部分进行排序，最后将两部分<strong>合并</strong>成一个有序数组。</p><p><strong>分治步骤</strong>：</p><pre><code> 1.**分**：将数组递归地分成两半，直到每个子数组只包含一个元素（此时认为子数组是有序的）。 2.**治**：将两个有序的子数组合并成一个有序数组。 3.**合并**：将小问题合并成大问题，最终将整个数组合并为一个有序数组。</code></pre><p>归并排序的核心步骤是合并两个有序数组，过程是线性时间的。</p><p><img src="https://cdn.jsdelivr.net/gh/Barbecue-g/imagehost/Language/C/C_%E6%8E%92%E5%BA%8F%E4%B8%8E%E6%9F%A5%E6%89%BE/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F.png" alt="归并排序"></p><h4 id="代码实现-7"><a href="#代码实现-7" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 归并函数，将两个有序的子数组合并为一个有序数组</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> left, <span class="type">int</span> mid, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">    <span class="type">int</span> n1 = mid - left + <span class="number">1</span>;  <span class="comment">// 左边子数组的大小</span></span><br><span class="line">    <span class="type">int</span> n2 = right - mid;     <span class="comment">// 右边子数组的大小</span></span><br><span class="line">    <span class="comment">// 创建临时数组存储左右两部分</span></span><br><span class="line">    <span class="type">int</span> L[n1], R[n2];</span><br><span class="line">    <span class="comment">// 将数据复制到临时数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n1; i++)</span><br><span class="line">        L[i] = arr[left + i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n2; i++)</span><br><span class="line">        R[i] = arr[mid + <span class="number">1</span> + i];</span><br><span class="line">    <span class="comment">// 合并两个临时数组</span></span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>, k = left;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; n1 &amp;&amp; j &lt; n2) &#123;</span><br><span class="line">        <span class="keyword">if</span> (L[i] &lt;= R[j]) &#123;  <span class="comment">// 保证稳定性：左边元素 &lt;= 右边元素</span></span><br><span class="line">            arr[k] = L[i];</span><br><span class="line">            i++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            arr[k] = R[j];</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        k++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果左边还有剩余元素，直接复制</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt; n1) &#123;</span><br><span class="line">        arr[k] = L[i];</span><br><span class="line">        i++;</span><br><span class="line">        k++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果右边还有剩余元素，直接复制</span></span><br><span class="line">    <span class="keyword">while</span> (j &lt; n2) &#123;</span><br><span class="line">        arr[k] = R[j];</span><br><span class="line">        j++;</span><br><span class="line">        k++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 归并排序的递归函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">mergeSort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;  <span class="comment">// 计算中间点</span></span><br><span class="line">        <span class="comment">// 递归地对左右两部分进行排序</span></span><br><span class="line">        mergeSort(arr, left, mid);</span><br><span class="line">        mergeSort(arr, mid + <span class="number">1</span>, right);</span><br><span class="line">        <span class="comment">// 合并已排好序的两部分</span></span><br><span class="line">        merge(arr, left, mid, right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="算法分析-7"><a href="#算法分析-7" class="headerlink" title="算法分析"></a>算法分析</h4><ul><li><p>归并排序在最优、最坏和平均情况下的时间复杂度都是 **<code>O(nlog n)</code>**。其中 <code>n</code> 是数组的长度，<code>logn</code> 是由于递归分割数组的过程，<code>n</code> 是合并两个有序子数组的时间。</p><p>时间复杂度分析：</p><ul><li>归并排序的每一次分解步骤，都会将数组对半划分，整个过程为 <strong><code>O(log n)</code></strong>  次。</li><li>在每次划分后的合并步骤中，需要花费 <strong><code>O(n)</code></strong> 的时间来合并两个有序子数组。</li><li>总时间复杂度为 <code>O(nlogn)</code>。</li></ul></li></ul><ol><li><p>时间复杂度：</p><ul><li><p><strong>最坏情况：<code>O(nlogn)</code></strong></p></li><li><p><strong>平均情况：<code>O(nlogn)</code></strong></p></li><li><p><strong>最好情况：<code>O(nlogn)</code></strong></p></li></ul></li><li><p>空间复杂度：**O(n)**。归并排序的空间复杂度主要来自递归调用栈以及临时数组。每次递归调用会使用 <code>O(logn)</code> 的栈空间，而临时数组则需要 <code>O(n)</code> 的额外空间来存储子数组。</p></li><li><p>稳定性：<strong>稳定</strong>。排序时相等元素的相对位置不会改变。若两个元素相等，会优先将左边的元素放入结果数组。</p></li></ol><h3 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h3><h4 id="算法思想-8"><a href="#算法思想-8" class="headerlink" title="算法思想"></a>算法思想</h4><p>基数排序是一种非比较排序算法，基于“位”的思想来排序。它适合用于对整数或字符串等结构较为固定的对象进行排序。该算法的核心思想是将数据拆分成多个部分（如个位、十位、百位等），逐步对每一部分进行排序，最终得到有序的数据序列。基数排序有两种方式：</p><ul><li><p><strong>LSD（Least Significant Digit）</strong>：从最低位开始排序（常用于排序数字）。</p></li><li><p><strong>MSD（Most Significant Digit）</strong>：从最高位开始排序（常用于排序字符串等）。</p></li></ul><p>主要步骤如下：</p><ol><li>将数据按位（从最低位到最高位）进行分配。找出待排序数组中最大元素的位数。</li><li>从最低位开始，对数组元素按位排序，使用稳定的排序算法（如计数排序或桶排序）对各个位上的数进行排序。</li><li>重复步骤2，直到最高位也排序完毕。</li></ol><p>基数排序的特点是，<strong>每一位上的排序必须是稳定的</strong>，才能保证排序的正确性。</p><h4 id="代码实现-8"><a href="#代码实现-8" class="headerlink" title="代码实现"></a>代码实现</h4><p>假设整数的范围是0到999，并且使用<strong>计数排序</strong>作为每一位的排序方法。主要包含核心的<code>radixSort</code>和辅助的计数排序<code>countSort</code>函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取数组中的最大值</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">getMax</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> max = arr[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] &gt; max) &#123;</span><br><span class="line">            max = arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 按照当前位数进行计数排序，exp 是对应的位数（1表示个位，10表示十位，依次类推）</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">countingSort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> n, <span class="type">int</span> <span class="built_in">exp</span>)</span> &#123;</span><br><span class="line">    <span class="type">int</span> output[n];  <span class="comment">// 输出数组</span></span><br><span class="line">    <span class="type">int</span> count[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;;  <span class="comment">// 计数数组，用来存储每个桶中的元素个数</span></span><br><span class="line">    <span class="comment">// 计算当前位数的出现次数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="type">int</span> digit = (arr[i] / <span class="built_in">exp</span>) % <span class="number">10</span>;</span><br><span class="line">        count[digit]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 修改计数数组，使其包含当前位数的正确位置</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        count[i] += count[i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 从后向前遍历数组，确保计数排序是稳定的</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="type">int</span> digit = (arr[i] / <span class="built_in">exp</span>) % <span class="number">10</span>;</span><br><span class="line">        output[count[digit] - <span class="number">1</span>] = arr[i];</span><br><span class="line">        count[digit]--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将排序结果复制回原数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        arr[i] = output[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 基数排序主函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">radixSort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="comment">// 找到数组中的最大数，以确定最大位数</span></span><br><span class="line">    <span class="type">int</span> max = getMax(arr, n);</span><br><span class="line">    <span class="comment">// 从个位开始，逐位对数组进行排序</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="built_in">exp</span> = <span class="number">1</span>; max / <span class="built_in">exp</span> &gt; <span class="number">0</span>; <span class="built_in">exp</span> *= <span class="number">10</span>) &#123;</span><br><span class="line">        countingSort(arr, n, <span class="built_in">exp</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="算法分析-8"><a href="#算法分析-8" class="headerlink" title="算法分析"></a>算法分析</h4><p>设数组中元素的最大值为<code>M</code>，数组的长度为<code>n</code>。最大值<code>M</code>的位数为<code>d</code>，每一位使用计数排序，其复杂度为<code>O(n + k)</code>，其中<code>k</code>为计数排序的范围（对10个数字的计数排序，<code>k=10</code>）。总时间复杂度为 <code>O(d*(n + k))</code> ，当<code>k</code>为常数时，复杂度为 <code>O(d*n)</code> 。</p><ul><li>对于整数来说，<code>d</code>通常较小，可以认为<code>d</code>为常数，基数排序的时间复杂度为**O(n)**。</li><li>元素范围较大，例如需要排序非常大的数字， <code>d</code> 会增大，算法的时间复杂度也会相应提高。</li></ul><ol><li><p>时间复杂度：</p><ul><li><p><strong>最坏情况：<code>O(n)</code></strong></p></li><li><p><strong>平均情况：<code>O(n)</code></strong></p></li><li><p><strong>最好情况：<code>O(n)</code></strong></p></li></ul></li><li><p>空间复杂度：**O(n+k)**。其中 <code>n</code> 是待排序元素的个数，<code>k</code> 是计数排序的桶数量。在本算法中，计数排序的桶数量是 <code>10</code>（对应十进制数的个位、十位、百位等），即线性空间复杂度。</p></li><li><p>稳定性：<strong>稳定</strong>。特别是在每一位的排序中使用稳定的排序算法（如计数排序）时，可以保证两个相同元素在排序前后的相对顺序不变。</p></li></ol><h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><h3 id="评估查找算法"><a href="#评估查找算法" class="headerlink" title="评估查找算法"></a>评估查找算法</h3><h4 id="时间复杂度-1"><a href="#时间复杂度-1" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><ul><li><strong>最坏情况时间复杂度</strong>：算法在最坏情况下的运行时间。例如，线性查找在最坏情况下需要 O(n)，而二分查找的最坏情况是 O(log n)。</li><li><strong>平均情况时间复杂度</strong>：评估算法在不同输入条件下的平均表现。平均情况下的算法性能。例如，哈希查找在没有冲突时，平均复杂度为 O(1)，而在发生冲突时复杂度升高。</li><li><strong>最优情况时间复杂度</strong>：算法在最理想的情况下的性能。例如，在二分查找中，若目标元素恰好是数组的中间值，查找时间为 O(1)。</li></ul><h4 id="空间复杂度-1"><a href="#空间复杂度-1" class="headerlink" title="空间复杂度"></a>空间复杂度</h4><ul><li><strong>额外空间需求</strong>：是否需要额外空间进行数据存储或处理。例如，线性查找不需要额外空间，复杂度为 O(1)，而哈希查找需要额外的空间来存储哈希表。</li><li><strong>辅助数据结构</strong>：某些查找算法依赖额外的数据结构，比如跳表或哈希表，需要额外的内存空间来存储索引或哈希值。</li></ul><h4 id="前提条件"><a href="#前提条件" class="headerlink" title="前提条件"></a>前提条件</h4><ul><li><strong>有序数据</strong>：算法是否需要数据有序，如二分查找，要求数据必须是已排序的。</li><li><strong>数据结构</strong>：不同查找算法适用于不同的数据结构。例如，哈希查找适用于哈希表，二分查找适用于有序数组，广度优先搜索（BFS）适用于图。</li><li><strong>动态数据集</strong>：某些查找算法更适合处理动态数据集，如跳表和哈希查找，而二分查找适用于静态有序数组。</li></ul><h4 id="鲁棒性"><a href="#鲁棒性" class="headerlink" title="鲁棒性"></a>鲁棒性</h4><ul><li><strong>最坏情况表现</strong>：算法在最坏情况下的效率。例如，哈希查找在最坏情况下退化到 O(n)（当哈希冲突严重时），而二分查找始终保持 O(log n)。</li><li><strong>容错能力</strong>：查找算法是否对异常输入（如空数组、数据不匹配）做了合理处理，防止崩溃或出错。</li><li><strong>抗数据分布能力</strong>：部分查找算法对数据分布较为敏感，如插值查找对均匀分布数据表现好，但对于不均匀分布的数据，性能下降明显。</li></ul><h4 id="稳定性-1"><a href="#稳定性-1" class="headerlink" title="稳定性"></a>稳定性</h4><ul><li><strong>动态数据处理能力</strong>：某些查找算法需要在数据动态变化时仍保持高效。例如，跳表在数据插入、删除时能保持较好的查找性能，时间复杂度是 O(log n)。</li><li><strong>重复元素的处理</strong>：查找算法是否能正确处理重复元素，如线性查找可以找到多个匹配项，但二分查找需要特殊处理以找到第一个或最后一个匹配元素。</li></ul><h3 id="线性查找"><a href="#线性查找" class="headerlink" title="线性查找"></a>线性查找</h3><h4 id="算法思想-9"><a href="#算法思想-9" class="headerlink" title="算法思想"></a>算法思想</h4><p>线性查找（Linear Search）核心思想是：从数组的第一个元素开始，依次检查每个元素，直到找到目标元素或数组末尾为止。线性查找适用于<strong>无序数组</strong>，不需要对数组进行排序。</p><h4 id="代码实现-9"><a href="#代码实现-9" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">linear_search</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> size, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="comment">// 遍历数组中的每一个元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">        <span class="comment">// 如果找到了目标值，返回其索引</span></span><br><span class="line">        <span class="keyword">if</span> (arr[i] == target) &#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果未找到目标值，返回 -1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="算法分析-9"><a href="#算法分析-9" class="headerlink" title="算法分析"></a>算法分析</h4><ol><li><p>时间复杂度：</p><ul><li>**最坏情况：<code>O(n)</code>**。在最坏的情况下（即目标元素在数组的末尾或者不存在），需要检查数组中的每一个元素。</li><li>**最好情况：<code>O(1)</code>**。在最好的情况下（即目标元素是数组的第一个元素），只需要一次比较。</li><li>**平均情况：<code>O(n)</code>**。目标元素可能在数组的任何位置，平均需要遍历数组的一半，即 <code>n/2</code> 次操作，时间复杂度仍然为 <code>O(n)</code>。</li></ul></li><li><p>空间复杂度：**O(1)**。该算法只使用了一个额外的整型变量（用于循环计数），空间复杂度与输入数据的大小无关。</p></li><li><p>前提条件：<strong>无序数组</strong>。线性查找不要求数组有序，适合在任何情况下使用。</p></li><li><p>鲁棒性：<strong>鲁棒性强</strong>。算法本身不会对数组的内容做任何假设。即使数组中包含重复值、负数、零等，线性查找仍然可以正常工作。</p></li><li><p>稳定性：<strong>稳定</strong>。特别是在每一位的排序中使用稳定的排序算法（如计数排序）时，可以保证两个相同元素在排序前后的相对顺序不变。</p></li></ol><h3 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h3><h4 id="算法思想-10"><a href="#算法思想-10" class="headerlink" title="算法思想"></a>算法思想</h4><p>二分查找（Binary Search）是一种在<strong>有序数组</strong>中查找目标值的高效算法。基本思想是：</p><ul><li>每次将查找范围缩小一半。</li><li>假设有一个有序数组，并想在其中查找一个特定元素。首先比较目标值与中间元素的大小：<ul><li>如果目标值等于中间元素，直接返回该元素的索引。</li><li>如果目标值小于中间元素，则只需继续在左半部分查找。</li><li>如果目标值大于中间元素，则只需继续在右半部分查找。</li></ul></li></ul><p>不断重复，直到找到目标值，或者查找范围缩小为空，表明目标值不存在。</p><h4 id="代码实现-10"><a href="#代码实现-10" class="headerlink" title="代码实现"></a>代码实现</h4><ol><li>循环实现</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">binarySearch</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> left, <span class="type">int</span> right, <span class="type">int</span> target)</span> &#123;</span><br><span class="line"><span class="keyword">while</span> (left &lt;= right) &#123;    </span><br><span class="line">        <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>; <span class="comment">// 计算中间索引 </span></span><br><span class="line">        <span class="keyword">if</span> (arr[mid] == target) &#123;<span class="comment">// 如果目标值等于中间元素，返回索引</span></span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (arr[mid] &gt; target) &#123;<span class="comment">// 如果目标值小于中间元素，继续在左半部分查找</span></span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">else</span> &#123;<span class="comment">// 如果目标值大于中间元素，继续在右半部分查找</span></span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 未找到目标值，返回-1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>递归实现</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">bsearch</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> left, <span class="type">int</span> right, <span class="type">int</span> key)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (left &gt; right) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"><span class="comment">// 递归公式</span></span><br><span class="line"><span class="type">int</span> mid = left + (right - left &gt;&gt; <span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span> (key &lt; arr[mid]) <span class="keyword">return</span> bsearch(arr, left, mid - <span class="number">1</span>, key);</span><br><span class="line"><span class="keyword">if</span> (key &gt; arr[mid]) <span class="keyword">return</span> bsearch(arr, mid + <span class="number">1</span>, right, key);</span><br><span class="line"><span class="keyword">return</span> mid;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">binary_search</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> n, <span class="type">int</span> key)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> bsearch(arr, <span class="number">0</span>, n - <span class="number">1</span>, key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="算法分析-10"><a href="#算法分析-10" class="headerlink" title="算法分析"></a>算法分析</h4><ol><li><p>时间复杂度：</p><ul><li>**最坏情况：<code>O(logn)</code>**。每次查找都会将范围缩小一半，需要进行的比较次数为 <code>log₂n</code> 次，时间复杂度为 <code>O(logn)</code>。</li><li>**最好情况：<code>O(1)</code>**。当目标值正好位于数组的中间位置时，只需进行一次比较即可找到目标值，此时复杂度为 <code>O(1)</code>。</li><li>**平均情况：<code>O(logn)</code>**。与最坏情况相同，平均情况下复杂度为 <code>O(logn)</code>。</li></ul></li><li><p>空间复杂度：**O(1)**。由于只使用了常数级别的额外变量（如 <code>left</code>、<code>right</code>、<code>mid</code>）。</p></li><li><p>前提条件：</p><ul><li><p><strong>数组有序</strong>：二分查找的前提是数组必须是有序的，若数组无序，算法无法正常工作。</p></li><li><p><strong>静态数组</strong>：二分查找适合用于静态数组，即数组元素在查找过程中不会改变。元素发生改变，需要先重新排序。</p></li></ul></li><li><p>鲁棒性：</p><ul><li><p><strong>目标值不存在的情况</strong>：目标值不在数组中，算法最终会将查找范围缩小至无效的区间（<code>left &gt; right</code>），此时返回 <code>-1</code>，表示未找到目标值。</p></li><li><p><strong>数组为空</strong>：在调用函数时，数组为空（<code>right &lt; left</code>），算法会直接返回 <code>-1</code>。</p></li></ul></li><li><p>稳定性：<strong>不稳定</strong>。无法保证对于重复出现的元素总是返回第一个出现的索引。</p></li></ol><h3 id="跳表"><a href="#跳表" class="headerlink" title="跳表"></a>跳表</h3><h4 id="算法思想-11"><a href="#算法思想-11" class="headerlink" title="算法思想"></a>算法思想</h4><p>跳表（Skip List）是一种<strong>基于链表的数据结构</strong>。其核心思想是是在链表上建立多层“跳跃”索引，每层索引中的元素是下层链表的子集，索引层数越高包含的元素越少。</p><p><strong>跳表特点</strong>：</p><ol><li>跳表的结构是多级链表，最低层是原始链表，上面的每一层是索引链表；</li><li>查找、插入和删除操作依赖于索引，通过逐层查找可以减少比较次数，进而提高效率；</li><li>跳表的随机层数决定了效率，可以通过随机函数控制索引的生成。</li></ol><h4 id="代码实现-11"><a href="#代码实现-11" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义跳表的最大层数</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_LEVEL 16</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> P 0.5  <span class="comment">// 跳表中元素晋升的概率</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 跳表节点定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">SkipListNode</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">SkipListNode</span> *<span class="title">forward</span>[];</span>  <span class="comment">// 指向各层的前进指针数组</span></span><br><span class="line">&#125; SkipListNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 跳表定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">SkipList</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> level;                      <span class="comment">// 当前跳表的最大层数</span></span><br><span class="line">    SkipListNode *header;           <span class="comment">// 跳表的头节点</span></span><br><span class="line">&#125; SkipList;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建节点</span></span><br><span class="line">SkipListNode *<span class="title function_">createNode</span><span class="params">(<span class="type">int</span> level, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">    SkipListNode *node = (SkipListNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(SkipListNode) + level * <span class="keyword">sizeof</span>(SkipListNode *));</span><br><span class="line">    node-&gt;value = value;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建跳表</span></span><br><span class="line">SkipList *<span class="title function_">createSkipList</span><span class="params">()</span> &#123;</span><br><span class="line">    SkipList *<span class="built_in">list</span> = (SkipList *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(SkipList));</span><br><span class="line">    <span class="built_in">list</span>-&gt;level = <span class="number">0</span>;  <span class="comment">// 初始时，跳表层数为 0</span></span><br><span class="line">    <span class="built_in">list</span>-&gt;header = createNode(MAX_LEVEL, <span class="number">0</span>);  <span class="comment">// 创建头节点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; MAX_LEVEL; i++) &#123;</span><br><span class="line">        <span class="built_in">list</span>-&gt;header-&gt;forward[i] = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">list</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成随机层数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">randomLevel</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> level = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (((<span class="type">double</span>)rand() / RAND_MAX) &lt; P &amp;&amp; level &lt; MAX_LEVEL) &#123;</span><br><span class="line">        level++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> level;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找操作</span></span><br><span class="line">SkipListNode *<span class="title function_">search</span><span class="params">(SkipList *<span class="built_in">list</span>, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">    SkipListNode *x = <span class="built_in">list</span>-&gt;header;</span><br><span class="line">    <span class="comment">// 从最高层往低层查找</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="built_in">list</span>-&gt;level - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">while</span> (x-&gt;forward[i] &amp;&amp; x-&gt;forward[i]-&gt;value &lt; value) &#123;</span><br><span class="line">            x = x-&gt;forward[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    x = x-&gt;forward[<span class="number">0</span>];  <span class="comment">// 到达底层后，前进到下一个节点</span></span><br><span class="line">    <span class="keyword">if</span> (x &amp;&amp; x-&gt;value == value) &#123;</span><br><span class="line">        <span class="keyword">return</span> x;  <span class="comment">// 找到目标节点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;  <span class="comment">// 未找到</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入操作</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">insert</span><span class="params">(SkipList *<span class="built_in">list</span>, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">    SkipListNode *update[MAX_LEVEL];  <span class="comment">// 记录更新路径</span></span><br><span class="line">    SkipListNode *x = <span class="built_in">list</span>-&gt;header;</span><br><span class="line">    <span class="comment">// 从最高层往低层查找插入位置</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="built_in">list</span>-&gt;level - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">while</span> (x-&gt;forward[i] &amp;&amp; x-&gt;forward[i]-&gt;value &lt; value) &#123;</span><br><span class="line">            x = x-&gt;forward[i];</span><br><span class="line">        &#125;</span><br><span class="line">        update[i] = x;  <span class="comment">// 记录每一层的最后节点</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> level = randomLevel();  <span class="comment">// 生成该节点的随机层数</span></span><br><span class="line">    <span class="keyword">if</span> (level &gt; <span class="built_in">list</span>-&gt;level) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="built_in">list</span>-&gt;level; i &lt; level; i++) &#123;</span><br><span class="line">            update[i] = <span class="built_in">list</span>-&gt;header;  <span class="comment">// 新层初始化</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">list</span>-&gt;level = level;  <span class="comment">// 更新跳表的层数</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建新节点并插入</span></span><br><span class="line">    x = createNode(level, value);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; level; i++) &#123;</span><br><span class="line">        x-&gt;forward[i] = update[i]-&gt;forward[i];</span><br><span class="line">        update[i]-&gt;forward[i] = x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除操作</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">delete</span><span class="params">(SkipList *<span class="built_in">list</span>, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">    SkipListNode *update[MAX_LEVEL];</span><br><span class="line">    SkipListNode *x = <span class="built_in">list</span>-&gt;header;</span><br><span class="line">    <span class="comment">// 从最高层往低层查找删除位置</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="built_in">list</span>-&gt;level - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">while</span> (x-&gt;forward[i] &amp;&amp; x-&gt;forward[i]-&gt;value &lt; value) &#123;</span><br><span class="line">            x = x-&gt;forward[i];</span><br><span class="line">        &#125;</span><br><span class="line">        update[i] = x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    x = x-&gt;forward[<span class="number">0</span>];  <span class="comment">// 到达底层</span></span><br><span class="line">    <span class="keyword">if</span> (x &amp;&amp; x-&gt;value == value) &#123;</span><br><span class="line">        <span class="comment">// 更新每一层的前进指针，删除节点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">list</span>-&gt;level; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (update[i]-&gt;forward[i] != x) <span class="keyword">break</span>;</span><br><span class="line">            update[i]-&gt;forward[i] = x-&gt;forward[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">free</span>(x);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查并更新跳表的层数</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">list</span>-&gt;level &gt; <span class="number">0</span> &amp;&amp; <span class="built_in">list</span>-&gt;header-&gt;forward[<span class="built_in">list</span>-&gt;level - <span class="number">1</span>] == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="built_in">list</span>-&gt;level--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="算法分析-11"><a href="#算法分析-11" class="headerlink" title="算法分析"></a>算法分析</h4><ol><li><p>时间复杂度：</p><ul><li><strong>查找操作</strong>：跳表的查找过程是从上层逐级往下查找，每一层的节点数期望是上一层的一半。查找的平均时间复杂度为 **O(log n)**，最坏情况下退化为 **O(n)**（所有元素都在最低层）。</li><li><strong>插入操作</strong>：插入操作需要找到插入位置，然后插入新节点。和查找过程类似，平均时间复杂度为 **O(log n)**。</li><li><strong>删除操作</strong>：删除操作与查找过程相似，找到要删除的节点，修改前驱节点的指针。平均时间复杂度为 **O(log n)**。</li></ul></li><li><p>空间复杂度：**O(n)**。跳表需要为每个节点维护多层索引，索引的层数是随机生成的。平均情况下，跳表每一层的节点数量是前一层的 <strong>1&#x2F;2</strong>。</p></li><li><p>前提条件：</p><ul><li>跳表是一种有序的数据结构，节点的值必须具有可比较性（例如整数、浮点数、字符串等可排序类型）。</li><li>跳表在设计上依赖于随机层数的生成，随机数生成器需要良好表现，不能总是生成过大的层数或过小的层数。</li></ul></li><li><p>鲁棒性：</p><ul><li>跳表的插入和删除操作依赖于随机层数生成，跳表的性能在实际运行时会有一定波动。虽然最坏情况下跳表的时间复杂度为 **O(n)**，但平均情况较好，能保持 **O(log n)**。</li><li>跳表的鲁棒性体现在它可以通过随机层数来避免复杂的平衡操作，不像红黑树等需要严格的平衡调整。</li></ul></li><li><p>稳定性：</p><ul><li><p><strong>查找的稳定性</strong>：跳表的查找操作是确定的，即使数据随机插入，只要结构不发生变化，多次查找同一个值的结果一致，因此跳表的查找操作是稳定的。</p></li><li><p><strong>插入&#x2F;删除的稳定性</strong>：由于跳表中的元素插入是基于随机层数生成的，插入和删除的效率会有所波动，但总体是稳定的。</p></li></ul></li></ol><h3 id="哈希查找"><a href="#哈希查找" class="headerlink" title="哈希查找"></a>哈希查找</h3><h4 id="算法思想-12"><a href="#算法思想-12" class="headerlink" title="算法思想"></a>算法思想</h4><p>哈希查找（Hashing）是一种通过键值（Key）来直接访问数据的方法，其核心思想是将元素的存储位置和键值通过一个哈希函数关联起来，将关键字映射到数组中的一个位置，然后通过数组的下标直接找到对应的值。</p><ul><li><strong>哈希函数（Hash Function）</strong>：负责将键值转换为数组索引。一个好的哈希函数应具有均匀性和简单性，避免大量冲突。</li><li><strong>哈希表（Hash Table）</strong>：利用数组实现的，存储元素的位置通过哈希函数计算得出。</li><li><strong>冲突处理</strong>：当两个不同的键值通过哈希函数得到相同的数组索引时，称为“冲突”。常用的冲突解决方法有开放地址法和链地址法。</li></ul><h4 id="代码实现-12"><a href="#代码实现-12" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 哈希表的最大容量</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TABLE_SIZE 100</span></span><br><span class="line"><span class="comment">// 定义哈希表</span></span><br><span class="line"><span class="type">int</span> hashTable[TABLE_SIZE];</span><br><span class="line"><span class="comment">// 初始化哈希表，所有位置设置为-1表示空</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">initHashTable</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; TABLE_SIZE; i++) &#123;</span><br><span class="line">        hashTable[i] = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 简单的哈希函数，将键值转换为数组索引</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">hashFunction</span><span class="params">(<span class="type">int</span> key)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> key % TABLE_SIZE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 插入键值</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">insert</span><span class="params">(<span class="type">int</span> key)</span> &#123;</span><br><span class="line">    <span class="type">int</span> index = hashFunction(key);  <span class="comment">// 计算哈希值</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 线性探测，处理冲突</span></span><br><span class="line">    <span class="keyword">while</span> (hashTable[index] != <span class="number">-1</span>) &#123;</span><br><span class="line">        index = (index + <span class="number">1</span>) % TABLE_SIZE;  <span class="comment">// 向后探测下一个位置</span></span><br><span class="line">    &#125;</span><br><span class="line">    hashTable[index] = key;  <span class="comment">// 插入键值</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 查找键值</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span> key)</span> &#123;</span><br><span class="line">    <span class="type">int</span> index = hashFunction(key);  <span class="comment">// 计算哈希值</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 线性探测查找，处理冲突</span></span><br><span class="line">    <span class="keyword">while</span> (hashTable[index] != <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (hashTable[index] == key) &#123;</span><br><span class="line">            <span class="keyword">return</span> index;  <span class="comment">// 找到键值，返回位置</span></span><br><span class="line">        &#125;</span><br><span class="line">        index = (index + <span class="number">1</span>) % TABLE_SIZE;  <span class="comment">// 向后探测下一个位置</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;  <span class="comment">// 未找到，返回-1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 删除键值</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">delete</span><span class="params">(<span class="type">int</span> key)</span> &#123;</span><br><span class="line">    <span class="type">int</span> index = search(key);  <span class="comment">// 查找键值所在位置</span></span><br><span class="line">    <span class="keyword">if</span> (index != <span class="number">-1</span>) &#123;</span><br><span class="line">        hashTable[index] = <span class="number">-1</span>;  <span class="comment">// 将对应位置设为空</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="算法分析-12"><a href="#算法分析-12" class="headerlink" title="算法分析"></a>算法分析</h4><ol><li><p>时间复杂度：</p><ul><li>**最坏情况：<code>O(n)</code>**。当发生大量冲突时，最坏情况下时间复杂度为 <code>O(n)</code> ，例如所有键值都映射到相同位置时，需要线性探测整个数组。</li><li>**最好情况：<code>O(1)</code>**。理想情况下，通过哈希函数能直接定位。</li><li>**平均情况：<code>O(1)</code>**。插入、查找和删除的平均时间复杂度为 <code>O(1)</code> ，理想情况下，通过哈希函数能直接定位。</li></ul></li><li><p>空间复杂度：**O(n)**。哈希表的空间复杂度为 <code>O(n)</code>，其中 <code>n</code> 是哈希表的大小。</p></li><li><p>前提条件：</p><ul><li><p>哈希函数应设计合理，尽量均匀分布键值，避免产生大量冲突。</p></li><li><p>表的大小应适当，通常选择一个比实际存储量略大的素数以减少冲突。</p></li></ul></li><li><p>鲁棒性：</p><ul><li><p><strong>目标值不存在的情况</strong>：对于不存在的元素，查找函数能返回 -1，表示未找到，具有良好的鲁棒性。</p></li><li><p>插入函数能自动处理冲突，避免覆盖已有数据。</p></li></ul></li><li><p>稳定性：<strong>不稳定</strong>。元素的插入和查找顺序不依赖于元素的原始顺序。</p></li></ol><h3 id="深度优先搜索"><a href="#深度优先搜索" class="headerlink" title="深度优先搜索"></a>深度优先搜索</h3><h4 id="算法思想-13"><a href="#算法思想-13" class="headerlink" title="算法思想"></a>算法思想</h4><p>深度优先搜索（Depth First Search, DFS）是一种遍历或搜索图或树数据结构的算法。其基本思想是沿着一个分支不断向前深入，直到找到目标或到达叶子节点。每当到达一个节点时，如果该节点的所有相邻节点都已经访问过或不可达，算法会回溯到上一个节点继续搜索未访问的相邻节点，直到所有节点都被访问。</p><p>DFS使用的是“栈”的思想（可以通过递归或显式使用栈结构来实现），即先探到最深处，然后逐步回溯。</p><h4 id="代码实现-13"><a href="#代码实现-13" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_NODES 100</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 图的邻接矩阵表示</span></span><br><span class="line"><span class="type">int</span> graph[MAX_NODES][MAX_NODES]; <span class="comment">// 图的邻接矩阵</span></span><br><span class="line"><span class="type">int</span> visited[MAX_NODES]; <span class="comment">// 标记节点是否已访问</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 深度优先搜索算法实现</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">DFS</span><span class="params">(<span class="type">int</span> node, <span class="type">int</span> num_nodes)</span> &#123;</span><br><span class="line">    visited[node] = <span class="number">1</span>; <span class="comment">// 标记当前节点为已访问</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历所有相邻节点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; num_nodes; i++) &#123;</span><br><span class="line">        <span class="comment">// 如果有相邻节点且未访问，继续深入</span></span><br><span class="line">        <span class="keyword">if</span> (graph[node][i] == <span class="number">1</span> &amp;&amp; !visited[i]) &#123;</span><br><span class="line">            DFS(i, num_nodes); <span class="comment">// 递归调用</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><p><code>graph</code> 是图的邻接矩阵，<code>graph[i][j] = 1</code> 表示节点 <code>i</code> 与节点 <code>j</code> 相连。</p></li><li><p><code>visited[i]</code> 用于标记节点是否已经被访问，以避免重复遍历。</p></li><li><p><code>DFS</code> 函数中，通过递归实现了从某个节点开始的深度优先搜索。</p></li></ul><h4 id="算法分析-13"><a href="#算法分析-13" class="headerlink" title="算法分析"></a>算法分析</h4><ol><li><p>时间复杂度：DFS的时间复杂度取决于图的表示方式，总的来说，DFS对稀疏图（边较少）和稠密图（边较多）都具有良好的性能表现。</p><ul><li><strong>邻接矩阵</strong>： <strong><code>O(V^2)</code></strong> ，其中 <code>V</code> 是图中节点数。</li><li><strong>邻接表</strong>： <strong><code>O(V+E)</code></strong> ，其中 <code>E</code> 是图中边的数量。</li></ul></li><li><p>空间复杂度：空间复杂度主要由递归栈占用</p><ul><li><strong>邻接矩阵</strong>： <strong><code>O(V)</code></strong> ，其中 <code>V</code> 是图中节点数。</li><li><strong>邻接表</strong>： <strong><code>O(V^2)</code></strong> ，其中 <code>V</code> 是图中节点数。</li></ul></li><li><p>前提条件：</p><ul><li>图可以是连通或非连通图。</li><li>适用于无向图和有向图。</li><li>对于递归实现，要求系统栈空间足够大，适合节点数量较小的图。如果图的节点非常多，递归深度过大可能会导致栈溢出，建议改用非递归方式（例如使用栈模拟递归）。</li></ul></li><li><p>鲁棒性：</p><ul><li>需要考虑边界情况，例如图为空（没有节点或边）、只有一个节点、图不连通等特殊情况。</li><li>需要处理节点数组越界、空指针等异常。</li></ul></li><li><p>稳定性：<strong>不稳定</strong>。不同的执行顺序可能会导致不同的遍历路径，取决于邻接节点的访问顺序。</p></li></ol><h3 id="广度优先搜索"><a href="#广度优先搜索" class="headerlink" title="广度优先搜索"></a>广度优先搜索</h3><h4 id="算法思想-14"><a href="#算法思想-14" class="headerlink" title="算法思想"></a>算法思想</h4><p>广度优先搜索（Breadth First Search, BFS）是一种图遍历算法，通常用于无权图最短路径问题、连通分量搜索等问题。其基本思想是：从起始节点开始，先访问所有相邻节点，然后再逐层向外扩展，直到目标节点被访问或所有节点都被遍历完。</p><p>BFS 使用队列（Queue）来维护当前层级的节点，并确保节点按层级顺序访问。每次从队列中取出一个节点，访问其所有未访问的邻节点，将它们加入队列。</p><h4 id="代码实现-14"><a href="#代码实现-14" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_VERTICES 100</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 队列结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> items[MAX_VERTICES];</span><br><span class="line">    <span class="type">int</span> front;</span><br><span class="line">    <span class="type">int</span> rear;</span><br><span class="line">&#125; Queue;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化队列</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">initQueue</span><span class="params">(Queue* q)</span> &#123;</span><br><span class="line">    q-&gt;front = <span class="number">-1</span>;</span><br><span class="line">    q-&gt;rear = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断队列是否为空</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">isEmpty</span><span class="params">(Queue* q)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> q-&gt;front == <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 入队</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">enqueue</span><span class="params">(Queue* q, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (q-&gt;rear == MAX_VERTICES - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;  <span class="comment">// 队列满了</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (q-&gt;front == <span class="number">-1</span>) &#123;</span><br><span class="line">            q-&gt;front = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        q-&gt;rear++;</span><br><span class="line">        q-&gt;items[q-&gt;rear] = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 出队</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">dequeue</span><span class="params">(Queue* q)</span> &#123;</span><br><span class="line">    <span class="type">int</span> item;</span><br><span class="line">    <span class="keyword">if</span> (isEmpty(q)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;  <span class="comment">// 队列为空</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        item = q-&gt;items[q-&gt;front];</span><br><span class="line">        q-&gt;front++;</span><br><span class="line">        <span class="keyword">if</span> (q-&gt;front &gt; q-&gt;rear) &#123;</span><br><span class="line">            q-&gt;front = q-&gt;rear = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> item;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 广度优先搜索算法</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">BFS</span><span class="params">(<span class="type">int</span> graph[MAX_VERTICES][MAX_VERTICES], <span class="type">int</span> startVertex, <span class="type">int</span> numVertices)</span> &#123;</span><br><span class="line">    Queue q;</span><br><span class="line">    initQueue(&amp;q);</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> visited[MAX_VERTICES] = &#123;<span class="literal">false</span>&#125;;  <span class="comment">// 标记每个节点是否访问过</span></span><br><span class="line">    visited[startVertex] = <span class="literal">true</span>;</span><br><span class="line">    enqueue(&amp;q, startVertex);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!isEmpty(&amp;q)) &#123;</span><br><span class="line">        <span class="type">int</span> currentVertex = dequeue(&amp;q);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;访问节点 %d\n&quot;</span>, currentVertex);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历当前节点的所有邻接节点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numVertices; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (graph[currentVertex][i] == <span class="number">1</span> &amp;&amp; !visited[i]) &#123;</span><br><span class="line">                visited[i] = <span class="literal">true</span>;  <span class="comment">// 标记为已访问</span></span><br><span class="line">                enqueue(&amp;q, i);  <span class="comment">// 将邻接节点加入队列</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="算法分析-14"><a href="#算法分析-14" class="headerlink" title="算法分析"></a>算法分析</h4><ol><li><p>时间复杂度： <strong>O(V + E)<strong>，其中，</strong>V</strong> 是顶点的数量，<strong>E</strong> 是边的数量。在最坏情况下，BFS 需要遍历每个顶点和与其相连的每条边。</p></li><li><p>空间复杂度：存储图的邻接矩阵和队列。</p><ul><li><strong>队列</strong>：最多存储所有顶点，即 O(V)。</li><li><strong>访问标记数组</strong>：存储每个顶点的访问状态，也是 O(V)。</li></ul></li><li><p>前提条件：</p><ul><li><strong>图的存储方式</strong>：本实现使用邻接矩阵表示图，因此适用于稠密图。如果图是稀疏的，可以改用邻接表来优化空间复杂度。</li><li><strong>输入合法性</strong>：输入的图应是连通图（探索全图），并且顶点的索引应合法。</li></ul></li><li><p>鲁棒性：</p><ul><li><p><strong>队列溢出检测</strong>：本代码中检查了队列是否满，但没有处理队列溢出的错误处理机制（如扩展队列容量）。对于大图来说，需要更鲁棒的动态队列实现。</p><p><strong>图遍历的边界处理</strong>：该算法可以处理连通图和非连通图，但要确保输入的顶点索引在有效范围内（即 [0, numVertices-1] 之间）。</p></li></ul></li><li><p>稳定性：<strong>稳定</strong>。按照层级顺序依次访问每个顶点，保证在最短路径问题中，较早访问的顶点优先处理，不会跳跃式访问。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> C </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C_数组</title>
      <link href="/Language/C/C_%E6%95%B0%E7%BB%84"/>
      <url>/Language/C/C_%E6%95%B0%E7%BB%84</url>
      
        <content type="html"><![CDATA[<h1 id="C-数组"><a href="#C-数组" class="headerlink" title="C_数组"></a>C_数组</h1><p>C语言中的变量可以根据存储的数据类型和结构来分为<strong>标量变量</strong>和<strong>聚合变量</strong>。</p><p><strong>标量变量（Scalar Variables）</strong>：标量变量是指单一的数据项，表示单个值。常见的标量类型包括整数、浮点数、字符和枚举等。</p><p><strong>聚合变量（Aggregate Variables）</strong>：聚合变量是指由多个数据项组成的集合，每个数据项可以是标量类型，也可以是其它聚合类型。常见的聚合类型包括数组、结构体和联合体等。聚合变量可以同时保存多个值。 </p><h2 id="按维度分类"><a href="#按维度分类" class="headerlink" title="按维度分类"></a>按维度分类</h2><h3 id="一维数组"><a href="#一维数组" class="headerlink" title="一维数组"></a>一维数组</h3><p>一维数组是一组按照线性排列的元素集合，每个元素都有一个唯一的下标，可以用数组索引来访问数组中的元素。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type arrayName[arraySize];</span><br></pre></td></tr></table></figure><p><strong>数组初始化</strong>：</p><ol><li><p>用大括号包含一组常量表达式，常量表达式之间用逗号分隔。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">10</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>&#125;;</span><br></pre></td></tr></table></figure><p>当初始化式比数组短，剩余元素被初始化为 <code>0</code>，但初始化式不能比数组长，也不能完全为空。</p></li><li><p>给定了初始化式，可以省略数组的长度：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>&#125;;</span><br></pre></td></tr></table></figure></li><li><p>数组元素可以是任何类型，数组的长度则必须是常量表达式 (能够在编译期间求值的表达式)。一般使用宏来</p><p>定义数组的长度：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> N 10</span></span><br><span class="line">...</span><br><span class="line"><span class="type">int</span> a[N];</span><br></pre></td></tr></table></figure></li></ol><h3 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h3><p>多维数组是一种具有多个维度的数组，元素在多个维度上排列。常见的多维数组有二维数组、三维数组等。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type arrayName[size1][size2]...[sizeN];</span><br></pre></td></tr></table></figure><p>多维数组初始化：</p><ol><li><p>嵌套一维数组初始化式，可以构建二维数组的初始化式，更高维数组可以采取类似的方法构建。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> matrix[<span class="number">5</span>][<span class="number">9</span>] = &#123;&#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;,</span><br><span class="line">                   &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;,</span><br><span class="line">                   &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;,</span><br><span class="line">                   &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;,</span><br><span class="line">                   &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;&#125;;</span><br></pre></td></tr></table></figure></li><li><p>初始化式的长度不够，剩余元素被初始化为 <code>0</code>。</p></li><li><p>内层初始化式不足以填满数组的一行，这一行剩余的元素会被初始化为<code>0</code>。</p></li><li><p>可以省略内存的大括号，编译器一旦发现值足以填满一行，就开始填充下一行。（在初始化式中省略内层大括号是非常危险的，不小心多写或者少写一个值都会影响后面元素的初始化）</p></li></ol><h2 id="按存储方式分类"><a href="#按存储方式分类" class="headerlink" title="按存储方式分类"></a>按存储方式分类</h2><h3 id="静态数组"><a href="#静态数组" class="headerlink" title="静态数组"></a>静态数组</h3><p>静态数组是在编译时分配内存空间的数组，其大小在编译时确定，通常使用数组声明语句来定义。静态数组的声明和初始化可以在程序的任何位置进行。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="type">static</span> Array[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;; <span class="comment">// 静态数组的声明和初始化</span></span><br></pre></td></tr></table></figure><h3 id="动态数组"><a href="#动态数组" class="headerlink" title="动态数组"></a>动态数组</h3><p>动态数组是在程序运行时动态分配内存空间的数组，其大小可以根据需要在运行时确定，通常使用动态内存分配函数来创建，如<code>malloc</code>、<code>calloc</code>等。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *dynamicArray;</span><br><span class="line"><span class="type">int</span> size = <span class="number">5</span>;</span><br><span class="line">dynamicArray = (<span class="type">int</span>*)<span class="built_in">malloc</span>(size * <span class="keyword">sizeof</span>(<span class="type">int</span>)); <span class="comment">// 动态分配数组内存</span></span><br></pre></td></tr></table></figure><h2 id="按声明方式分类"><a href="#按声明方式分类" class="headerlink" title="按声明方式分类"></a>按声明方式分类</h2><h3 id="全局数组"><a href="#全局数组" class="headerlink" title="全局数组"></a>全局数组</h3><p>全局数组是在函数外部声明的数组，其作用域为整个文件，可以被文件中的所有函数访问。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> globalArray[<span class="number">5</span>]; <span class="comment">// 全局数组声明</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 在main函数中访问全局数组</span></span><br><span class="line">    globalArray[<span class="number">0</span>] = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Value of globalArray[0]: %d\n&quot;</span>, globalArray[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="局部数组"><a href="#局部数组" class="headerlink" title="局部数组"></a>局部数组</h3><p>局部数组是在函数内部声明的数组，其作用域仅限于声明它的函数内部，无法被其它函数访问。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">function</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> localArray[<span class="number">3</span>]; <span class="comment">// 局部数组声明</span></span><br><span class="line">    <span class="comment">// 在函数中访问局部数组</span></span><br><span class="line">    localArray[<span class="number">0</span>] = <span class="number">5</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Value of localArray[0]: %d\n&quot;</span>, localArray[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="其它分类方式"><a href="#其它分类方式" class="headerlink" title="其它分类方式"></a>其它分类方式</h2><h3 id="字符数组"><a href="#字符数组" class="headerlink" title="字符数组"></a>字符数组</h3><p>字符数组是一种特殊的一维数组，其元素类型为字符型，通常用于存储字符串。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> str[<span class="number">6</span>] = <span class="string">&quot;Hello&quot;</span>; <span class="comment">// 声明并初始化字符数组</span></span><br></pre></td></tr></table></figure><h3 id="数组指针"><a href="#数组指针" class="headerlink" title="数组指针"></a>数组指针</h3><p>数组指针是指向数组的指针，可以用于动态多维数组的实现。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> (*ptr)[<span class="number">5</span>]; <span class="comment">// 声明一个指向包含5个整数的数组的指针</span></span><br></pre></td></tr></table></figure><h3 id="数组参数"><a href="#数组参数" class="headerlink" title="数组参数"></a>数组参数</h3><p>数组参数可以在函数参数中使用数组类型，可以通过数组名传递数组，也可以传递指向数组首元素的指针。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">printArray</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> size)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; ++i) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="常量数组"><a href="#常量数组" class="headerlink" title="常量数组"></a>常量数组</h3><p>声明时加上 <code>const</code> 修饰符而变成 “常量”：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span> hex_chars[] =</span><br><span class="line"> &#123;<span class="string">&#x27;0&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;3&#x27;</span>, <span class="string">&#x27;4&#x27;</span>, <span class="string">&#x27;5&#x27;</span>, <span class="string">&#x27;6&#x27;</span>, <span class="string">&#x27;7&#x27;</span>, <span class="string">&#x27;8&#x27;</span>, <span class="string">&#x27;9&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;D&#x27;</span>, <span class="string">&#x27;E&#x27;</span>, <span class="string">&#x27;F&#x27;</span>&#125;;</span><br></pre></td></tr></table></figure><p>程序在运行期间不会对数组进行修改。 <code>const</code> 不仅仅可以修饰数组，还可以修饰任意变量。</p><h3 id="对数组使用sizeof运算符"><a href="#对数组使用sizeof运算符" class="headerlink" title="对数组使用sizeof运算符"></a>对数组使用<code>sizeof</code>运算符</h3><p><code>sizeof</code> 运算符可以确定数组元素的大小，两者相除即得到数组的长度：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sizeof</span>(a) / <span class="keyword">sizeof</span>(a[<span class="number">0</span>])</span><br></pre></td></tr></table></figure><p>清空数组可以写成如下形式：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(a) / <span class="keyword">sizeof</span>(a[<span class="number">0</span>]); i++)</span><br><span class="line">a[i] = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>为了可读性和通用性，把 <code>sizeof(a) / sizeof(a[0])</code> 定义为带参数的宏</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> SIZE(a) (sizeof(a) / sizeof(a[0]))</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C_数据结构</title>
      <link href="/Language/C/C_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"/>
      <url>/Language/C/C_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84</url>
      
        <content type="html"><![CDATA[<h1 id="C-常用数据结构"><a href="#C-常用数据结构" class="headerlink" title="C_常用数据结构"></a>C_常用数据结构</h1><p>最常用的数据结构有：数组，链表，栈，队列，哈希表和二叉搜索树等。网站推荐 <a href="https://www.cs.usfca.edu/~galles/visualization/">数据结构与算法可视化</a></p><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><p>链表是一种动态数据结构，由一系列节点组成，与数组不同，链表中的元素在内存中不需要是连续的，通过指针将元素串联起来。链表的主要特性是其动态性，即可以方便地进行插入和删除操作，而无需像数组需要移动元素。</p><p><img src="https://cdn.jsdelivr.net/gh/Barbecue-g/imagehost/Language/C/C_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%93%BE%E8%A1%A8.png" alt="链表"></p><p>链表有多种类型：单链表（Singly Linked List），双向链表（Doubly Linked List），以及循环链表（Circular Linked List）等。</p><p><img src="https://cdn.jsdelivr.net/gh/Barbecue-g/imagehost/Language/C/C_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%93%BE%E8%A1%A8%E5%88%86%E7%B1%BB.png" alt="链表分类"></p><p>循环链表用的一般比较少，但是当处理的数据具有环形结构时，就特别适合用循环链表（约瑟夫环问题）。</p><h3 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h3><h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h4><p>每个节点包含数据部分和指向下一个节点的指针。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义链表节点结构</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> data;           <span class="comment">// 数据域</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">next</span>;</span>  <span class="comment">// 指针域，指向下一个节点</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化链表头指针为 NULL</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">head</span> =</span> <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure><h4 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h4><ol><li><p><strong>节点插入（头插法）</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">insertAtHead</span><span class="params">(<span class="type">int</span> data)</span> &#123;</span><br><span class="line">    <span class="comment">// 创建新节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">newNode</span> =</span> (<span class="keyword">struct</span> Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> Node));</span><br><span class="line">    newNode-&gt;data = data;</span><br><span class="line">    newNode-&gt;next = head;</span><br><span class="line">    head = newNode;  <span class="comment">// 更新头指针</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>节点插入（尾插法）</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">insertAtTail</span><span class="params">(<span class="type">int</span> data)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">newNode</span> =</span> (<span class="keyword">struct</span> Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> Node));</span><br><span class="line">    newNode-&gt;data = data;</span><br><span class="line">    newNode-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">NULL</span>) &#123;  <span class="comment">// 链表为空</span></span><br><span class="line">        head = newNode;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">struct</span> Node* temp = head;</span><br><span class="line">        <span class="keyword">while</span> (temp-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            temp = temp-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        temp-&gt;next = newNode;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>节点删除（按值删除）</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">deleteNode</span><span class="params">(<span class="type">int</span> key)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">temp</span> =</span> head;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">prev</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当头节点就是要删除的节点</span></span><br><span class="line">    <span class="keyword">if</span> (temp != <span class="literal">NULL</span> &amp;&amp; temp-&gt;data == key) &#123;</span><br><span class="line">        head = temp-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(temp);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 搜索要删除的节点</span></span><br><span class="line">    <span class="keyword">while</span> (temp != <span class="literal">NULL</span> &amp;&amp; temp-&gt;data != key) &#123;</span><br><span class="line">        prev = temp;</span><br><span class="line">        temp = temp-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (temp == <span class="literal">NULL</span>) <span class="keyword">return</span>;  <span class="comment">// 未找到</span></span><br><span class="line"></span><br><span class="line">    prev-&gt;next = temp-&gt;next;</span><br><span class="line">    <span class="built_in">free</span>(temp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>节点查找</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> Node* <span class="title function_">search</span><span class="params">(<span class="type">int</span> key)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">temp</span> =</span> head;</span><br><span class="line">    <span class="keyword">while</span> (temp != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (temp-&gt;data == key) &#123;</span><br><span class="line">            <span class="keyword">return</span> temp;</span><br><span class="line">        &#125;</span><br><span class="line">        temp = temp-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;  <span class="comment">// 未找到</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>链表反转</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">reverseList</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">prev</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">current</span> =</span> head;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">next</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (current != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        next = current-&gt;next;</span><br><span class="line">        current-&gt;next = prev;</span><br><span class="line">        prev = current;</span><br><span class="line">        current = next;</span><br><span class="line">    &#125;</span><br><span class="line">    head = prev;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>链表遍历</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">printList</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">temp</span> =</span> head;</span><br><span class="line">    <span class="keyword">while</span> (temp != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d -&gt; &quot;</span>, temp-&gt;data);</span><br><span class="line">        temp = temp-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;NULL\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h4><p><strong>时间复杂度</strong>：</p><ul><li><strong>插入</strong>：在链表头插入节点的时间复杂度为 O(1)；在链表尾插入节点的时间复杂度为 O(n)。</li><li><strong>删除</strong>：删除节点的时间复杂度为 O(n)。</li><li><strong>查找</strong>：查找节点的时间复杂度为 O(n)。</li><li><strong>反转</strong>：链表反转的时间复杂度为 O(n)。</li></ul><p><strong>空间复杂度</strong>：</p><ul><li>链表节点的空间复杂度为 O(n)，其中 n 为节点数量。每个节点的额外空间开销是一个指针的大小。</li></ul><h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><p>链表适用于以下场景：</p><ul><li>需要频繁插入、删除操作，尤其是在链表开头或结尾（如队列和栈的实现）。</li><li>需要动态分配内存且不需要连续的内存块时。</li><li>数据量不大，且对随机访问要求不高的情况下。</li></ul><p>链表不适合用于随机访问，访问链表中的任意节点需要遍历整个链表，时间复杂度为 O(n)，不如数组的 O(1) 高效。</p><h3 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h3><p>双向链表是一种链表数据结构，与单链表不同，双向链表允许在两个方向上遍历节点，从而提高了某些操作的效率。双向链表的主要优点是可以更方便地进行前后节点的访问、插入和删除操作。</p><h4 id="数据结构-1"><a href="#数据结构-1" class="headerlink" title="数据结构"></a>数据结构</h4><p>每个节点包含三个部分：存储数据的区域、指向下一个节点的指针和指向前一个节点的指针。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义双向链表节点</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> data;           <span class="comment">// 存储数据</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">next</span>;</span>  <span class="comment">// 指向下一个节点的指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">prev</span>;</span>  <span class="comment">// 指向前一个节点的指针</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义链表头节点</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">head</span> =</span> <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure><h4 id="基本操作-1"><a href="#基本操作-1" class="headerlink" title="基本操作"></a>基本操作</h4><ol><li><p><strong>初始化链表</strong></p><p>创建一个空的双向链表：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">initialize</span><span class="params">()</span> &#123;</span><br><span class="line">    head = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>节点插入（头插法）</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">insertAtBeginning</span><span class="params">(<span class="type">int</span> newData)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">newNode</span> =</span> (<span class="keyword">struct</span> Node*) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> Node));</span><br><span class="line">    newNode-&gt;data = newData;</span><br><span class="line">    newNode-&gt;next = head;</span><br><span class="line">    newNode-&gt;prev = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (head != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        head-&gt;prev = newNode;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    head = newNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>节点插入（尾插法）</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">insertAtEnd</span><span class="params">(<span class="type">int</span> newData)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">newNode</span> =</span> (<span class="keyword">struct</span> Node*) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> Node));</span><br><span class="line">    newNode-&gt;data = newData;</span><br><span class="line">    newNode-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        newNode-&gt;prev = <span class="literal">NULL</span>;</span><br><span class="line">        head = newNode;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">temp</span> =</span> head;</span><br><span class="line">    <span class="keyword">while</span> (temp-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        temp = temp-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    temp-&gt;next = newNode;</span><br><span class="line">    newNode-&gt;prev = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>节点删除（按值删除）</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">deleteNode</span><span class="params">(<span class="type">int</span> key)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">temp</span> =</span> head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找到要删除的节点</span></span><br><span class="line">    <span class="keyword">while</span> (temp != <span class="literal">NULL</span> &amp;&amp; temp-&gt;data != key) &#123;</span><br><span class="line">        temp = temp-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (temp == <span class="literal">NULL</span>) <span class="keyword">return</span>; <span class="comment">// 节点未找到</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (temp-&gt;prev != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        temp-&gt;prev-&gt;next = temp-&gt;next;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        head = temp-&gt;next; <span class="comment">// 删除的是头节点</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (temp-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        temp-&gt;next-&gt;prev = temp-&gt;prev;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(temp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>节点查找</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span> key)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">temp</span> =</span> head;</span><br><span class="line">    <span class="keyword">while</span> (temp != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (temp-&gt;data == key)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        temp = temp-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>链表遍历</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">printList</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">temp</span> =</span> head;</span><br><span class="line">    <span class="keyword">while</span> (temp != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d -&gt; &quot;</span>, temp-&gt;data);</span><br><span class="line">        temp = temp-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;NULL\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="性能分析-1"><a href="#性能分析-1" class="headerlink" title="性能分析"></a>性能分析</h4><p><strong>时间复杂度</strong>：</p><ul><li><strong>插入</strong>：在链表头插入节点的时间复杂度为 O(1)；在链表尾插入节点的时间复杂度为 O(1)。</li><li><strong>删除</strong>：删除节点的时间复杂度为 O(n)。</li><li><strong>查找</strong>：查找节点的时间复杂度为 O(n)。</li><li><strong>遍历</strong>：正向&#x2F;反向遍历链表的时间复杂度为 O(n)。</li></ul><p><strong>空间复杂度</strong>：</p><ul><li>双向链表的空间复杂度为O(n)，其中n是节点数量。相较于单链表，双向链表由于每个节点多一个指针（prev），占用的空间略多。</li></ul><p><font color=#0099ff>总结：虽然双向链表更占内存空间，但是它某些操作的性能是优于单链表的。这是空间换时间的思想。</font></p><h4 id="应用场景-1"><a href="#应用场景-1" class="headerlink" title="应用场景"></a>应用场景</h4><p>双向链表适用于以下场景：</p><ul><li>当需要在两端频繁插入或删除节点时，双向链表比单链表更高效。</li><li>当需要从任意位置（尤其是中间节点）进行删除操作时，双向链表更合适，可以直接访问前一个节点。</li><li>适用于需要在两个方向上遍历数据的场景，如实现浏览器的前进&#x2F;后退功能。</li></ul><p>不适合用于需要频繁访问任意元素的场景，链表的随机访问时间复杂度较高（O(n)）。</p><h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><p>栈（Stack）是一种<strong>后进先出（LIFO, Last In First Out）</strong>的数据结构。特点是只能在一端（栈顶）进行数据的插入和删除操作。栈通常用作函数调用的管理、表达式求值、括号匹配等。</p><p><img src="https://cdn.jsdelivr.net/gh/Barbecue-g/imagehost/Language/C/C_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%88.png" alt="栈"></p><h3 id="数据结构-2"><a href="#数据结构-2" class="headerlink" title="数据结构"></a>数据结构</h3><p>栈可以使用数组或链表来实现</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_SIZE 100  <span class="comment">// 栈的最大容量</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Stack</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> data[MAX_SIZE];  <span class="comment">// 栈的存储空间</span></span><br><span class="line">    <span class="type">int</span> top;             <span class="comment">// 栈顶指针</span></span><br><span class="line">&#125; Stack;</span><br></pre></td></tr></table></figure><h3 id="基本操作-2"><a href="#基本操作-2" class="headerlink" title="基本操作"></a>基本操作</h3><ol><li><p><strong>初始化栈</strong>：将栈顶指针<code>top</code>初始化为<code>-1</code>，表示栈为空。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">initStack</span><span class="params">(Stack *s)</span> &#123;</span><br><span class="line">    s-&gt;top = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>压栈</strong>：在栈未满的情况下，将元素压入栈顶。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">push</span><span class="params">(Stack *s, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!isFull(s)) &#123;</span><br><span class="line">        s-&gt;data[++(s-&gt;top)] = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>弹栈</strong>：在栈不为空的情况下，从栈顶弹出元素。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pop</span><span class="params">(Stack *s)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!isEmpty(s)) &#123;</span><br><span class="line">        <span class="keyword">return</span> s-&gt;data[(s-&gt;top)--];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">// 栈为空时返回-1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>获取栈顶元素</strong>：获取栈顶元素但不弹出。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">peek</span><span class="params">(Stack *s)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!isEmpty(s)) &#123;</span><br><span class="line">        <span class="keyword">return</span> s-&gt;data[s-&gt;top];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">// 栈为空时返回-1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>判断栈是否为空</strong>：判断栈顶指针是否为<code>-1</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">isEmpty</span><span class="params">(Stack *s)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> s-&gt;top == <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>判断栈是否已满</strong>：判断栈顶指针是否等于数组的最大索引。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">isFull</span><span class="params">(Stack *s)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> s-&gt;top == <span class="number">99</span>; <span class="comment">// 数组大小为100</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="性能分析-2"><a href="#性能分析-2" class="headerlink" title="性能分析"></a>性能分析</h3><p><strong>时间复杂度</strong>：</p><ul><li><code>Push</code>：O(1) —— 插入元素只需要更新栈顶指针并赋值。</li><li><code>Pop</code>：O(1) —— 弹出元素只需要读取栈顶指针位置的值并更新指针。</li><li><code>Top</code>：O(1) —— 获取栈顶元素只需访问数组中栈顶指针位置的值。</li></ul><p><strong>空间复杂度</strong>：</p><ul><li>空间复杂度为 O(n)，其中 n 是栈的容量。栈的空间由数组固定分配。</li></ul><h3 id="应用场景-2"><a href="#应用场景-2" class="headerlink" title="应用场景"></a>应用场景</h3><p>栈在许多算法中有着广泛的应用，主要包括但不限于以下几个方面：</p><ul><li><strong>函数调用管理</strong>：递归函数调用时，系统使用栈来保存和恢复函数的上下文信息。</li><li><strong>表达式求值</strong>：在中缀表达式转后缀表达式或计算后缀表达式时广泛使用栈。</li><li><strong>括号匹配</strong>：检查代码中括号的匹配情况。</li><li><strong>深度优先搜索（DFS）</strong>：在图的深度优先搜索算法中，栈用于存储路径信息。</li></ul><h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><p><strong>队列</strong>是一种特殊的线性数据结构，遵循 <strong>FIFO（First In First Out）</strong> 原则，即最先进入队列的元素最先被移出。队列通常用于需要按顺序处理数据的场景，比如任务调度、广度优先搜索等。</p><p><img src="https://cdn.jsdelivr.net/gh/Barbecue-g/imagehost/Language/C/C_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%98%9F%E5%88%97.png" alt="队列"></p><h3 id="数据结构-3"><a href="#数据结构-3" class="headerlink" title="数据结构"></a>数据结构</h3><p>队列可以由队列节点结构和队列结构实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义队列节点结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> data;              <span class="comment">// 数据域</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">next</span>;</span>     <span class="comment">// 指向下一个节点的指针</span></span><br><span class="line">&#125; Node;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义队列结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Queue</span> &#123;</span></span><br><span class="line">    Node* front;           <span class="comment">// 队列头</span></span><br><span class="line">    Node* rear;            <span class="comment">// 队列尾</span></span><br><span class="line">&#125; Queue;</span><br></pre></td></tr></table></figure><h3 id="基本操作-3"><a href="#基本操作-3" class="headerlink" title="基本操作"></a>基本操作</h3><ol><li><p><strong>初始化队列</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">initQueue</span><span class="params">(Queue* q)</span> &#123;</span><br><span class="line">    q-&gt;front = q-&gt;rear = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>入队操作（Enqueue）</strong>：</p><p>将一个元素添加到队列的末尾。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">enqueue</span><span class="params">(Queue* q, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">    Node* newNode = (Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    newNode-&gt;data = value;</span><br><span class="line">    newNode-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (q-&gt;rear == <span class="literal">NULL</span>) &#123;    <span class="comment">// 队列为空时</span></span><br><span class="line">        q-&gt;front = q-&gt;rear = newNode;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        q-&gt;rear-&gt;next = newNode;</span><br><span class="line">        q-&gt;rear = newNode;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>出队操作（Dequeue）</strong>：</p><p>从队列的头部移除并返回一个元素。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">dequeue</span><span class="params">(Queue* q)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (q-&gt;front == <span class="literal">NULL</span>) &#123;   <span class="comment">// 队列为空时</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;            <span class="comment">// 表示队列为空</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node* temp = q-&gt;front;</span><br><span class="line">    <span class="type">int</span> value = temp-&gt;data;</span><br><span class="line">    q-&gt;front = q-&gt;front-&gt;next;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (q-&gt;front == <span class="literal">NULL</span>) &#123;   <span class="comment">// 队列为空时</span></span><br><span class="line">        q-&gt;rear = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(temp);</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>查看队列头部元素（Peek）</strong>：</p><p>获取队列头部的元素，但不移除它。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">peek</span><span class="params">(Queue* q)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (q-&gt;front == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;  <span class="comment">// 队列为空</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> q-&gt;front-&gt;data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>检查队列是否为空（IsEmpty）</strong>：</p><p>判断队列是否为空。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">isEmpty</span><span class="params">(Queue* q)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> q-&gt;front == <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="性能分析-3"><a href="#性能分析-3" class="headerlink" title="性能分析"></a>性能分析</h3><p><strong>时间复杂度</strong></p><ul><li><strong>入队（Enqueue）</strong>: O(1)，因为每次操作都只涉及队列尾部。</li><li><strong>出队（Dequeue）</strong>: O(1)，因为每次操作都只涉及队列头部。</li><li><strong>查看队列头部（Peek）</strong>: O(1)，只需读取头部元素。</li><li><strong>检查是否为空（IsEmpty）</strong>: O(1)，只需检查指针是否为空。</li></ul><p><strong>空间复杂度</strong></p><ul><li>空间复杂度为 O(n)，其中 n 是队列中元素的数量。每个节点占用固定大小的内存。</li></ul><h3 id="应用场景-3"><a href="#应用场景-3" class="headerlink" title="应用场景"></a>应用场景</h3><ol><li><strong>任务调度</strong>: 例如操作系统中的进程调度，保证任务按到达顺序依次处理。</li><li><strong>广度优先搜索(BFS)</strong>: 在图的遍历中使用队列来按层次访问节点。</li><li><strong>缓冲区管理</strong>: 处理数据流时，使用队列作为缓冲区，保证数据按顺序被处理。</li><li><strong>消息队列</strong>: 在分布式系统中，队列用来缓存和传递消息。</li></ol><h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><p>哈希表（Hash Table）是一种用于快速查找的常用数据结构。通过哈希函数（Hash Function）将键（Key）映射到存储位置，从而实现对数据的高效查找、插入和删除。哈希表的核心思想是利用数组的快速访问特点，将键值映射为数组的下标，进行查找、插入和删除操作的时间复杂度可以接近O(1)。</p><p><img src="https://cdn.jsdelivr.net/gh/Barbecue-g/imagehost/Language/C/C_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%93%88%E5%B8%8C%E8%A1%A8.png" alt="哈希表"></p><h3 id="数据结构-4"><a href="#数据结构-4" class="headerlink" title="数据结构"></a>数据结构</h3><h4 id="哈希函数"><a href="#哈希函数" class="headerlink" title="哈希函数"></a>哈希函数</h4><p>哈希函数是将键转换为数组索引的函数，设计一个好的哈希函数可以减少冲突。常见的哈希函数有取模法、乘法散列法等。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">hash_function</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> table_size)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> key % table_size;  <span class="comment">// 取模法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="冲突解决"><a href="#冲突解决" class="headerlink" title="冲突解决"></a>冲突解决</h4><p>由于哈希表的有限大小，不同的键值可能映射到相同的数组索引位置，这种现象称为冲突（Collision）。常见的冲突解决方法有开放地址法和链地址法。</p><ol><li><strong>开放地址法（Open Addressing）</strong>: 冲突时寻找下一个空闲的数组位置。</li><li><strong>链地址法（Chaining）</strong>: 使用链表将所有冲突的键值存储在同一个数组位置。</li></ol><p>定义链表节点</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> TABLE_SIZE 10</span></span><br><span class="line"><span class="comment">// 定义链表节点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> key;</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125; Node;</span><br></pre></td></tr></table></figure><p>定义哈希表</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    Node* buckets[TABLE_SIZE];</span><br><span class="line">&#125; HashTable;</span><br></pre></td></tr></table></figure><h3 id="基本操作-4"><a href="#基本操作-4" class="headerlink" title="基本操作"></a>基本操作</h3><ol><li><p><strong>初始化哈希表</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">init_hash_table</span><span class="params">(HashTable* table)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; TABLE_SIZE; i++) &#123;</span><br><span class="line">        table-&gt;buckets[i] = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>插入键值对</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">insert</span><span class="params">(HashTable* table, <span class="type">int</span> key, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> index = hash_function(key, TABLE_SIZE);</span><br><span class="line">    Node* new_node = (Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    new_node-&gt;key = key;</span><br><span class="line">    new_node-&gt;value = value;</span><br><span class="line">    new_node-&gt;next = table-&gt;buckets[index];</span><br><span class="line">    table-&gt;buckets[index] = new_node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>查找键对应的值</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">search</span><span class="params">(HashTable* table, <span class="type">int</span> key)</span> &#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> index = hash_function(key, TABLE_SIZE);</span><br><span class="line">    Node* node = table-&gt;buckets[index];</span><br><span class="line">    <span class="keyword">while</span> (node != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;key == key) &#123;</span><br><span class="line">            <span class="keyword">return</span> node-&gt;value;</span><br><span class="line">        &#125;</span><br><span class="line">        node = node-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">// 表示未找到</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>删除键值对</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">delete</span><span class="params">(HashTable* table, <span class="type">int</span> key)</span> &#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> index = hash_function(key, TABLE_SIZE);</span><br><span class="line">    Node* node = table-&gt;buckets[index];</span><br><span class="line">    Node* prev = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span> (node != <span class="literal">NULL</span> &amp;&amp; node-&gt;key != key) &#123;</span><br><span class="line">        prev = node;</span><br><span class="line">        node = node-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (node != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (prev == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            table-&gt;buckets[index] = node-&gt;next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            prev-&gt;next = node-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">free</span>(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="性能分析-4"><a href="#性能分析-4" class="headerlink" title="性能分析"></a>性能分析</h3><p><strong>时间复杂度</strong>：</p><ul><li><strong>插入</strong>：平均情况下 O(1)，最坏情况下 O(n)（所有元素哈希冲突在同一个桶内）。</li><li><strong>查找</strong>：平均情况下 O(1)，最坏情况下 O(n)。</li><li><strong>删除</strong>：平均情况下 O(1)，最坏情况下 O(n)。</li></ul><p><strong>空间复杂度</strong>：O(n) 用于存储所有元素，外加 O(m) 用于存储桶数组（其中 m 是桶的数量）。</p><h3 id="应用场景-4"><a href="#应用场景-4" class="headerlink" title="应用场景"></a>应用场景</h3><p>哈希表适用于以下场景：</p><ul><li><strong>快速查找&#x2F;插入&#x2F;删除</strong>：需要在常数时间内快速查找数据、频繁插入和删除元素，哈希表提供高效的 O(1) 操作。如字典、缓存。</li><li><strong>唯一性检查</strong>：用于快速判断一个元素是否存在，如检测重复元素。</li><li><strong>计数器</strong>：如统计字符频率、单词频率等。</li><li><strong>集合操作</strong>：哈希表可以用于集合操作，如求交集、并集、差集等。</li></ul><p>不适用于：</p><ul><li>需要维持数据有序的场合，哈希表无法保持元素的顺序。</li><li>空间有限且哈希表装载因子较高时，冲突增多可能导致性能下降。</li></ul><p>哈希表在需要高效键值对操作的场景中表现尤为出色，但需要注意选择合适的哈希函数以及处理冲突的方法，以避免性能退化。</p><h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><p>二叉树是一种树形数据结构，每个节点最多有两个子节点，分别称为左子节点和右子节点。二叉树通常用于组织数据以实现快速的查找、插入和删除操作。</p><p><img src="https://cdn.jsdelivr.net/gh/Barbecue-g/imagehost/Language/C/C_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E4%BA%8C%E5%8F%89%E6%A0%91.png" alt="二叉树"></p><ul><li><strong>满二叉树</strong>：每一层的结点数目都达到最大值</li><li><strong>完全二叉树</strong>：一个二叉树除了最后一层，其他层都是满的，且最后一层的节点连续排列在最左边。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Barbecue-g/imagehost/Language/C/C_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%BB%A1or%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91.png" alt="满or完全二叉树"></p><p>(a)满二叉树；(b)完全二叉树；(c)和(d)非完全二叉树</p><p>二叉树具有以下性质：</p><ul><li>高度为 <code>h</code> 的二叉树最多有 <code>2^h - 1</code> 个节点。</li><li>对于 <code>n</code> 个节点的完全二叉树，其高度 <code>h</code> 为 <code>log2(n+1)</code>。</li></ul><h3 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h3><p>二叉搜索树（二叉排序树）是一种特殊的二叉树，其中每个节点都遵循以下规则：</p><ul><li>左子树中所有节点的值都小于根节点的值。</li><li>右子树中所有节点的值都大于根节点的值。</li><li>每个节点的左右子树也都是二叉搜索树。</li></ul><p>二叉搜索树在搜索、插入和删除操作时具有较好的性能。</p><h4 id="数据结构-5"><a href="#数据结构-5" class="headerlink" title="数据结构"></a>数据结构</h4><p>二叉搜索树节点的基本结构：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 二叉搜索树节点结构</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> val;                <span class="comment">// 节点的值</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>* <span class="title">left</span>;</span>  <span class="comment">// 指向左子树的指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>* <span class="title">right</span>;</span> <span class="comment">// 指向右子树的指针</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="基本操作-5"><a href="#基本操作-5" class="headerlink" title="基本操作"></a>基本操作</h4><ol><li><p><strong>创建新的二叉搜索树节点</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> TreeNode* <span class="title function_">createNode</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>* <span class="title">newNode</span> =</span> (<span class="keyword">struct</span> TreeNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> TreeNode));</span><br><span class="line">    newNode-&gt;val = val;</span><br><span class="line">    newNode-&gt;left = <span class="literal">NULL</span>;</span><br><span class="line">    newNode-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> newNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>插入节点</strong>：</p><p>插入节点时，从根节点开始，根据值的大小递归地找到适当的空位置插入新节点。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> TreeNode* <span class="title function_">insertNode</span><span class="params">(<span class="keyword">struct</span> TreeNode* root, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">    <span class="comment">// 如果树为空，则创建一个新节点</span></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> createNode(val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 递归地插入到左子树或右子树</span></span><br><span class="line">    <span class="keyword">if</span> (val &lt; root-&gt;val) &#123;</span><br><span class="line">        root-&gt;left = insertNode(root-&gt;left, val);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (val &gt; root-&gt;val) &#123;</span><br><span class="line">        root-&gt;right = insertNode(root-&gt;right, val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回（未变更的）节点指针</span></span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>搜索节点</strong>：</p><p>搜索时，根据当前节点的值和目标值的比较结果决定向左子树或右子树递归。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> TreeNode* <span class="title function_">searchNode</span><span class="params">(<span class="keyword">struct</span> TreeNode* root, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">    <span class="comment">// 如果找不到或者找到匹配的节点，则返回</span></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span> || root-&gt;val == val) &#123;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果目标值小于当前节点的值，继续在左子树中搜索</span></span><br><span class="line">    <span class="keyword">if</span> (val &lt; root-&gt;val) &#123;</span><br><span class="line">        <span class="keyword">return</span> searchNode(root-&gt;left, val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 否则继续在右子树中搜索</span></span><br><span class="line">    <span class="keyword">return</span> searchNode(root-&gt;right, val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>删除节点</strong>：</p><p>删除节点分为三种情况：</p><ul><li>要删除的节点是叶子节点（无子树）。</li><li>要删除的节点有一个子树。</li><li>要删除的节点有两个子树：此时需找到右子树中的最小节点（或左子树中的最大节点）代替被删除的节点。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> TreeNode* <span class="title function_">findMinNode</span><span class="params">(<span class="keyword">struct</span> TreeNode* node)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>* <span class="title">current</span> =</span> node;</span><br><span class="line">    <span class="keyword">while</span> (current &amp;&amp; current-&gt;left != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        current = current-&gt;left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> current;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> TreeNode* <span class="title function_">deleteNode</span><span class="params">(<span class="keyword">struct</span> TreeNode* root, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">    <span class="comment">// 基本情况</span></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 递归找到要删除的节点</span></span><br><span class="line">    <span class="keyword">if</span> (val &lt; root-&gt;val) &#123;</span><br><span class="line">        root-&gt;left = deleteNode(root-&gt;left, val);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (val &gt; root-&gt;val) &#123;</span><br><span class="line">        root-&gt;right = deleteNode(root-&gt;right, val);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 找到要删除的节点</span></span><br><span class="line">        <span class="comment">// 情况1：节点没有子节点（叶子节点）</span></span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left == <span class="literal">NULL</span> &amp;&amp; root-&gt;right == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="built_in">free</span>(root);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 情况2：节点有一个子节点</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (root-&gt;left == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">struct</span> TreeNode* temp = root-&gt;right;</span><br><span class="line">            <span class="built_in">free</span>(root);</span><br><span class="line">            <span class="keyword">return</span> temp;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (root-&gt;right == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">struct</span> TreeNode* temp = root-&gt;left;</span><br><span class="line">            <span class="built_in">free</span>(root);</span><br><span class="line">            <span class="keyword">return</span> temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 情况3：节点有两个子节点</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>* <span class="title">temp</span> =</span> findMinNode(root-&gt;right);</span><br><span class="line">        root-&gt;val = temp-&gt;val;</span><br><span class="line">        root-&gt;right = deleteNode(root-&gt;right, temp-&gt;val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>中序遍历（获取有序元素）</strong>：</p><p>二叉搜索树的中序遍历可以获得有序的节点序列。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">inorderTraversal</span><span class="params">(<span class="keyword">struct</span> TreeNode* root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        inorderTraversal(root-&gt;left);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, root-&gt;val);</span><br><span class="line">        inorderTraversal(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="性能分析-5"><a href="#性能分析-5" class="headerlink" title="性能分析"></a>性能分析</h4><p><strong>时间复杂度</strong>:</p><ul><li><strong>查找</strong>: 平均情况下为O(log n)，最坏情况下为O(n)（当树退化为链表时）。</li><li><strong>插入</strong>: 平均情况下为O(log n)，最坏情况下为O(n)。</li><li><strong>删除</strong>: 平均情况下为O(log n)，最坏情况下为O(n)。</li><li><strong>遍历</strong>: O(n)，需要访问每个节点一次。</li></ul><p><strong>空间复杂度</strong>:</p><ul><li>对于n个节点的二叉搜索树，空间复杂度为O(n)，需要存储n个节点。</li></ul><h4 id="应用场景-5"><a href="#应用场景-5" class="headerlink" title="应用场景"></a>应用场景</h4><p>二叉搜索树适用于以下场景：</p><ul><li><strong>动态数据集合</strong>：需要频繁插入、删除和查找操作的应用。</li><li><strong>有序数据输出</strong>：需要频繁获取有序数据的应用。需要快速查找、中序遍历或范围查询的场景。</li><li><strong>字典、集合实现</strong>：基于键值对操作的数据结构，比如实现符号表。</li></ul><p>二叉搜索树适用于需要动态管理有序数据的场景，但需注意在最坏情况下，树的性能会退化到线性时间复杂度。为了保持平衡，可以考虑使用自平衡二叉搜索树（如红黑树或AVL树）来确保更好的性能。</p><h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><p>堆（Heap）是一种特殊的二叉树，它可以分为<strong>最大堆</strong>和<strong>最小堆</strong>。</p><ul><li><p><strong>完全二叉树</strong>：除了最后一层外，所有层的节点都被填满，最后一层的节点从左到右依次填充。</p></li><li><p><strong>最大堆</strong>：在最大堆中，每个父节点的值都大于或等于其子节点的值。</p></li><li><p><strong>最小堆</strong>：在最小堆中，每个父节点的值都小于或等于其子节点的值。</p></li></ul><p>堆通常用<strong>数组</strong>来实现，而非实际的二叉树。假设节点的索引为<code>i</code>，则有以下关系：</p><ul><li>父节点索引为 <code>(i - 1) / 2</code></li><li>左子节点索引为 <code>2 * i + 1</code></li><li>右子节点索引为 <code>2 * i + 2</code></li></ul><h4 id="数据结构-6"><a href="#数据结构-6" class="headerlink" title="数据结构"></a>数据结构</h4><p>下面是一个简单的堆实现（以最大堆为例）:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_SIZE 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> data[MAX_SIZE];  <span class="comment">// 用数组表示堆</span></span><br><span class="line">    <span class="type">int</span> size;            <span class="comment">// 当前堆的大小</span></span><br><span class="line">&#125; Heap;</span><br></pre></td></tr></table></figure><h4 id="基本操作-6"><a href="#基本操作-6" class="headerlink" title="基本操作"></a>基本操作</h4><ol><li><p><strong>初始化堆</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">initHeap</span><span class="params">(Heap *h)</span> &#123;</span><br><span class="line">    h-&gt;size = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>插入操作</strong>：</p><p>插入新元素到堆中，并维护堆的性质。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">insert</span><span class="params">(Heap *h, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (h-&gt;size &gt;= MAX_SIZE) <span class="keyword">return</span>;  <span class="comment">// 堆满</span></span><br><span class="line">    <span class="type">int</span> i = h-&gt;size++;</span><br><span class="line">    h-&gt;data[i] = value;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 向上调整</span></span><br><span class="line">    <span class="keyword">while</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">int</span> parent = (i - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (h-&gt;data[i] &lt;= h-&gt;data[parent]) <span class="keyword">break</span>;</span><br><span class="line">        <span class="type">int</span> temp = h-&gt;data[i];</span><br><span class="line">        h-&gt;data[i] = h-&gt;data[parent];</span><br><span class="line">        h-&gt;data[parent] = temp;</span><br><span class="line">        i = parent;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>删除操作（删除根节点）</strong>：</p><p>删除堆顶元素，并维护堆的性质。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">deleteMax</span><span class="params">(Heap *h)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (h-&gt;size == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;  <span class="comment">// 堆为空</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> max = h-&gt;data[<span class="number">0</span>];</span><br><span class="line">    h-&gt;data[<span class="number">0</span>] = h-&gt;data[--h-&gt;size];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 向下调整</span></span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">2</span> * i + <span class="number">1</span> &lt; h-&gt;size) &#123;</span><br><span class="line">        <span class="type">int</span> leftChild = <span class="number">2</span> * i + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> rightChild = <span class="number">2</span> * i + <span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span> largest = i;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (leftChild &lt; h-&gt;size &amp;&amp; h-&gt;data[leftChild] &gt; h-&gt;data[largest]) &#123;</span><br><span class="line">            largest = leftChild;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (rightChild &lt; h-&gt;size &amp;&amp; h-&gt;data[rightChild] &gt; h-&gt;data[largest]) &#123;</span><br><span class="line">            largest = rightChild;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (largest == i) <span class="keyword">break</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> temp = h-&gt;data[i];</span><br><span class="line">        h-&gt;data[i] = h-&gt;data[largest];</span><br><span class="line">        h-&gt;data[largest] = temp;</span><br><span class="line">        i = largest;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>获取堆顶元素</strong>：</p><p>获取堆中最大值（最大堆）或最小值（最小堆），时间复杂度为 O(1)。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">getMax</span><span class="params">(Heap *h)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (h-&gt;size == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;  <span class="comment">// 堆为空</span></span><br><span class="line">    <span class="keyword">return</span> h-&gt;data[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>堆化（Heapify）</strong>：</p><p>将一个无序数组调整为堆，常用于构建堆排序。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">heapify</span><span class="params">(Heap *h, <span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="type">int</span> leftChild = <span class="number">2</span> * i + <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> rightChild = <span class="number">2</span> * i + <span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> largest = i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (leftChild &lt; h-&gt;size &amp;&amp; h-&gt;data[leftChild] &gt; h-&gt;data[largest]) &#123;</span><br><span class="line">        largest = leftChild;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (rightChild &lt; h-&gt;size &amp;&amp; h-&gt;data[rightChild] &gt; h-&gt;data[largest]) &#123;</span><br><span class="line">        largest = rightChild;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (largest != i) &#123;</span><br><span class="line">        <span class="type">int</span> temp = h-&gt;data[i];</span><br><span class="line">        h-&gt;data[i] = h-&gt;data[largest];</span><br><span class="line">        h-&gt;data[largest] = temp;</span><br><span class="line">        heapify(h, largest);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="性能分析-6"><a href="#性能分析-6" class="headerlink" title="性能分析"></a>性能分析</h4><ul><li><p><strong>插入操作</strong>：时间复杂度为 O(log⁡n)，因为插入元素后，最多需要沿着树向上调整 log⁡n 次。</p></li><li><p><strong>删除操作</strong>：时间复杂度为 O(log⁡n)，因为删除根节点后，最多需要沿着树向下调整 log⁡n 次。</p></li><li><p><strong>获取堆顶元素</strong>：时间复杂度为 O(1)，因为只需返回根节点的值。</p></li><li><p><strong>堆化操作</strong>：时间复杂度为 O(n)，通常用于构建堆。</p></li><li><p><strong>空间复杂度</strong>：堆通常使用数组实现，空间复杂度为 O(n)，其中 n 为堆中元素个数。</p></li></ul><h4 id="应用场景-6"><a href="#应用场景-6" class="headerlink" title="应用场景"></a>应用场景</h4><p>堆适用于以下场景：</p><ul><li><p><strong>优先队列</strong>：堆广泛用于实现优先队列，能够以较高效率找到和移除优先级最高的元素。</p></li><li><p><strong>排序算法</strong>：堆排序是经典的<code>O(nlogn)</code>排序算法，适用于大数据量的排序任务。</p></li><li><p><strong>图算法</strong>：堆在Dijkstra算法和Prim算法中用于高效地选择最短路径或最小生成树中的下一条边。</p></li><li><p><strong>任务调度</strong>：处理多个任务时，堆可以用来调度优先级较高的任务。</p></li></ul><h3 id="平衡树"><a href="#平衡树" class="headerlink" title="平衡树"></a>平衡树</h3><p>平衡树是一种自动调整的数据结构，保证在进行插入、删除、查找等操作时，树的高度始终保持平衡（或接近平衡）。通常平衡树的定义是为了防止树变成一条长链，会导致操作效率下降到 O(n)（线性时间）。在平衡树中，操作的时间复杂度能够保持在 O(log n)，确保高效的查找、插入和删除操作。</p><p>常见的平衡树包括 AVL 树、红黑树等。下面的例子将以 <strong>AVL树</strong> 为例，该树的特性是：每个节点的左右子树的高度差不超过 1。</p><h4 id="数据结构-7"><a href="#数据结构-7" class="headerlink" title="数据结构"></a>数据结构</h4><p>AVL 树作为一种平衡二叉搜索树，能够有效地保证操作的时间复杂度在 O(log n) 范围内，适用于对查找、插入、删除操作都有较高要求的应用场景。 <code>AVL</code> 树的基本数据结构：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">AVLNode</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> key;  <span class="comment">// 节点值</span></span><br><span class="line">    <span class="type">int</span> height;  <span class="comment">// 节点的高度</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">AVLNode</span>* <span class="title">left</span>;</span>  <span class="comment">// 左子树</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">AVLNode</span>* <span class="title">right</span>;</span>  <span class="comment">// 右子树</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="基本操作-7"><a href="#基本操作-7" class="headerlink" title="基本操作"></a>基本操作</h4><ol><li><p><strong>获取节点高度</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">height</span><span class="params">(<span class="keyword">struct</span> AVLNode* node)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> node-&gt;height;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>创建新节点</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> AVLNode* <span class="title function_">createNode</span><span class="params">(<span class="type">int</span> key)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">AVLNode</span>* <span class="title">node</span> =</span> (<span class="keyword">struct</span> AVLNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> AVLNode));</span><br><span class="line">    node-&gt;key = key;</span><br><span class="line">    node-&gt;left = node-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line">    node-&gt;height = <span class="number">1</span>;  <span class="comment">// 新节点的高度为1</span></span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>右旋操作</strong>：</p><p>右旋是指将某个节点及其左子树向右旋转，调整树的平衡。该操作用于在插入或删除节点后，树变得左重时恢复平衡。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> AVLNode* <span class="title function_">rightRotate</span><span class="params">(<span class="keyword">struct</span> AVLNode* y)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">AVLNode</span>* <span class="title">x</span> =</span> y-&gt;left;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">AVLNode</span>* <span class="title">T2</span> =</span> x-&gt;right;</span><br><span class="line">    <span class="comment">// 进行旋转</span></span><br><span class="line">    x-&gt;right = y;</span><br><span class="line">    y-&gt;left = T2;</span><br><span class="line">    <span class="comment">// 更新高度</span></span><br><span class="line">    y-&gt;height = max(height(y-&gt;left), height(y-&gt;right)) + <span class="number">1</span>;</span><br><span class="line">    x-&gt;height = max(height(x-&gt;left), height(x-&gt;right)) + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 返回新的根节点</span></span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>左旋操作</strong>：</p><p>左旋是指将某个节点及其右子树向左旋转，调整树的平衡。该操作用于在插入或删除节点后，树变得右重时恢复平衡。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> AVLNode* <span class="title function_">leftRotate</span><span class="params">(<span class="keyword">struct</span> AVLNode* x)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">AVLNode</span>* <span class="title">y</span> =</span> x-&gt;right;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">AVLNode</span>* <span class="title">T2</span> =</span> y-&gt;left;</span><br><span class="line">    <span class="comment">// 进行旋转</span></span><br><span class="line">    y-&gt;left = x;</span><br><span class="line">    x-&gt;right = T2;</span><br><span class="line">    <span class="comment">// 更新高度</span></span><br><span class="line">    x-&gt;height = max(height(x-&gt;left), height(x-&gt;right)) + <span class="number">1</span>;</span><br><span class="line">    y-&gt;height = max(height(y-&gt;left), height(y-&gt;right)) + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 返回新的根节点</span></span><br><span class="line">    <span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>获取平衡因子</strong>：</p><p>AVL 树的核心在于维护每个节点的平衡因子，平衡因子等于左右子树高度差。如果平衡因子的绝对值大于 1，则该节点需要旋转以保持平衡。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">getBalance</span><span class="params">(<span class="keyword">struct</span> AVLNode* node)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> height(node-&gt;left) - height(node-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>插入节点</strong>：</p><p>在 AVL 树中插入节点后，可能会破坏树的平衡，此时需要通过旋转来恢复平衡。插入时，需要判断四种情况：左左、右右、左右、右左，并选择相应的旋转操作。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> AVLNode* <span class="title function_">insert</span><span class="params">(<span class="keyword">struct</span> AVLNode* node, <span class="type">int</span> key)</span> &#123;</span><br><span class="line">    <span class="comment">// 标准的二叉搜索树插入</span></span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> createNode(key);</span><br><span class="line">    <span class="keyword">if</span> (key &lt; node-&gt;key)</span><br><span class="line">        node-&gt;left = insert(node-&gt;left, key);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (key &gt; node-&gt;key)</span><br><span class="line">        node-&gt;right = insert(node-&gt;right, key);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> node; <span class="comment">// 键值已存在，返回不做插入</span></span><br><span class="line">    <span class="comment">// 更新节点高度</span></span><br><span class="line">    node-&gt;height = <span class="number">1</span> + max(height(node-&gt;left), height(node-&gt;right));</span><br><span class="line">    <span class="comment">// 获取当前节点的平衡因子</span></span><br><span class="line">    <span class="type">int</span> balance = getBalance(node);</span><br><span class="line">    <span class="comment">// 如果节点不平衡，进行相应旋转</span></span><br><span class="line">    <span class="comment">// 左左情况</span></span><br><span class="line">    <span class="keyword">if</span> (balance &gt; <span class="number">1</span> &amp;&amp; key &lt; node-&gt;left-&gt;key)</span><br><span class="line">        <span class="keyword">return</span> rightRotate(node);</span><br><span class="line">    <span class="comment">// 右右情况</span></span><br><span class="line">    <span class="keyword">if</span> (balance &lt; <span class="number">-1</span> &amp;&amp; key &gt; node-&gt;right-&gt;key)</span><br><span class="line">        <span class="keyword">return</span> leftRotate(node);</span><br><span class="line">    <span class="comment">// 左右情况</span></span><br><span class="line">    <span class="keyword">if</span> (balance &gt; <span class="number">1</span> &amp;&amp; key &gt; node-&gt;left-&gt;key) &#123;</span><br><span class="line">        node-&gt;left = leftRotate(node-&gt;left);</span><br><span class="line">        <span class="keyword">return</span> rightRotate(node);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 右左情况</span></span><br><span class="line">    <span class="keyword">if</span> (balance &lt; <span class="number">-1</span> &amp;&amp; key &lt; node-&gt;right-&gt;key) &#123;</span><br><span class="line">        node-&gt;right = rightRotate(node-&gt;right);</span><br><span class="line">        <span class="keyword">return</span> leftRotate(node);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>查找节点</strong>：</p><p>查找节点与标准的二叉搜索树相同。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> AVLNode* <span class="title function_">search</span><span class="params">(<span class="keyword">struct</span> AVLNode* root, <span class="type">int</span> key)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span> || root-&gt;key == key)</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    <span class="keyword">if</span> (key &lt; root-&gt;key)</span><br><span class="line">        <span class="keyword">return</span> search(root-&gt;left, key);</span><br><span class="line">    <span class="keyword">return</span> search(root-&gt;right, key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>删除节点</strong>：</p><p>删除节点后也可能破坏树的平衡，因此同样需要进行平衡因子的检查与旋转操作。删除的核心与标准二叉搜索树类似，之后根据不同的情况调整平衡。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 找到最小值节点</span></span><br><span class="line"><span class="keyword">struct</span> AVLNode* <span class="title function_">minValueNode</span><span class="params">(<span class="keyword">struct</span> AVLNode* node)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">AVLNode</span>* <span class="title">current</span> =</span> node;</span><br><span class="line">    <span class="comment">// 找到最左边的叶子节点</span></span><br><span class="line">    <span class="keyword">while</span> (current-&gt;left != <span class="literal">NULL</span>)</span><br><span class="line">        current = current-&gt;left;</span><br><span class="line">    <span class="keyword">return</span> current;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除节点并维持平衡</span></span><br><span class="line"><span class="keyword">struct</span> AVLNode* <span class="title function_">deleteNode</span><span class="params">(<span class="keyword">struct</span> AVLNode* root, <span class="type">int</span> key)</span> &#123;</span><br><span class="line">    <span class="comment">// 标准二叉搜索树删除</span></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    <span class="keyword">if</span> (key &lt; root-&gt;key)</span><br><span class="line">        root-&gt;left = deleteNode(root-&gt;left, key);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (key &gt; root-&gt;key)</span><br><span class="line">        root-&gt;right = deleteNode(root-&gt;right, key);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 单子节点或无子节点</span></span><br><span class="line">        <span class="keyword">if</span> ((root-&gt;left == <span class="literal">NULL</span>) || (root-&gt;right == <span class="literal">NULL</span>)) &#123;</span><br><span class="line">            <span class="keyword">struct</span> AVLNode* temp = root-&gt;left ? root-&gt;left : root-&gt;right;</span><br><span class="line">            <span class="keyword">if</span> (temp == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                temp = root;</span><br><span class="line">                root = <span class="literal">NULL</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span></span><br><span class="line">                *root = *temp;</span><br><span class="line">            <span class="built_in">free</span>(temp);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 找到右子树的最小节点</span></span><br><span class="line">            <span class="keyword">struct</span> AVLNode* temp = minValueNode(root-&gt;right);</span><br><span class="line">            root-&gt;key = temp-&gt;key;</span><br><span class="line">            root-&gt;right = deleteNode(root-&gt;right, temp-&gt;key);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    <span class="comment">// 更新节点高度</span></span><br><span class="line">    root-&gt;height = <span class="number">1</span> + max(height(root-&gt;left), height(root-&gt;right));</span><br><span class="line">    <span class="comment">// 检查平衡因子</span></span><br><span class="line">    <span class="type">int</span> balance = getBalance(root);</span><br><span class="line">    <span class="comment">// 左左情况</span></span><br><span class="line">    <span class="keyword">if</span> (balance &gt; <span class="number">1</span> &amp;&amp; getBalance(root-&gt;left) &gt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> rightRotate(root);</span><br><span class="line">    <span class="comment">// 左右情况</span></span><br><span class="line">    <span class="keyword">if</span> (balance &gt; <span class="number">1</span> &amp;&amp; getBalance(root-&gt;left) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        root-&gt;left = leftRotate(root-&gt;left);</span><br><span class="line">        <span class="keyword">return</span> rightRotate(root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 右右情况</span></span><br><span class="line">    <span class="keyword">if</span> (balance &lt; <span class="number">-1</span> &amp;&amp; getBalance(root-&gt;right) &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> leftRotate(root);</span><br><span class="line">    <span class="comment">// 右左情况</span></span><br><span class="line">    <span class="keyword">if</span> (balance &lt; <span class="number">-1</span> &amp;&amp; getBalance(root-&gt;right) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        root-&gt;right = rightRotate(root-&gt;right);</span><br><span class="line">        <span class="keyword">return</span> leftRotate(root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="性能分析-7"><a href="#性能分析-7" class="headerlink" title="性能分析"></a>性能分析</h4><p><strong>时间复杂度</strong>：</p><ul><li>插入、删除、查找操作的时间复杂度均为 O(log n)，因为 AVL 树的高度始终保持在 O(log n) 的范围内。</li></ul><p><strong>空间复杂度</strong>：</p><ul><li>在最坏情况下，AVL 树的额外空间复杂度为 O(n)，主要用于存储每个节点的指针以及递归栈的深度。</li></ul><h4 id="应用场景-7"><a href="#应用场景-7" class="headerlink" title="应用场景"></a>应用场景</h4><ul><li><p><code>AVL</code> 树适用于对查找操作要求较高的场景，它能确保树的高度始终平衡，查找性能良好。</p></li><li><p>在需要频繁插入和删除数据的场景下，<code>AVL</code> 树也能够通过旋转保持平衡，从而保证操作效率。</p></li></ul><h2 id="图"><a href="#图" class="headerlink" title="图"></a>图</h2><p>图（Graph）是一种非常重要的非线性数据结构，由<strong>顶点（Vertex）</strong>和<strong>边（Edge）</strong>组成。图用于表示对象（顶点）之间的关系（边），广泛应用于社交网络、网络路由、搜索引擎等领域。图可分为以下几类：</p><ul><li><p><strong>无向图</strong>：边没有方向，边<code>(u, v)</code>与<code>(v, u)</code>等价。</p></li><li><p><strong>有向图</strong>：边有方向，边<code>(u, v)</code>与<code>(v, u)</code>不等价。</p></li><li><p><strong>加权图</strong>：边带有权重（Weight），表示两个顶点之间的距离或代价。</p></li><li><p><strong>无权图</strong>：边没有权重。</p></li></ul><p>此外，图还可以表示为<strong>稀疏图</strong>（Sparse Graph）和<strong>稠密图</strong>（Dense Graph）：</p><ul><li><strong>稀疏图</strong>：边的数量远小于顶点数的平方。</li><li><strong>稠密图</strong>：边的数量接近于顶点数的平方。</li></ul><h3 id="数据结构-8"><a href="#数据结构-8" class="headerlink" title="数据结构"></a>数据结构</h3><p>图的数据结构可以通过<strong>邻接矩阵</strong>（Adjacency Matrix）或<strong>邻接表</strong>（Adjacency List）来实现。</p><ul><li><p><strong>邻接矩阵</strong></p><p>邻接矩阵是一种二维数组，用于表示图中节点之间的连接关系。假设图中有 <code>n</code> 个节点，<code>matrix[i][j]</code> 表示节点 <code>i</code> 和节点 <code>j</code> 之间的连接关系。若为无向图，<code>matrix[i][j] = matrix[j][i]</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_VERTICES 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> matrix[MAX_VERTICES][MAX_VERTICES];  <span class="comment">// 用二维数组表示图</span></span><br><span class="line">    <span class="type">int</span> numVertices;                         <span class="comment">// 图的顶点数量</span></span><br><span class="line">&#125; Graph;</span><br></pre></td></tr></table></figure><p><strong>初始化图</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">initGraph</span><span class="params">(Graph* g, <span class="type">int</span> numVertices)</span> &#123;</span><br><span class="line">    g-&gt;numVertices = numVertices;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numVertices; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; numVertices; j++) &#123;</span><br><span class="line">            g-&gt;matrix[i][j] = <span class="number">0</span>; <span class="comment">// 初始化矩阵为0，表示没有边</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>添加边</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">addEdge</span><span class="params">(Graph* g, <span class="type">int</span> src, <span class="type">int</span> dest)</span> &#123;</span><br><span class="line">    g-&gt;matrix[src][dest] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>移除边</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">removeEdge</span><span class="params">(Graph* g, <span class="type">int</span> src, <span class="type">int</span> dest)</span> &#123;</span><br><span class="line">    g-&gt;matrix[src][dest] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>邻接表</strong></p><p>邻接表是一种链表数组，数组中的每个元素都是一个链表，用于存储与某个顶点相连的所有顶点。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_VERTICES 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> vertex;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125; Node;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    Node* <span class="built_in">list</span>[MAX_VERTICES];  <span class="comment">// 用数组存储每个顶点的邻接链表</span></span><br><span class="line">    <span class="type">int</span> numVertices;           <span class="comment">// 图的顶点数量</span></span><br><span class="line">&#125; Graph;</span><br></pre></td></tr></table></figure><p><strong>初始化图</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">initGraph</span><span class="params">(Graph* g, <span class="type">int</span> numVertices)</span> &#123;</span><br><span class="line">    g-&gt;numVertices = numVertices;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numVertices; i++) &#123;</span><br><span class="line">        g-&gt;<span class="built_in">list</span>[i] = <span class="literal">NULL</span>;  <span class="comment">// 初始化链表为空</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>创建节点</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Node* <span class="title function_">createNode</span><span class="params">(<span class="type">int</span> vertex)</span> &#123;</span><br><span class="line">    Node* newNode = (Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    newNode-&gt;vertex = vertex;</span><br><span class="line">    newNode-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> newNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>添加边</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">addEdge</span><span class="params">(Graph* g, <span class="type">int</span> src, <span class="type">int</span> dest)</span> &#123;</span><br><span class="line">    Node* newNode = createNode(dest);</span><br><span class="line">    newNode-&gt;next = g-&gt;<span class="built_in">list</span>[src];</span><br><span class="line">    g-&gt;<span class="built_in">list</span>[src] = newNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>移除边</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">removeEdge</span><span class="params">(Graph* g, <span class="type">int</span> src, <span class="type">int</span> dest)</span> &#123;</span><br><span class="line">    Node* temp = g-&gt;<span class="built_in">list</span>[src];</span><br><span class="line">    Node* prev = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span> (temp != <span class="literal">NULL</span> &amp;&amp; temp-&gt;vertex != dest) &#123;</span><br><span class="line">        prev = temp;</span><br><span class="line">        temp = temp-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (temp != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (prev != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            prev-&gt;next = temp-&gt;next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            g-&gt;<span class="built_in">list</span>[src] = temp-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">free</span>(temp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="基本操作-8"><a href="#基本操作-8" class="headerlink" title="基本操作"></a>基本操作</h3><p>图的遍历常见的有两种方式：<strong>深度优先遍历</strong>（DFS）和<strong>广度优先遍历</strong>（BFS）。</p><ul><li><p><strong>DFS（深度优先搜索）</strong>: 使用递归实现，沿着每一个路径深入到不能再深入为止，然后回溯。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">DFS</span><span class="params">(Graph* g, <span class="type">int</span> vertex, <span class="type">int</span> visited[])</span> &#123;</span><br><span class="line">    visited[vertex] = <span class="number">1</span>; <span class="comment">// 标记当前节点为已访问</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, vertex); <span class="comment">// 访问节点</span></span><br><span class="line"></span><br><span class="line">    Node* adjList = g-&gt;<span class="built_in">list</span>[vertex];</span><br><span class="line">    Node* temp = adjList;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (temp != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="type">int</span> connectedVertex = temp-&gt;vertex;</span><br><span class="line">        <span class="keyword">if</span> (visited[connectedVertex] == <span class="number">0</span>) &#123;</span><br><span class="line">            DFS(g, connectedVertex, visited);</span><br><span class="line">        &#125;</span><br><span class="line">        temp = temp-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>BFS（广度优先搜索）</strong>: 使用队列实现，从一个顶点开始，先访问其所有邻接顶点，然后逐层访问。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">BFS</span><span class="params">(Graph* g, <span class="type">int</span> startVertex)</span> &#123;</span><br><span class="line">    <span class="type">int</span> visited[MAX_VERTICES] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    Queue* <span class="built_in">queue</span> = createQueue();</span><br><span class="line"></span><br><span class="line">    visited[startVertex] = <span class="number">1</span>;</span><br><span class="line">    enqueue(<span class="built_in">queue</span>, startVertex);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!isEmpty(<span class="built_in">queue</span>)) &#123;</span><br><span class="line">        <span class="type">int</span> currentVertex = dequeue(<span class="built_in">queue</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, currentVertex);</span><br><span class="line"></span><br><span class="line">        Node* temp = g-&gt;<span class="built_in">list</span>[currentVertex];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (temp) &#123;</span><br><span class="line">            <span class="type">int</span> adjVertex = temp-&gt;vertex;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (visited[adjVertex] == <span class="number">0</span>) &#123;</span><br><span class="line">                visited[adjVertex] = <span class="number">1</span>;</span><br><span class="line">                enqueue(<span class="built_in">queue</span>, adjVertex);</span><br><span class="line">            &#125;</span><br><span class="line">            temp = temp-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="性能分析-8"><a href="#性能分析-8" class="headerlink" title="性能分析"></a>性能分析</h3><p><strong>邻接矩阵</strong>：</p><ul><li><strong>时间复杂度</strong>：添加边、移除边、检查边存在性：O(1)；遍历所有邻接顶点：O(V)</li><li><strong>空间复杂度</strong>：O(V^2)，其中V是图中顶点的数量。不适合稀疏图，会浪费大量空间。</li></ul><p><strong>邻接表</strong>：</p><ul><li><strong>时间复杂度</strong>：添加边：O(1)；移除边、检查边存在性、遍历所有邻接顶点：O(E&#x2F;V) 平均</li><li><strong>空间复杂度</strong>：O(V + E)，其中E是图中边的数量。适合稀疏图，因为只存储实际存在的边。</li></ul><p>对于稠密图（即边的数量接近于顶点数量的平方），建议使用邻接矩阵。对于稀疏图（即边的数量远小于顶点数量的平方），建议使用邻接表。</p><h3 id="应用场景-8"><a href="#应用场景-8" class="headerlink" title="应用场景"></a>应用场景</h3><ul><li><p><strong>邻接矩阵</strong>：适用于图较小且稠密（边较多）的情况，快速检查两个顶点之间是否有边。如社交网络中的好友关系。</p></li><li><p><strong>邻接表</strong>：适用于图较大且稀疏（边较少）的情况，节省空间，适合存储大量顶点及其关系。如城市间的道路网络。</p></li><li><p><strong>DFS</strong>常用于解决迷宫问题、连通性检测、拓扑排序等。</p></li><li><p><strong>BFS</strong>常用于最短路径问题（如无权图的最短路径），也用于层次遍历（如树的层次遍历）。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> C </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C_文件</title>
      <link href="/Language/C/C_%E6%96%87%E4%BB%B6"/>
      <url>/Language/C/C_%E6%96%87%E4%BB%B6</url>
      
        <content type="html"><![CDATA[<h1 id="C-文件I-O"><a href="#C-文件I-O" class="headerlink" title="C_文件I&#x2F;O"></a>C_文件I&#x2F;O</h1><h2 id="流"><a href="#流" class="headerlink" title="流"></a>流</h2><p>在 C 语言中，<strong>流</strong> (stream) 表示任意输入的源或任意输出的目的地。流是一个抽象的概念，即可以表示存储硬盘上的文件，也可以表示网络端口或者打印设备。</p><blockquote><p>Linux哲学：一切皆文件</p></blockquote><h3 id="文件缓冲"><a href="#文件缓冲" class="headerlink" title="文件缓冲"></a>文件缓冲</h3><p>操作系统会在内存上为流设置缓冲区。</p><p><img src="https://cdn.jsdelivr.net/gh/Barbecue-g/imagehost/Language/C/C_%E6%96%87%E4%BB%B6/%E6%96%87%E4%BB%B6%E7%BC%93%E5%86%B2.png" alt="文件缓冲"></p><p>缓冲区是以<strong>先进先出</strong>的方式管理数据的。缓冲区分为三种类型：</p><ul><li><p>满缓冲：当缓冲区空时，从输入流中读取数据；当缓冲区满时，向输出流中写入数据。</p></li><li><p>行缓冲：每次从输入流中读取一行数据；每次向输出流中写入一行数据 (stdin,stdout)。</p></li><li><p>无缓冲：顾名思义，就是没有缓冲区 (stderr)。</p></li></ul><h3 id="文件指针"><a href="#文件指针" class="headerlink" title="文件指针"></a>文件指针</h3><p>在C语言中，文件指针是用来处理文件读写操作的一种特殊类型的指针。在使用文件指针之前，需要先定义一个指向 <code>FILE</code> 类型的指针变量，用于表示文件指针。 <code>FILE</code> 类型定义在 <code>stdio.h</code> 头文件中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">short</span>           level;  <span class="comment">// 缓冲区&quot;满&quot;或者&quot;空&quot;的程度 </span></span><br><span class="line">    <span class="type">unsigned</span>        flags;  <span class="comment">// 文件状态标志 </span></span><br><span class="line">    <span class="type">char</span>            fd;     <span class="comment">// 文件描述符</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span>   hold;   <span class="comment">// 如无缓冲区不读取字符</span></span><br><span class="line">    <span class="type">short</span>           bsize;  <span class="comment">// 缓冲区的大小</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span>*  buffer; <span class="comment">// 数据缓冲区的位置 </span></span><br><span class="line">    <span class="type">unsigned</span>        ar;     <span class="comment">// 指针，当前的指向 </span></span><br><span class="line">    <span class="type">unsigned</span>        istemp; <span class="comment">// 临时文件，指示器</span></span><br><span class="line">    <span class="type">short</span>           token;  <span class="comment">// 用于有效性的检查 </span></span><br><span class="line">&#125;FILE;</span><br></pre></td></tr></table></figure><p>C语言中对文件的各种操作都是基于文件指针来实现的，每操作一个文件都应该让其对应一个文件指针</p><h3 id="标准流"><a href="#标准流" class="headerlink" title="标准流"></a>标准流</h3><p>C 语言对流的访问是通过<strong>文件指针</strong>实现的，类型为 <code>FILE*</code> 。并且在 <code>&lt;stdio.h&gt;</code> 头文件中提供了 3 个标准流。这 3 个标准流可以直接使用</p><table><thead><tr><th align="center">文件指针</th><th align="center">流</th><th align="center">默认函数</th></tr></thead><tbody><tr><td align="center">stdin</td><td align="center">标准输入</td><td align="center"><code>scanf</code></td></tr><tr><td align="center">stdout</td><td align="center">标准输出</td><td align="center"><code>printf</code></td></tr><tr><td align="center">stderr</td><td align="center">标准错误</td><td align="center"><code>fprintf</code></td></tr></tbody></table><p>在进行文件操作的时候，定义文件指针的方式如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FILE *filePointer;</span><br></pre></td></tr></table></figure><h3 id="文件文本和二进制文本"><a href="#文件文本和二进制文本" class="headerlink" title="文件文本和二进制文本"></a>文件文本和二进制文本</h3><p>C 语言支持两种类型的文件：文本文件和二进制文件。文本文件中存储的是字符数据，人类是可以看懂的；二进制文件中的数据，人类是看不懂的。</p><p>文本文件具有两个独特的性质：</p><ul><li><strong>文本文件有行的概念</strong>：文本文件被划分为若干行，并且每一行的结尾都以特殊字符进行标记。在 Windows 系统中，是以回车符和换行符 (\r\n) 进行标记的；在 Unix和 Mac 系统中是以换行符 (\n) 标记的。</li><li><strong>文本文件可能包含一个特殊的</strong> “<strong>文件末尾</strong>“ <strong>标记</strong>：操作系统允许在文本文件的末尾使用一个特殊的字节作为标记。</li></ul><blockquote><p>文本形式可以方便人类阅读和编辑；二进制形式可以节省空间，并且转换效率高。</p></blockquote><h2 id="打开-关闭文件"><a href="#打开-关闭文件" class="headerlink" title="打开&#x2F;关闭文件"></a>打开&#x2F;关闭文件</h2><h3 id="fopen-函数"><a href="#fopen-函数" class="headerlink" title="fopen 函数"></a><code>fopen</code> 函数</h3><p><code>fopen</code>函数的原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FILE *<span class="title function_">fopen</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *filename, <span class="type">const</span> <span class="type">char</span> *mode)</span>;</span><br></pre></td></tr></table></figure><p>参数：</p><ul><li><code>filename</code>：指定要打开的文件名，需要加上路径（相对、绝对路径）</li><li><code>mode</code>：指定文件的打开模式</li></ul><p>返回值：</p><ul><li>成功：返回指向打开文件的文件指针</li><li>失败：返回 NULL</li></ul><p>关于<code>fopen</code>函数第二个参数<code>mode</code>对应的文件打开模式如下表<font color=#0099ff>( <code>b</code> 是二进制模式的意思)</font>：</p><table><thead><tr><th align="center">打开模式</th><th align="left">含义</th></tr></thead><tbody><tr><td align="center"><code>r</code>或<code>rb</code></td><td align="left">以只读方式打开一个文本文件（不创建文件，若文件不存在则报错）</td></tr><tr><td align="center"><code>w</code>或<code>wb</code></td><td align="left">以写方式打开文件(如果文件存在则清空文件，文件不存在则创建一个文件)</td></tr><tr><td align="center"><code>a</code>或<code>ab</code></td><td align="left">以追加方式打开文件，在末尾添加内容，若文件不存在则创建文件</td></tr><tr><td align="center"><code>r+</code>或<code>rb+</code></td><td align="left">以可读、可写的方式打开文件(不创建新文件)</td></tr><tr><td align="center"><code>w+</code>或<code>wb+</code></td><td align="left">以可读、可写的方式打开文件(如果文件存在则清空文件，文件不存在则创建一个文件)</td></tr><tr><td align="center"><code>a+</code>或<code>ab+</code></td><td align="left">以追加方式打开文件，打开文件并在末尾更改文件，若文件不存在则创建文件</td></tr></tbody></table><blockquote><p>写模式和追加模式是不一样的。如果文件存在，写模式会清空原有的数据，而追加模式会在原有数据的后面写入新的内容。</p></blockquote><h3 id="fclose-函数"><a href="#fclose-函数" class="headerlink" title="fclose 函数"></a><code>fclose</code> 函数</h3><p><code>fclose</code> 可以关闭程序不再使用的文件，函数原型如下：：</p><ul><li>打开的文件会占用内存资源，如果总是打开不关闭，会消耗很多内存</li><li>一个进程同时打开的文件数是有限制的，超过最大同时打开文件数，再次调用<code>fopen</code>打开文件会失败</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fclose</span><span class="params">(FILE * stream)</span>;</span><br></pre></td></tr></table></figure><p>参数：</p><ul><li>接受一个文件指针 <code>stream</code>，用于指定要关闭的文件。将缓冲区中的数据写回到文件中，并释放与文件相关的资源。</li></ul><p>返回值：返回一个整数值来指示关闭操作的成功与否。</p><ul><li>成功：关闭文件，返回0</li><li>失败：返回非零值</li></ul><h2 id="读-写文件"><a href="#读-写文件" class="headerlink" title="读&#x2F;写文件"></a>读&#x2F;写文件</h2><p> <code>fgetc</code>&#x2F;<code>fputc</code> , <code>fgets</code>&#x2F;<code>fputs</code> 和 <code>fscanf</code>&#x2F;<code>fprintf</code> 是用来读写文本文件，<code>fread</code>&#x2F;<code>fwrite</code> 是用来读写二进制文件。</p><h3 id="输入与输出的标准函数"><a href="#输入与输出的标准函数" class="headerlink" title="输入与输出的标准函数"></a>输入与输出的标准函数</h3><h4 id="读文件"><a href="#读文件" class="headerlink" title="读文件"></a>读文件</h4><p> <code>fscanf</code> 用于从文件中读取格式化数据，类似于从键盘输入的 <code>scanf</code> 函数。从指定的文件指针读取数据，并根据提供的格式字符串将其存储在变量中。函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fscanf</span><span class="params">(FILE *stream, <span class="type">const</span> <span class="type">char</span> *format, ...)</span>;</span><br></pre></td></tr></table></figure><p><strong>参数说明</strong>:</p><ul><li><code>FILE *stream</code>: 文件指针，指向要读取的文件。</li><li><code>const char *format</code>: 格式化字符串，定义如何读取数据（例如 <code>%d</code>、<code>%f</code>、<code>%s</code> 等）。</li><li><code>...</code>: 可变参数，存储读取数据的变量地址。</li></ul><p><strong>返回值</strong>:</p><ul><li>成功时，返回成功读取的项数。</li><li>如果到达文件末尾，返回 <code>EOF</code>。</li></ul><p>不同的是， scanf 是从标准输入(stdin)中读取数据，而 <code>fscanf</code> 可以从任何一个流中读取数据。当 <code>fscanf</code> 的第一个参数为 <code>stdin</code> 时，效果等价于 <code>scanf</code> ( <code>sscanf</code> 可以从字符串中读取数据)。</p><ul><li><code>fscanf</code> 的读取受文件内容和格式字符串的匹配影响，格式不匹配会导致读取失败。</li><li>遇到空格、换行或制表符时，<code>fscanf</code> 会自动忽略。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    FILE *file = fopen(<span class="string">&quot;data.txt&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (file == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;无法打开文件。\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    <span class="type">char</span> name[<span class="number">50</span>];</span><br><span class="line">    <span class="type">float</span> score;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">fscanf</span>(file, <span class="string">&quot;%d %s %f&quot;</span>, &amp;id, name, &amp;score) != EOF) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;ID: %d, 姓名: %s, 分数: %.2f\n&quot;</span>, id, name, score);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fclose(file);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="写文件"><a href="#写文件" class="headerlink" title="写文件"></a>写文件</h4><p> <code>fprintf</code> 和 <code>printf</code> 类似，是用来进行格式化输出的，</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fprintf</span><span class="params">(FILE *stream, <span class="type">const</span> <span class="type">char</span> *format, ...)</span>;</span><br></pre></td></tr></table></figure><p><strong>参数说明</strong>:</p><ul><li><code>FILE *stream</code>: 文件指针，指向要写入的文件。</li><li><code>const char *format</code>: 格式化字符串，定义如何输出数据。</li><li><code>...</code>: 可变参数，指定要写入的数据。</li></ul><p><strong>返回值</strong>:</p><ul><li>成功时，返回写入字符的总数。</li><li>失败时，返回负值。</li></ul><p>不同的是， <code>printf</code> 始终是向标准输出( <code>stdout</code> )写入内容的，而  <code>fprintf</code>  可以向任何一个输出流中写入内容。当 <code>fprintf</code> 的第一个参数为 <code>stdout</code> 时，效果等价于 <code>printf</code> ( <code>sprintf</code>  可以将内容写入到一个字符数组中)。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    FILE *file = fopen(<span class="string">&quot;output.txt&quot;</span>, <span class="string">&quot;w&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (file == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;无法创建文件。\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> id = <span class="number">101</span>;</span><br><span class="line">    <span class="type">char</span> name[] = <span class="string">&quot;张三&quot;</span>;</span><br><span class="line">    <span class="type">float</span> score = <span class="number">95.5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fprintf</span>(file, <span class="string">&quot;ID: %d, 姓名: %s, 分数: %.2f\n&quot;</span>, id, name, score);</span><br><span class="line"></span><br><span class="line">    fclose(file);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;数据已成功写入文件。\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>格式化输入输出，可以用于序列化和反序列化过程中。所谓<strong>序列化</strong>，就是将程序中的对象转换成一种可以保存的格式(二进制或文本)，从而方便存储(存储到文件或数据库中)或传输(通过网络传输给另一台机器)。<strong>反序列化</strong>则是序列化的逆过程，将按一定格式存储的数据转换成程序中的对象。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line"><span class="type">char</span> name[<span class="number">25</span>];</span><br><span class="line"> <span class="type">int</span> age;</span><br><span class="line"> <span class="type">char</span> gender;</span><br><span class="line">&#125;Student_t;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;Error: invalid arguments\n&quot;</span>);</span><br><span class="line"> <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line"> &#125;</span><br><span class="line"> Student_t s = &#123; <span class="string">&quot;xixi&quot;</span>, <span class="number">18</span>, <span class="string">&#x27;f&#x27;</span> &#125;;</span><br><span class="line"> FILE* fp = fopen(argv[<span class="number">1</span>], <span class="string">&quot;w&quot;</span>);</span><br><span class="line"> <span class="keyword">if</span> (fp == <span class="literal">NULL</span>) &#123;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;Cannot open %s\n&quot;</span>, argv[<span class="number">1</span>]);</span><br><span class="line"> <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line"> &#125;</span><br><span class="line">    <span class="comment">// 序列化</span></span><br><span class="line"> <span class="built_in">fprintf</span>(fp, <span class="string">&quot;%s %d %c&quot;</span>, s.name, s.age, s.gender);</span><br><span class="line"> fclose(fp);</span><br><span class="line"> fp = fopen(argv[<span class="number">1</span>], <span class="string">&quot;r&quot;</span>);</span><br><span class="line"> <span class="keyword">if</span> (fp == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Cannot open %s\n&quot;</span>, argv[<span class="number">1</span>]);</span><br><span class="line"> <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line"> &#125;</span><br><span class="line"> Student_t t;</span><br><span class="line">    <span class="comment">// 反序列化</span></span><br><span class="line"> <span class="built_in">fscanf</span>(fp, <span class="string">&quot;%s %d %c&quot;</span>, t.name, &amp;t.age, &amp;t.gender);</span><br><span class="line"> fclose(fp);</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="按照字符读写文件"><a href="#按照字符读写文件" class="headerlink" title="按照字符读写文件"></a>按照字符读写文件</h3><h4 id="读文件-1"><a href="#读文件-1" class="headerlink" title="读文件"></a>读文件</h4><p><code>fgetc</code>是一个C标准库函数，用于从文件中读取一个字符。函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">fgetc</span><span class="params">(FILE *stream)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">getc</span><span class="params">(FILE *stream)</span>;</span><br></pre></td></tr></table></figure><p>参数：</p><ul><li><code>stream</code>：文件指针，对应要写入字符的文件</li></ul><p>返回值：</p><ul><li>成功：返回写入的字符</li><li>失败&#x2F;文件末尾：返回 <code>EOF</code>(end of file)</li></ul><p> <code>fgetc</code> 和 <code>getchar</code> 和 <code>getc</code> 的区别：</p><ol><li><code>int fgetc(FILE *stream)</code>: 从指定的文件流 <code>stream</code> 中读取下一个字符，并将其作为 <code>unsigned char</code> 类型返回。如果到达文件末尾或发生读取错误，则返回 <code>EOF</code>。</li><li><code>int getchar()</code>: 从标准输入流中读取一个字符，并将其作为 <code>unsigned char</code> 类型返回。与 <code>fgetc(stdin)</code> 是等价的。</li><li><code>int getc(FILE *stream)</code>: 从指定的文件流 <code>stream</code> 中读取下一个字符，并将其作为 <code>unsigned char</code> 类型返回。与  <code>fgetc</code> 几乎完全相同，只是可以被实现为宏，并且通常比 <code>fgetc</code> 更高效。</li></ol><p>三个函数的返回值都是 <code>int</code> 类型，以便能够返回读取的字符或 <code>EOF</code> (End of File)。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> </span><br><span class="line">&#123;</span><br><span class="line">    FILE* fp = fopen(<span class="string">&quot;example.txt&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (fp == <span class="literal">NULL</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Failed to open the file.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> ch;</span><br><span class="line">    <span class="keyword">while</span> ((ch = fgetc(fp)) != EOF)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, ch);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    fclose(fp);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="写文件-1"><a href="#写文件-1" class="headerlink" title="写文件"></a>写文件</h4><p>fputc是一个C标准库函数，用于将一个字符写入到文件中。函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">fputc</span><span class="params">(<span class="type">int</span> character, FILE *stream)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">putc</span><span class="params">(<span class="type">int</span> character, FILE *stream)</span>;</span><br></pre></td></tr></table></figure><p>参数：</p><ul><li><code>character</code>：要写入的字符，注意参数是整形</li><li><code>stream</code>：文件指针，对应要写入字符的文件</li></ul><p>返回值：</p><ul><li>成功：返回写入的字符</li><li>失败：返回 <code>EOF</code>(end of file)</li></ul><p><code>fputc</code> 和 <code>putchar</code> 类似。不同的是 <code>putchar</code> 只能向标准输出流(<code>stdout</code>)中写入字符，而 <code>fputc</code> 可以向任意一个流中写入字符。</p><p>在标准C库中，<code>putc</code>函数实际上是一个宏，而不是一个真正的函数。功能是相同的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span>* buf = <span class="string">&quot;One world one dream!&quot;</span>;</span><br><span class="line">    FILE* fp = fopen(<span class="string">&quot;example.txt&quot;</span>, <span class="string">&quot;w&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (fp == <span class="literal">NULL</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Failed to open the file.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">strlen</span>(buf);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> ch = fputc(buf[i], fp);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, ch);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    fclose(fp);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> <code>fcopy.c</code> </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span> &#123;</span><br><span class="line">    <span class="comment">// copy src dest</span></span><br><span class="line"><span class="keyword">if</span> (argc != <span class="number">3</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Error: invalid arguments\n&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打开文件流</span></span><br><span class="line"> FILE* source_fp = fopen(argv[<span class="number">1</span>], <span class="string">&quot;r&quot;</span>);</span><br><span class="line"> <span class="keyword">if</span> (source_fp == <span class="literal">NULL</span>) &#123;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;Cannot open %s\n&quot;</span>, argv[<span class="number">1</span>]);</span><br><span class="line"> <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">  FILE* dest_fp = fopen(argv[<span class="number">2</span>], <span class="string">&quot;w&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (dest_fp == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Cannot open %s\n&quot;</span>, argv[<span class="number">2</span>]);</span><br><span class="line">fclose(source_fp);</span><br><span class="line"><span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;   </span><br><span class="line"><span class="comment">// 复制文件</span></span><br><span class="line"><span class="type">int</span> c;</span><br><span class="line"><span class="keyword">while</span> ((c = fgetc(source_fp)) != EOF)</span><br><span class="line">fputc(c, dest_fp);</span><br><span class="line">    <span class="comment">// 关闭文件流</span></span><br><span class="line">fclose(source_fp);</span><br><span class="line">fclose(dest_fp);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="按照行读写文件"><a href="#按照行读写文件" class="headerlink" title="按照行读写文件"></a>按照行读写文件</h3><h4 id="读文件-2"><a href="#读文件-2" class="headerlink" title="读文件"></a>读文件</h4><p><code>fgets</code>是一个C标准库函数，用于从文件中读取一行字符。函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">char</span> *<span class="title function_">fgets</span><span class="params">(<span class="type">char</span> *<span class="built_in">string</span>, <span class="type">int</span> size, FILE *stream)</span>;</span><br></pre></td></tr></table></figure><p>参数：</p><ul><li><code>string</code>：字符指针，用于存储读取的字符</li><li><code>size</code>：指定要读取的最大字符数（包括终止符）</li><li><code>stream</code>：文件指针，用于指定要从中读取字符的文件</li></ul><p>返回值：</p><ul><li>成功：返回参数<code>string</code>的首地址</li><li>失败：返回NULL</li></ul><p>从输入流 <code>stream</code> 中，最多读取 <code>size-1</code> 个字符，并把读取的字符存入 <code>string</code> 指向的字符数组中。 <code>fgets</code> 遇到换行符 <code>\n</code>，或者文件的末尾就会终止(也就是说，读取的字符数可能不足 <code>size-1</code> 个)，并且会存储换行符 <code>\n</code> 。 <code>fgets</code> 会在最后添加空字符<code>\0</code>。</p><p><code>fgets</code> 是 <code>gets</code> 的通用版本，可以从任意输入流中读取数据，而 <code>gets</code> 只能从<code>stdin</code> 中读取数据。 <code>fgets</code> 也比 <code>gets</code> 更为安全，因为它限制了读取字符的最大数目<code>(siez-1)</code>。此外，如果 <code>fgets</code> 是因为读取了换行符而终止，那么它会存储换行符 <code>\n</code> ，而 <code>gets</code> 函数从来不会存储换行符。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> line[<span class="number">100</span>]; <span class="comment">// 假设一行最多100个字符</span></span><br><span class="line"></span><br><span class="line">    FILE* fp = fopen(<span class="string">&quot;example.txt&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (fp == <span class="literal">NULL</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Failed to open the file.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (fgets(line, <span class="keyword">sizeof</span>(line), fp) != <span class="literal">NULL</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Read line: %s&quot;</span>, line);</span><br><span class="line">    &#125;</span><br><span class="line">    fclose(fp);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="写文件-2"><a href="#写文件-2" class="headerlink" title="写文件"></a>写文件</h4><p><code>fputs</code>是一个C标准库函数，用于将字符串写入文件。函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">fputs</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *<span class="built_in">string</span>, FILE *stream)</span>;</span><br></pre></td></tr></table></figure><p>参数：</p><ul><li><code>string</code>：字符串的指针，表示要写入的内容</li><li><code>stream</code>：文件指针，用于指定要写入字符的文件</li></ul><p>返回值：</p><ul><li>成功：返回一个非负值</li><li>失败：返回<code>EOF</code>(end of file)</li></ul><p><code>fputs</code> 是 <code>puts</code> 的通用版本，可以将字符串写入到任意的输出流中，而 <code>puts</code> 只能写入到 <code>stdout</code> 中。此外， <code>fputs</code> 是原样输出字符串，而 <code>puts</code> 会在字符串后面而外输出一个换行符 <code>\n</code> 。在每个字符串之间添加换行符或其他分隔符，需要在调用<code>fputs</code>之后手动添加。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* <span class="built_in">string</span> = <span class="string">&quot;Hello, world!&quot;</span>;</span><br><span class="line">    FILE* fp = fopen(<span class="string">&quot;example.txt&quot;</span>, <span class="string">&quot;w&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (fp == <span class="literal">NULL</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Failed to open the file.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">fputs</span>(<span class="built_in">string</span>, fp) == EOF) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Failed to write the string.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    fclose(fp);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> <code>fcopy.c</code> </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span> &#123;</span><br><span class="line"><span class="comment">// copy src dest</span></span><br><span class="line"><span class="keyword">if</span> (argc != <span class="number">3</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Error: invalid arguments\n&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line"> &#125;</span><br><span class="line">    <span class="comment">// 打开文件流</span></span><br><span class="line"> FILE* source_fp = fopen(argv[<span class="number">1</span>], <span class="string">&quot;r&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (source_fp == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Cannot open %s\n&quot;</span>, argv[<span class="number">1</span>]);</span><br><span class="line"><span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br><span class="line">FILE* dest_fp = fopen(argv[<span class="number">2</span>], <span class="string">&quot;w&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (dest_fp == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Cannot open %s\n&quot;</span>, argv[<span class="number">2</span>]);</span><br><span class="line">    fclose(source_fp);</span><br><span class="line">      <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line"> &#125;</span><br><span class="line"><span class="comment">// 复制文件</span></span><br><span class="line"> <span class="type">char</span> str[<span class="number">1024</span>];</span><br><span class="line"> <span class="keyword">while</span> (fgets(str, <span class="keyword">sizeof</span>(str), source_fp) != <span class="literal">NULL</span>)</span><br><span class="line"> <span class="built_in">fputs</span>(str, dest_fp);</span><br><span class="line">    <span class="comment">// 关闭文件流</span></span><br><span class="line"> fclose(source_fp);</span><br><span class="line"> fclose(dest_fp);</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="按照块读写文件"><a href="#按照块读写文件" class="headerlink" title="按照块读写文件"></a>按照块读写文件</h3><p><code>fread</code> 和 <code>fwrite</code> 主要是用来处理二进制文件的。还可以用于序列化和反序列化过程中。</p><h4 id="读文件-3"><a href="#读文件-3" class="headerlink" title="读文件"></a>读文件</h4><p><code>fread</code>是一个C标准库函数，用于从文件中以二进制形式读取数据。函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">size_t</span> <span class="title function_">fread</span><span class="params">(<span class="type">void</span> *ptr, <span class="type">size_t</span> size, <span class="type">size_t</span> count, FILE *stream)</span>;</span><br></pre></td></tr></table></figure><p>参数：</p><ul><li><code>ptr</code>：指向用于存储读取数据的缓冲区的指针</li><li><code>size</code>：每个元素的字节数(以字节为单位)</li><li><code>count</code>：要读取的元素数量</li><li><code>stream</code>：文件指针，用于指定要从中读取数据的文件</li></ul><p>返回值：</p><ul><li>成功：返回实际读取的元素数量</li><li>失败&#x2F;文件末尾：返回的元素数量与<code>count</code>不相等，可以通过<code>feof</code>和<code>ferror</code>函数来判断，到底是读到了文件末尾，还是发生了错误。</li></ul><p><code>fread</code>函数会从文件中读取指定数量的元素，每个元素占据<code>size</code>个字节，将它们存储在<code>ptr</code>指向的缓冲区中。</p><h4 id="写文件-3"><a href="#写文件-3" class="headerlink" title="写文件"></a>写文件</h4><p><code>fwrite</code>是一个C标准库函数，用于以二进制形式将数据写入文件。函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">size_t</span> <span class="title function_">fwrite</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *ptr, <span class="type">size_t</span> size, <span class="type">size_t</span> count, FILE *stream)</span>;</span><br></pre></td></tr></table></figure><p>参数：</p><ul><li><code>ptr</code>：指向要写入数据的指针</li><li><code>size</code>：要写入的每个元素的字节数(以字节为单位)</li><li><code>count</code>：要写入的元素数量</li><li><code>stream</code>：文件指针，用于指定要写入数据的文件</li></ul><p>返回值：</p><ul><li>成功：返回写入的元素数量，即<code>count</code>的值</li><li>失败：返回一个小于<code>count</code>的值</li></ul><p><code>fwrite</code>函数会将指针<code>ptr</code>指向的数据写入到文件中。写入的总字节数是<code>size</code>与<code>count</code>相乘的积。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//序列化/反序列化</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line"> <span class="type">char</span> name[<span class="number">25</span>];</span><br><span class="line"> <span class="type">int</span> age;</span><br><span class="line"><span class="type">char</span> gender;</span><br><span class="line">&#125;Student_t;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Error: invalid arguments\n&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br><span class="line">Student_t s = &#123; <span class="string">&quot;xixi&quot;</span>, <span class="number">18</span>, <span class="string">&#x27;f&#x27;</span> &#125;;</span><br><span class="line">FILE* fp = fopen(argv[<span class="number">1</span>], <span class="string">&quot;wb&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (fp == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Cannot open %s\n&quot;</span>, argv[<span class="number">1</span>]);</span><br><span class="line"><span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// 序列化</span></span><br><span class="line">fwrite(&amp;s, <span class="keyword">sizeof</span>(Student_s), <span class="number">1</span>, fp);</span><br><span class="line">fclose(fp);</span><br><span class="line">fp = fopen(argv[<span class="number">1</span>], <span class="string">&quot;rb&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (fp == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Cannot open %s\n&quot;</span>, argv[<span class="number">1</span>]);</span><br><span class="line"><span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br><span class="line">Student_t t;</span><br><span class="line"><span class="comment">// 反序列化</span></span><br><span class="line">fread(&amp;t, <span class="keyword">sizeof</span>(Student_s), <span class="number">1</span>, fp);</span><br><span class="line">fclose(fp);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="文件定位"><a href="#文件定位" class="headerlink" title="文件定位"></a>文件定位</h2><p>每个流都有相关联的文件位置。在执行读写操作时，文件位置会自动推进，并按照顺序访问文件。<code>&lt;stdio.h&gt;</code> 提供了几个函数来支持：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fseek</span><span class="params">(FILE* stream, <span class="type">long</span> <span class="type">int</span> offset, <span class="type">int</span> whence)</span>;</span><br><span class="line"><span class="type">long</span> <span class="type">int</span> <span class="title function_">ftell</span><span class="params">(FILE* stream)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">rewind</span><span class="params">(FILE* stream)</span>;</span><br></pre></td></tr></table></figure><h3 id="fseek-函数"><a href="#fseek-函数" class="headerlink" title="fseek 函数"></a><code>fseek</code> 函数</h3><p>fseek 函数用于将文件指针移动到文件中的指定位置。函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fseek</span><span class="params">(FILE *stream, <span class="type">long</span> offset, <span class="type">int</span> whence)</span>;</span><br></pre></td></tr></table></figure><p><strong>参数说明</strong>：</p><ul><li><p><code>stream</code>：文件指针，指向已打开的文件。</p></li><li><p><code>offset</code>：偏移量，表示相对于 whence 的位置的偏移量（可以是正值、负值或零）。</p></li><li><p><code>whence</code>：定位起始点，取值如下：</p></li><li><p><code>SEEK_SET</code>：文件的开头</p></li><li><p><code>SEEK_CUR</code>：当前文件指针位置</p></li><li><p><code>SEEK_END</code>：文件的末尾</p></li></ul><p><strong>返回值</strong>：</p><p>​•成功时返回 0，失败时返回非零值。</p><p><strong>示例</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    FILE *file = fopen(<span class="string">&quot;example.txt&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (file == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;无法打开文件&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将文件指针移动到文件开头的第 10 个字节位置</span></span><br><span class="line">    <span class="keyword">if</span> (fseek(file, <span class="number">10</span>, SEEK_SET) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;文件指针移动到文件开头的第 10 个字节。\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        perror(<span class="string">&quot;fseek 失败&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fclose(file);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ftell-函数"><a href="#ftell-函数" class="headerlink" title="ftell 函数"></a><code>ftell</code> 函数</h3><p><code>ftell</code> 函数用于获取当前文件指针的位置。函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">ftell</span><span class="params">(FILE *stream)</span>;</span><br></pre></td></tr></table></figure><p><strong>参数说明</strong>：</p><ul><li><code>stream</code>：文件指针，指向已打开的文件。</li></ul><p><strong>返回值</strong>：</p><ul><li>返回文件指针的当前偏移量（相对于文件开头），失败时返回 -1L。</li></ul><p><strong>示例</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    FILE *file = fopen(<span class="string">&quot;example.txt&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (file == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;无法打开文件&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取当前文件指针位置</span></span><br><span class="line">    <span class="type">long</span> position = ftell(file);</span><br><span class="line">    <span class="keyword">if</span> (position != <span class="number">-1L</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;当前文件指针位置：%ld\n&quot;</span>, position);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        perror(<span class="string">&quot;ftell 失败&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fclose(file);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="rewind-函数"><a href="#rewind-函数" class="headerlink" title="rewind 函数"></a><code>rewind</code> 函数</h3><p>rewind 函数用于将文件指针移动到文件的开头。函数原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">rewind</span><span class="params">(FILE *stream)</span>;</span><br></pre></td></tr></table></figure><p><strong>参数说明</strong>：</p><ul><li><code>stream</code>：文件指针，指向已打开的文件。</li></ul><p><strong>返回值</strong>：</p><ul><li>无返回值。</li></ul><p><strong>示例</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    FILE *file = fopen(<span class="string">&quot;example.txt&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (file == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;无法打开文件&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将文件指针移动到文件末尾</span></span><br><span class="line">    fseek(file, <span class="number">0</span>, SEEK_END);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;文件指针已移动到文件末尾。\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 rewind 将文件指针移动到文件开头</span></span><br><span class="line">    rewind(file);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;文件指针已移动到文件开头。\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    fclose(file);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li><p><code>fseek</code>：用于将文件指针移动到指定位置。</p></li><li><p><code>ftell</code>：用于获取当前文件指针的位置。</p></li><li><p><code>rewind</code>：将文件指针移动到文件开头。</p></li></ul><h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2><p>C 语言往往是通过函数的返回值，或者是测试 <code>errno</code> 变量来检测错误的；并且需要程序员自己编写代码来处理错误。</p><h3 id="errno的简介"><a href="#errno的简介" class="headerlink" title="errno的简介"></a><code>errno</code>的简介</h3><p><code>errno</code>是C语言标准库中定义的全局变量，用于指示最近发生的错误。该变量由头文件<code>&lt;errno.h&gt;</code>声明，并在出现错误时由系统函数进行设置。<code>errno</code>的初始值为零，每当系统调用或库函数出现错误时，它会被设置为相应的错误代码。</p><h3 id="常用的errno错误码"><a href="#常用的errno错误码" class="headerlink" title="常用的errno错误码"></a>常用的<code>errno</code>错误码</h3><p><code>errno</code>变量通常与各种错误码配合使用，错误码预定义在<code>&lt;errno.h&gt;</code>中。以下是常见的错误码：</p><table><thead><tr><th align="center">错误码</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center"><code>EPERM</code></td><td align="center">操作不允许</td></tr><tr><td align="center"><code>ENOENT</code></td><td align="center">文件或目录不存在</td></tr><tr><td align="center"><code>ESRCH</code></td><td align="center">无效的进程</td></tr><tr><td align="center"><code>EINTR</code></td><td align="center">被中断的系统调用</td></tr><tr><td align="center"><code>EIO</code></td><td align="center">输入&#x2F;输出错误</td></tr><tr><td align="center"><code>ENOMEM</code></td><td align="center">内存不足</td></tr><tr><td align="center"><code>EACCES</code></td><td align="center">权限被拒绝</td></tr></tbody></table><h3 id="使用errno的步骤"><a href="#使用errno的步骤" class="headerlink" title="使用errno的步骤"></a>使用<code>errno</code>的步骤</h3><h4 id="步骤1：包含必要的头文件"><a href="#步骤1：包含必要的头文件" class="headerlink" title="步骤1：包含必要的头文件"></a>步骤1：包含必要的头文件</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br></pre></td></tr></table></figure><h4 id="步骤2：清除-errno"><a href="#步骤2：清除-errno" class="headerlink" title="步骤2：清除 errno"></a>步骤2：清除 errno</h4><p>errno 是一个全局变量，默认不会被自动清零。建议在调用可能发生错误的函数之前，手动将 errno 设置为 0，以便准确检测函数调用是否发生错误：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">errno = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><h4 id="步骤3：在函数调用后检测错误"><a href="#步骤3：在函数调用后检测错误" class="headerlink" title="步骤3：在函数调用后检测错误"></a>步骤3：在函数调用后检测错误</h4><p>函数调用或系统调用后，可以通过检查<code>errno</code>是否被设置为非零值来判断是否发生了错误。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FILE *file = fopen(<span class="string">&quot;nonexistent.txt&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (file == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Error opening file: %s\n&quot;</span>, strerror(errno));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果<code>fopen</code>函数失败，<code>errno</code>会被设置为相应的错误码，并且<code>strerror(errno)</code>将返回描述错误的字符串。</p><h3 id="错误处理函数"><a href="#错误处理函数" class="headerlink" title="错误处理函数"></a>错误处理函数</h3><h4 id="perror-函数"><a href="#perror-函数" class="headerlink" title="perror()函数"></a><code>perror()</code>函数</h4><p><code>perror()</code>函数可以用来打印带有错误信息的描述，用于根据当前 <code>errno</code> 的值打印错误消息。<code>perror</code> 会打印一条包含自定义前缀和错误消息的完整错误信息：</p><p>示例代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FILE *file = fopen(<span class="string">&quot;nonexistent.txt&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (file == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    perror(<span class="string">&quot;File opening failed&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：perror 自动将 errno 的值转换为错误消息，并将自定义前缀（如 “File opening failed”）一起打印。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">File opening failed:</span> <span class="literal">No</span> <span class="string">such</span> <span class="string">file</span> <span class="string">or</span> <span class="string">directory</span></span><br></pre></td></tr></table></figure><h4 id="strerror-函数"><a href="#strerror-函数" class="headerlink" title="strerror()函数"></a><code>strerror()</code>函数</h4><p><code>strerror()</code>函数根据错误码返回一个描述错误的字符串。示例如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FILE *file = fopen(<span class="string">&quot;nonexistent.txt&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (file == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Error opening file: %s\n&quot;</span>, strerror(errno));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li>在每次调用可能出错的函数前，建议将<code>errno</code>设置为0，以便区分新错误与之前的错误。</li><li>并非所有函数都会设置<code>errno</code>，因此仅在函数说明中明确表示会设置<code>errno</code>的函数中使用它。</li><li>在处理多个函数调用时，及时检查并记录 errno，以免其值被后续的函数调用覆盖。</li><li>使用 perror 和 strerror 提供更友好的错误信息。</li></ul><h3 id="示例：处理文件操作错误"><a href="#示例：处理文件操作错误" class="headerlink" title="示例：处理文件操作错误"></a>示例：处理文件操作错误</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    FILE *file = fopen(<span class="string">&quot;nonexistent.txt&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (file == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Error code: %d\n&quot;</span>, errno);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Error message: %s\n&quot;</span>, strerror(errno));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// 返回非零表示错误</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果成功打开文件，执行文件操作</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;File opened successfully\n&quot;</span>);</span><br><span class="line">    fclose(file);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><ul><li><code>errno</code> 是一个全局变量，用于指示最近一次错误发生的类型。</li><li>使用 <code>perror()</code> 或 <code>strerror()</code> 可以将 <code>errno</code> 变量值转换为可读的错误信息。</li><li>始终检查函数返回值，并在必要时处理错误。</li></ul>]]></content>
      
      
      <categories>
          
          <category> C </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C_格式化输入输出</title>
      <link href="/Language/C/C_%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA"/>
      <url>/Language/C/C_%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA</url>
      
        <content type="html"><![CDATA[<h1 id="C-格式化输入-输出"><a href="#C-格式化输入-输出" class="headerlink" title="C_格式化输入&#x2F;输出"></a>C_格式化输入&#x2F;输出</h1><h2 id="输入-输出模型"><a href="#输入-输出模型" class="headerlink" title="输入&#x2F;输出模型"></a>输入&#x2F;输出模型</h2><p>由于硬件设备速度：CPU&gt;&gt;内存&gt;&gt;IO设备</p><p>为了平衡内存和 IO 设备之间的速度差异，会在<strong>内存</strong>中设置缓冲区(buffer)，其中就有标准输入缓冲区 (stdin) 和标准输出缓冲区 (stdout)等。 </p><h2 id="printf函数"><a href="#printf函数" class="headerlink" title="printf函数"></a>printf函数</h2><p><code>printf</code> 函数的作用：显示<strong>格式串</strong>中的内容，并用后面表达式的值替换格式串中的<strong>转换说明</strong>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(格式字符串, 表达式<span class="number">1</span>, 表达式<span class="number">2</span>, ...);</span><br></pre></td></tr></table></figure><p>格式串中包含普通字符和转换说明。其中，普通字符会原样显示，转换说明则会替换为后面表达式的值。如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i, j;</span><br><span class="line"><span class="type">float</span> x, y;</span><br><span class="line">i = <span class="number">10</span>;</span><br><span class="line">j = <span class="number">20</span>;</span><br><span class="line">x = <span class="number">43.2892f</span>;</span><br><span class="line">y = <span class="number">5527.0f</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;i = %d, j = %d, x = %f, y = %f\n&quot;</span>, i, j, x, y);</span><br></pre></td></tr></table></figure><p><code>printf</code>函数可以将其它类型的数据转换成字符数据，并输出到<code>stdout</code>缓冲区中。</p><h3 id="转换说明"><a href="#转换说明" class="headerlink" title="转换说明"></a>转换说明</h3><p>转换说明可以对输出格式进行精确的控制。</p><p>转换说明的格式为： <code>%m.pX</code> 或 <code>%-m.pX</code> ，其中 <code>m</code> 和 <code>p</code> 都是整数常量，而 <code>X</code> 是字母。<code>m</code> 和 <code>p</code> 都是可选的；如果省略 <code>p</code>，则小数点也要省略。如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%<span class="number">10.2f</span>, %<span class="number">10f</span>, %<span class="number">.2</span>f, %f</span><br></pre></td></tr></table></figure><p><strong>最小字段宽度</strong> (<strong>m</strong>inimum field width) m 指定了要显示的最少字符数量。</p><p>如果显示值所需的字符数少于 m，会在值前面添加额外的空格(右对齐)。例如，转换说明<code>%4d</code> 将以 <code>•123</code> 的形式显示 <code>123</code> (<code>•</code>代表空格)。</p><p>如果显示值所需的字符数多于m，会自动扩展为所需的大小，不会丢失数字。因此, <code>%4d</code> 将以 <code>12345</code> 的形式显示<code>12345</code>。<strong>m前面的负号会导致值左对齐</strong>，<code>%-4d</code> 将以 <code>123•</code> 的形式显示<code>123</code>。</p><p><strong>精度</strong> (<strong>p</strong>recision) p 的含义依赖于<strong>转换说明符</strong> X 的选择。常用的转换说明符有以下几个：</p><ul><li><code>%d</code>: 表示十进制整数。p 表示待显示数字的最小个数 (必要时在数字前面补 0)；如果省略 p，则默认为1。</li><li><code>%f</code>: 表示“定点十进制”形式的浮点数。p 表示小数点后数字的个数 (默认为 6)。如果 p 为 0，则不显示小数点。</li><li><code>%c</code>: 用于字符</li><li><code>%s</code>: 用于字符串</li><li><code>%p</code>: 指针的地址</li><li><code>%m</code>: 报告上一个错误的描述。</li><li><code>%n</code>: 存储前面参数输出字符的数量。</li><li><code>%hh</code>: 用于 <code>char</code> 类型。</li><li><code>%Lf</code>: 用于 <code>long double</code> 类型，以长双精度浮点数格式输出。</li><li><code>%o</code>: 用于八进制整数</li><li><code>%u</code>: 用于无符号十进制整数</li><li><code>%i</code>: 有符号十进制、八进制、或十六进制整数（根据输入的前缀）</li><li><code>%x</code> 或 <code>%X</code>: 用于无符号十六进制整数，<code>%x</code>表示小写字母，<code>%X</code>表示大写字母</li><li><code>%a</code> 或 <code>%A</code>: 浮点数的十六进制浮点表示法，<code>%a</code>表示小写字母，<code>%A</code>表示大写字母。</li><li><code>%e</code> 或 <code>%E</code>: 用于以指数形式表示的浮点数，<code>%e</code>表示小写字母，<code>%E</code>表示大写字母</li><li><code>%g</code> 或 <code>%G</code>: 用于浮点数，根据值的大小自动选择 <code>%f</code> 或 <code>%e</code>，<code>%g</code>表示小写字母，<code>%G</code>表示大写字母</li><li><code>%ll</code>、<code>%j</code>、<code>%z</code>、<code>%t</code>: 用于 <code>long long</code>、<code>intmax_t</code>、<code>size_t</code>、<code>ptrdiff_t</code> 类型的整数，分别表示长长整数、最大整数类型、大小类型、指针差异类型。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> </span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">int</span> i = <span class="number">40</span>;</span><br><span class="line"> <span class="type">float</span> x = <span class="number">839.21f</span>;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;|%d|%5d|%-5d|%5.3d|\n&quot;</span>, i, i, i, i);</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;|%f|%10f|%10.2f|%-10.2f|\n&quot;</span>, x, x, x, x);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="scanf函数"><a href="#scanf函数" class="headerlink" title="scanf函数"></a>scanf函数</h2><p><code>scanf</code> 函数的作用：根据格式串读取 stdin 中的字符，并将字符转换成指定类型的数据后，写到后面表达式所指定的位置。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">scanf</span>(格式串, 表达式<span class="number">1</span>, 表达式<span class="number">2</span>, ...);</span><br></pre></td></tr></table></figure><p>在绝大多数情况下， <code>scanf</code> 函数的格式串中只包含转换说明：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i, j;</span><br><span class="line"><span class="type">float</span> x, y;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d%f%f&quot;</span>, &amp;i, &amp;j, &amp;x, &amp;y);</span><br></pre></td></tr></table></figure><p>值得注意的是，通常会在后面变量的前面加 &amp; 符号(取地址运算符)，但并不是必须的。</p><h3 id="scanf函数的工作原理"><a href="#scanf函数的工作原理" class="headerlink" title="scanf函数的工作原理"></a>scanf函数的工作原理</h3><p><code>scanf</code> 函数本质上是一个”模式匹配”函数，试图把 <code>stdin</code> 中的字符与格式串匹配。</p><p><code>scanf</code> 函数会从左到右依次匹配格式串中的每一项。如果匹配数据项成功，那么<code>scanf</code> 函数会继续处理格式串的剩余部分；如果匹配不成功， <code>scanf</code> 函数将不再处理格式串的剩余部分，而会立刻返回。</p><p><code>scanf</code> 函数的格式串中的每一项都表示一个匹配规则，其中：</p><ul><li><p><code>%d</code> : 忽略前置的<strong>空白字符</strong> (包括空格符、水平和垂直制表符、换页符和换行符)，然后匹配十进制的整数。</p></li><li><p><code>%f</code> : 忽略前置的空白字符，然后匹配浮点数。</p></li></ul><p><font color=#0099ff><strong>注意</strong>：当**<code>scanf函数</code>**遇到一个不属于当前项的字符时，它不会读取该字符。在下一次读取输入时，才会读取该字符。如果scanf输入后没有清理缓冲区，下次读写很可能错误</font></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d%f%f&quot;</span>, &amp;i, &amp;j, &amp;x, &amp;y);</span><br></pre></td></tr></table></figure><blockquote><p><code>scanf</code> 可以从 <code>stdin</code> 缓冲区中读取字符数据，然后转换成其它类型的数据，并写到后面表达式所指定的位置。</p></blockquote><h3 id="格式串中的普通字符"><a href="#格式串中的普通字符" class="headerlink" title="格式串中的普通字符"></a>格式串中的普通字符</h3><p><code>scanf</code> 函数的格式串中也可以包含普通字符，普通字符也用来表示匹配规则。</p><ul><li><p>空白字符：匹配 0 个或多个空白字符。</p></li><li><p>其它字符：精确匹配(是什么字符就匹配什么字符)。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">假设格式串是: <span class="string">&quot;%d/%d&quot;</span></span><br><span class="line">输入<span class="number">1</span>: •<span class="number">5</span>/•<span class="number">96</span></span><br><span class="line">输入<span class="number">2</span>: •<span class="number">5</span>•/•<span class="number">96</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="不要混淆printf函数和scanf函数"><a href="#不要混淆printf函数和scanf函数" class="headerlink" title="不要混淆printf函数和scanf函数"></a>不要混淆printf函数和scanf函数</h3><p>虽然 <code>scanf</code> 函数调用和 <code>printf</code> 函数调用看起来很相似，但这两个函数之间有很大的差异！</p><blockquote><p>一个常见的错误是：调用 <code>printf</code> 函数时，在变量的前面加 <code>&amp;</code>。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d,%d\n&quot;</span>, &amp;i, &amp;j); <span class="comment">/*** 错误的!!!***/</span></span><br></pre></td></tr></table></figure><p><code>scanf</code> 函数在寻找数据项时，通常会跳过前面的空白字符。所以除了转换说明，格式串通常不包含其它字符。</p><p>另一个常见的错误就是：认为 <code>scanf</code> 函数的格式串应该类似于 <code>printf</code> 函数的格式串。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d,%d&quot;</span>, &amp;i, &amp;j);</span><br><span class="line">输入：<span class="number">10</span> <span class="number">20</span> <span class="comment">/*** 错误的!!!，需要加,号***/</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C_概述</title>
      <link href="/Language/C/C_%E6%A6%82%E8%BF%B0"/>
      <url>/Language/C/C_%E6%A6%82%E8%BF%B0</url>
      
        <content type="html"><![CDATA[<h1 id="C-概述"><a href="#C-概述" class="headerlink" title="C_概述"></a>C_概述</h1><h2 id="编写一个简单的C程序"><a href="#编写一个简单的C程序" class="headerlink" title="编写一个简单的C程序"></a>编写一个简单的C程序</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//HelloWorld .c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span>  <span class="string">&lt;stdio .h&gt;</span>    <span class="comment">//  预处理指令</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span>  <span class="title">main</span><span class="params">(<span class="type">void</span>)</span>  </span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Hello  world .\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>  <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p><code>#include&lt;stdio .h&gt;</code> 是一条预处理指令，表示在程序中 “包含” <code>stdio .h</code> 头文件， 其中有C语言标准输入&#x2F;输出库的信息。</p></li><li><p><code>main</code>函数是程序的入口，  <code>main</code>函数中的第一行代码是用来打印信息的。<code>printf</code>函数来自于标准输入&#x2F;输出库，可以产生格式化的输出。<code>\n</code>是一个转义序列，表示换行。</p></li><li><p>第二行代码 <code>return  0;</code> 有两个作用：一是终止 <code>main</code>函数。二是程序终止时会向操作系统返回状态码 <code>0</code> ( <code>0</code> 表示正常终止，非 <code>0</code> 表示异常终止)。</p></li></ol><h2 id="编译和链接"><a href="#编译和链接" class="headerlink" title="编译和链接"></a>编译和链接</h2><p>对 C 程序来说，通常包含下面 4 个步骤：</p><ol><li><p><strong>预处理</strong></p><p>首先程序会由预处理器 (preprocessor) 进行处理。预处理器执行以 <code>#</code> 开头的指令。主要是把头文件中内容 copy 到源代码文件中，或者是对宏进行文本替换。</p><ul><li><code>#include</code>：头文件包含 (把头文件中的内容复制到指令所在的位置)</li></ul><ul><li><code>#define N 5</code>：宏定义 (简单的文本替换) </li><li><code>#define FOO(x) (1 + (x) * (x))</code>：带参数的宏 (宏函数) (文本替换：用“实参”替换“形参”)(记得带括号)（宏函数：左括号应该紧挨宏函数的名称，参数应该由小括号括起来，整个表达式也应该用小括号括起来）</li></ul></li><li><p><strong>编译</strong></p><p>经过预处理器处理的文件会交给编译器进行编译。编译器会把程序翻译成对应平台的汇编代码。</p></li><li><p><strong>汇编</strong></p><p>汇编器会把生成的汇编代码翻译成对应平台的机器代码 (目标代码)。</p></li><li><p><strong>链接</strong></p><p>在链接阶段，链接器会把由汇编器生成的目标代码和程序需要的其它附加代码整合在一起，生成最终可执行的程序。附加代码包括程序中用到的库函数(如 <code>printf</code> 函数)或库文件(<code>.a</code>为静态库文件，<code>.so</code>为动态库文件)。</p><p><img src="https://cdn.jsdelivr.net/gh/Barbecue-g/imagehost/Language/C/C_%E6%A6%82%E8%BF%B0/C%E7%BC%96%E8%AF%91%E4%B8%8E%E9%93%BE%E6%8E%A5%E5%8E%9F%E7%90%86.png" alt="编译与链接原理"></p><p><font color=#0099ff><strong>注意</strong>：在C&#x2F;C++中，编译单元为源文件，会对每一个源文件进行编译，生成对应的目标文件。</font>然后将多个目标文件链接在一起，生成可执行程序。</p></li></ol><h2 id="进程虚拟内存空间"><a href="#进程虚拟内存空间" class="headerlink" title="进程虚拟内存空间"></a>进程虚拟内存空间</h2><p>程序经过预处理、编译和链接，最终生成可执行文件。可执行文件被操作系统加载到内存，程序才得以运行。运行的程序为<strong>进程</strong> (process)。每个进程都有自己的虚拟内存空间，如下所示：</p><img src="https://cdn.jsdelivr.net/gh/Barbecue-g/imagehost/Language/C/C_%E6%A6%82%E8%BF%B0/%E8%BF%9B%E7%A8%8B%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98.png" alt="进程虚拟内存" style="zoom:67%;" /><h2 id="变量和赋值"><a href="#变量和赋值" class="headerlink" title="变量和赋值"></a>变量和赋值</h2><h3 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h3><p>每一个变量都必须有一个类型 。类型用来说明变量所存储数据的种类</p><h3 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h3><p>在使用变量之前必须对其进行声明，声明的格式如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">类型 变量名;</span><br></pre></td></tr></table></figure><p>例如，声明变量 height 和 profit：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> height;</span><br><span class="line"><span class="type">float</span> profit;</span><br></pre></td></tr></table></figure><p>有几个变量具有相同的类型，可以声明合并：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> height, length, width, volume;</span><br><span class="line"><span class="type">float</span> profit, loss;</span><br></pre></td></tr></table></figure><h3 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h3><p>变量通过赋值操作获取值。如</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">height = <span class="number">8</span>;</span><br><span class="line">length = <span class="number">12</span>;</span><br><span class="line">width = <span class="number">10</span>;</span><br></pre></td></tr></table></figure><p>通常会把一个浮点数赋值给 <code>float</code> 类型的变量，而且往往会在浮点数后面添加字母f。如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">profit = <span class="number">2150.48f</span>;</span><br></pre></td></tr></table></figure><p>一旦变量被赋值，就可以计算其它变量的值：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">height = <span class="number">8</span>;</span><br><span class="line">length = <span class="number">12</span>;</span><br><span class="line">width = <span class="number">10</span>;</span><br><span class="line">volumn = height * length * width;</span><br></pre></td></tr></table></figure><h3 id="显示变量的值"><a href="#显示变量的值" class="headerlink" title="显示变量的值"></a>显示变量的值</h3><p>可以用 <code>printf</code> 显示变量的值。如:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Height: %d\n&quot;</span>, height);</span><br></pre></td></tr></table></figure><p>其中<code>%d</code>是占位符——<strong>转换说明</strong> (conversion specification)，用来指明变量 height 在显示中的位置。</p><p><code>%d</code>仅适用于 <code>int</code> 类型变量，要显示 <code>float</code> 类型变量，需要用 <code>%f</code> 来代替 <code>%d</code>。默认情况下，<code>%f</code> 会显示出小数点后 <code>6</code> 位数字。要强制 <code>%f </code>显示小数点后 <code>p</code> 位数字，可以把 <code>.p</code> 放置在 <code>%</code> 和 <code>f</code> 之间，如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Profit: $%.2f\n&quot;</span>, profit);</span><br></pre></td></tr></table></figure><p>C 语言没有限制 <code>printf</code> 可以显示变量的数量，可以同时显示多个变量的值：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Height: %d Length: %d Width: %d\n&quot;</span>, height, length, width);</span><br></pre></td></tr></table></figure><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>当程序开始执行时，某些变量会被自动设置为零，而大多数变量不会。没有默认值并且尚未在程序中被赋值的变量是<strong>未初始化的</strong>。</p><p><font color=#0099ff><em><strong>注意</strong>：试图访问未初始化的变量，其行为是未定义的。在有些编译器中，可能会得到一个无意义的值；在另一些编译器中，则可能发生更坏的情况 (如程序崩溃)。</em></font></p><p>在声明变量的同时赋初始值。如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> height = <span class="number">8</span>;</span><br></pre></td></tr></table></figure><p>其中数值 8 是一个<strong>初始化式</strong> (initializer)。</p><p>在一个声明语句中，可以对任意数量的变量进行初始化：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> height = <span class="number">8</span>, length = <span class="number">12</span>, width = <span class="number">10</span>;</span><br></pre></td></tr></table></figure><p><font color=#0099ff>注意</font>：上面每一个变量都有自己的初始化式。如果写成：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> height, length, width = <span class="number">10</span>;</span><br></pre></td></tr></table></figure><p>则只有变量 width 被初始化了。</p><h2 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h2><p>在编写程序时，需要对变量、函数、宏等内容进行命名。名字为<strong>标识符</strong>(identifier)。</p><p>在C语言中，标识符只能包含数字，字母和下划线，但是必须以字母或者下划线开头，不能以数字开头。</p><p>下面是一些合法的标识符：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">times10, get_next_char, _done</span><br></pre></td></tr></table></figure><p>接下来是一些不合法的标识符 ： </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">10</span>times, get-next-<span class="type">char</span></span><br></pre></td></tr></table></figure><p>C语言的标识符是区分大小写的。比如，下面的标识符全都不同：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">job, Job, jOb, joB, JOb, JoB, jOB, JOB</span><br></pre></td></tr></table></figure><p>下划线标识符：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">symbol_table, current_page, name_and_address</span><br></pre></td></tr></table></figure><p>单词首字母大写标识符 (驼峰命令法)： </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">symbolTable, currentPage, nameAndAddress</span><br></pre></td></tr></table></figure><h3 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h3><p>对 C 编译器有特殊意义的名称，称为<strong>关键字</strong> (keyword)。关键字是不能作为标识符来使用的。如：</p><table><thead><tr><th>auto</th><th align="center">enum</th><th align="center">restrict (C99)</th><th align="center">unsigned</th><th align="center">break</th><th align="center">extern</th></tr></thead><tbody><tr><td>return</td><td align="center">void</td><td align="center">case</td><td align="center">float</td><td align="center">short</td><td align="center">volatile</td></tr><tr><td>char</td><td align="center">for</td><td align="center">signed</td><td align="center">while</td><td align="center">const</td><td align="center">goto</td></tr><tr><td>sizeof</td><td align="center">_Bool (C99)</td><td align="center">continue</td><td align="center">if</td><td align="center">static</td><td align="center">_Complex (C99)</td></tr><tr><td>default</td><td align="center">inline (C99)</td><td align="center">struct</td><td align="center">_Imaginary (C99)</td><td align="center">do</td><td align="center">int</td></tr><tr><td>switch</td><td align="center">double</td><td align="center">long</td><td align="center">typedef</td><td align="center">else</td><td align="center">register</td></tr><tr><td>union</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr></tbody></table><h2 id="为常量定义名字"><a href="#为常量定义名字" class="headerlink" title="为常量定义名字"></a>为常量定义名字</h2><p>当程序含有特殊意义的常量时 (比如 32.0f)，建议给这些常量定义名字，以免别人在阅读程序不知道这个常量的含义。在 C 语言中可以采取<strong>宏定义</strong>的方式给常量命名：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> FREEZING_PT 32.0f</span></span><br></pre></td></tr></table></figure><blockquote><p>在预处理阶段，预处理器会把每一个宏替换为其表示的值。</p></blockquote><p>可以利用宏来定义表达式，如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> SCALE_FACTOR (5.0f / 9.0f)</span></span><br></pre></td></tr></table></figure><p>当宏表示一个表达式时，最好用括号把表达式括起来。</p>]]></content>
      
      
      <categories>
          
          <category> C </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C_结构体和枚举</title>
      <link href="/Language/C/C_%E7%BB%93%E6%9E%84%E4%BD%93%E5%92%8C%E6%9E%9A%E4%B8%BE"/>
      <url>/Language/C/C_%E7%BB%93%E6%9E%84%E4%BD%93%E5%92%8C%E6%9E%9A%E4%B8%BE</url>
      
        <content type="html"><![CDATA[<h1 id="C-结构体和枚举"><a href="#C-结构体和枚举" class="headerlink" title="C_结构体和枚举"></a>C_结构体和枚举</h1><p>结构体是一系列值(成员)的集合，值(成员)可以有不同的数据类型。枚举本质上是一种整数类型，只不过给整数值起了名称。</p><h2 id="结构体（Structures）"><a href="#结构体（Structures）" class="headerlink" title="结构体（Structures）"></a>结构体（Structures）</h2><h3 id="结构体的定义"><a href="#结构体的定义" class="headerlink" title="结构体的定义"></a>结构体的定义</h3><p>结构体是C语言中一种自定义的复合数据类型，允许存储不同类型的数据项。结构体由一组相关的数据项组成，每个数据项可以是不同的数据类型。基本语法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> 结构体名 &#123;</span></span><br><span class="line">    数据类型<span class="number">1</span> 成员<span class="number">1</span>;</span><br><span class="line">    数据类型<span class="number">2</span> 成员<span class="number">2</span>;</span><br><span class="line">    <span class="comment">// 其它成员</span></span><br><span class="line">&#125; 可选的结构体变量列表;<span class="comment">//可以直接在可选的结构体变量列表处声明结构体变量名，如：&#125;p1,p2;</span></span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> name[<span class="number">50</span>];</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="type">float</span> height;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span> <span class="title">p1</span>;</span></span><br></pre></td></tr></table></figure><h3 id="结构体变量的初始化"><a href="#结构体变量的初始化" class="headerlink" title="结构体变量的初始化"></a>结构体变量的初始化</h3><p>结构体变量的初始化可以使用两种方法：逐个成员初始化和整体初始化，未被初始化的成员会被赋值为 <code>0</code> 。</p><p><strong>逐个成员初始化：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span> <span class="title">person1</span>;</span></span><br><span class="line"><span class="built_in">strcpy</span>(person1.name, <span class="string">&quot;John&quot;</span>);</span><br><span class="line">person1.age = <span class="number">25</span>;</span><br><span class="line">person1.height = <span class="number">175.5</span>;</span><br></pre></td></tr></table></figure><p><strong>整体初始化：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span> <span class="title">person2</span> =</span> &#123;<span class="string">&quot;Alice&quot;</span>, <span class="number">30</span>, <span class="number">160.2</span>&#125;;</span><br></pre></td></tr></table></figure><h3 id="结构体变量的基本操作"><a href="#结构体变量的基本操作" class="headerlink" title="结构体变量的基本操作"></a>结构体变量的基本操作</h3><p>对结构体变量进行基本操作包括访问成员、赋值、比较等。</p><p><strong>访问成员：</strong>结构体可以通过成员名称获取成员。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Name: %s\n&quot;</span>, person1.name);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Age: %d\n&quot;</span>, person1.age);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Height: %.1f\n&quot;</span>, person1.height);</span><br></pre></td></tr></table></figure><p>结构体的成员代表着内存中的一块存储空间。它可以出现在赋值语句的左边，并且可以当作自增、自减运算符的操作数。</p><p><strong>赋值：</strong>它的作用是把 person1 内存空间的数据 copy 到 person2 内存空间中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span> <span class="title">person2</span>;</span></span><br><span class="line">person2 = person1;</span><br></pre></td></tr></table></figure><p>能通过 <code>=</code> 运算符直接复制另一个结构体的数据，但<strong>当传递或返回一个结构体时，都会导致结构体的复制。</strong>避免开销时，会传递或返回一个指向结构体的指针。</p><p>基于结构体变量进行访问，语法为：变量名<code>.</code>成员名</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">print_Person_info</span><span class="params">(<span class="keyword">struct</span> person_p* p)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%c %d %f\n&quot;</span>,</span><br><span class="line">         (*p).name,</span><br><span class="line">         (*p).age,</span><br><span class="line">         (*p).height);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：<code>(*p)</code>中的小括号是不能省的，因为解引用运算符 <code>*</code> 的优先级是低于取成员运算符 <code>.</code> 的。结构体指针通过 <code>*</code> 进行了解引用（比如代码中的 <code>*p</code>）后将不再是指针，在访问结构体成员的时候需要通过<code>.</code>进行操作</p></blockquote><p>为方便使用指向结构体的指针，C语言提供了右箭头运算符  <code>-&gt;</code> ，来基于结构体指针进行访问。</p><p>语法为：指针名<code>-&gt;</code>成员名。改写成：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">print_Person_info</span><span class="params">(<span class="keyword">struct</span> person_p* p)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%c %d %f\n&quot;</span>,</span><br><span class="line">          p-&gt;name,</span><br><span class="line">          p-&gt;age,</span><br><span class="line">          p-&gt;height);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>结构体成员的比较：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (person1.age == person2.age) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;They are of the same age.\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="结构体类型的别名"><a href="#结构体类型的别名" class="headerlink" title="结构体类型的别名"></a>结构体类型的别名</h3><p>可以使用<code>typedef</code>关键字为结构体类型定义别名，避免每次声明结构体类型变量时都要加上 <code>struct</code> 关键字。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Person</span> &#123;</span><span class="comment">//此行的Person可以不写，写了后可以使用struct Person p1;</span></span><br><span class="line">    <span class="type">char</span> name[<span class="number">50</span>];</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="type">float</span> height;</span><br><span class="line">&#125; Person;</span><br><span class="line"></span><br><span class="line">Person person1;</span><br></pre></td></tr></table></figure><h3 id="内存对齐"><a href="#内存对齐" class="headerlink" title="内存对齐"></a>内存对齐</h3><p>内存对齐早起是因为大多数计算机系统要求数据类型按照一定的边界对齐存储。现代的目的是为了内存获取速度更快。</p><p><strong>内存对齐规则</strong>：</p><ol><li><p>按照结构体中最大的成员的大小来对齐，以保证结构体中每个成员都能够按照其自身大小对齐。</p></li><li><p>结构体A嵌套了结构体B，从结构体B最大元素的整数倍地址开始存。</p></li><li><p>函数、 <code>static</code> 变量属于类成员，不属于特定对象</p></li><li><p>带虚函数的类，有虚函数表指针，且属于对象首部，必须要和最大元素的大小对齐。</p></li><li><p>可以使用<code>#pragma pack(n)</code>来指定结构体的对齐方式，其中<code>n</code>表示对齐的字节数。例如，<code>#pragma pack(1)</code>表示按照1字节对齐。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> pack(1)<span class="comment">// 设置字节对齐为1字节</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Example</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">double</span> d;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> pack()  <span class="comment">// 恢复默认对齐</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Size of struct Example: %zu\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> Example));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>C++11及之后的标准引入了<code>alignas</code>和<code>alignof</code>关键字，可以显式指定对齐：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">MyAlignedStruct</span> &#123;</span><br><span class="line">    <span class="built_in">alignas</span>(<span class="number">16</span>) <span class="type">float</span> data[<span class="number">4</span>];  <span class="comment">// 16字节对齐</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol><h3 id="基础内容拓展"><a href="#基础内容拓展" class="headerlink" title="基础内容拓展"></a>基础内容拓展</h3><ul><li><strong>嵌套结构体：</strong> 在结构体中嵌套其它结构体，以构建更复杂的数据结构。</li><li><strong>结构体数组：</strong> 创建存储多个结构体变量的数组。</li><li><strong>指向结构体的指针：</strong> 使用指针来访问和操作结构体变量。</li><li><strong>结构体与函数：</strong> 传递结构体作为函数参数，以及函数返回结构体。</li></ul><h2 id="枚举（Enumerations）"><a href="#枚举（Enumerations）" class="headerlink" title="枚举（Enumerations）"></a>枚举（Enumerations）</h2><p>在很多程序中，变量取离散值，可以添加宏定义。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> SUIT int</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DIAMONDS 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HEARTS 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SPADES 2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CLUBS 3</span></span><br><span class="line"></span><br><span class="line">SUIT s = HEARTS;</span><br></pre></td></tr></table></figure><p>存在的问题：</p><ol><li>没有显示地表明 DIAMONDS、HEARTS、SPADES、CLUBS隶属于同一种类型；</li><li>离散值比较多，为每个值添加一个宏定义将会很繁琐；</li><li>预处理器会删除定义的名字：DIAMONDS、HEARTS、SPADES、CLUBS，所以在调试的时候是没办法使用这些名字的。</li></ol><p><strong>枚举</strong>是一种自定义的数据类型，用于为一组相关的常量赋予有意义的名字，用来表示离散值的。基本语法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> 枚举名 &#123;</span><span class="comment">//c++11可以使用 enum class 枚举名。</span></span><br><span class="line">    标识符<span class="number">1</span>,</span><br><span class="line">    标识符<span class="number">2</span>,</span><br><span class="line">    <span class="comment">// 其它标识符</span></span><br><span class="line">&#125; 可选的枚举变量列表;<span class="comment">//可以直接在可选的枚举变量列表处声明枚举变量名，如：&#125;e1,e2;</span></span><br></pre></td></tr></table></figure><p>C++11中 <code>enum class</code>定义的枚举类型不会隐式转换为整型，并且需要用<code>::</code>符号使用。它提供了更强的类型安全性和更好的作用域控制，避免了命名冲突和不必要的隐式转换，还可以显式指定枚举的底层类型。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">class</span> 枚举名 : <span class="type">unsigned</span> <span class="type">int</span> &#123;<span class="comment">//: unsigned int可以不写，不显示的指定枚举的底层类型</span></span><br><span class="line">    标识符<span class="number">1</span>,</span><br><span class="line">    标识符<span class="number">2</span>,</span><br><span class="line">    <span class="comment">// 其它标识符</span></span><br><span class="line">&#125; 可选的枚举变量列表;<span class="comment">//可以直接在可选的枚举变量列表处声明枚举变量名，如：&#125;e1,e2;</span></span><br></pre></td></tr></table></figure><p>如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义枚举类型</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Suit</span>&#123;</span></span><br><span class="line">    <span class="comment">// 罗列枚举值</span></span><br><span class="line">    DIAMONDS,</span><br><span class="line">    HEARTS,</span><br><span class="line">    SPADES,</span><br><span class="line">    CLUBS</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Suit</span> <span class="title">s</span> =</span> HEARTS; <span class="comment">// 定义枚举类型的变量</span></span><br></pre></td></tr></table></figure><p>枚举变量的基本操作包括赋值、比较、以及使用 switch 语句进行条件判断。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 赋值操作</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Suit</span> <span class="title">s</span> =</span> HEARTS;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 比较操作</span></span><br><span class="line"><span class="keyword">if</span> (s == HEARTS) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;HEARTS\n&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;NOT HEARTS\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// switch语句</span></span><br><span class="line"><span class="keyword">switch</span> (s) &#123;</span><br><span class="line">    <span class="keyword">case</span> DIAMONDS:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;DIAMONDS\n&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> HEARTS:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;HEARTS\n&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SPADES:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;SPADES\n&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;CLUBS\n&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="给枚举类型起别名"><a href="#给枚举类型起别名" class="headerlink" title="给枚举类型起别名"></a>给枚举类型起别名</h3><p>可以用 <code>typedef</code> 给枚举类型起别名，避免每次声明枚举类型变量时都要加上 <code>enum</code> 关键字。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> &#123;</span><span class="comment">//对比结构体，此处的枚举名没写，不可以用enum Suit s = HEARTS;</span></span><br><span class="line">    DIAMONDS,</span><br><span class="line">    HEARTS,</span><br><span class="line">    SPADES,</span><br><span class="line">    CLUBS</span><br><span class="line">&#125; Suit;</span><br><span class="line">Suit s = HEARTS;</span><br></pre></td></tr></table></figure><h3 id="基础内容拓展："><a href="#基础内容拓展：" class="headerlink" title="基础内容拓展："></a>基础内容拓展：</h3><ol><li><strong>枚举类型的内存表示</strong>：枚举类型在内存中通常以整数值存储，编译器会为枚举类型的每个常量分配一个整数值。</li><li><strong>枚举类型的限制</strong>：在C语言中，枚举类型的取值范围受限于其底层类型，通常为 <code>int</code> 类型。</li><li><strong>枚举类型的应用场景</strong>：枚举类型常用于表示一组有限的、相关的常量，例如状态码、选项等。</li></ol>]]></content>
      
      
      <categories>
          
          <category> C </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C_表达式</title>
      <link href="/Language/C/C_%E8%A1%A8%E8%BE%BE%E5%BC%8F"/>
      <url>/Language/C/C_%E8%A1%A8%E8%BE%BE%E5%BC%8F</url>
      
        <content type="html"><![CDATA[<h1 id="C-表达式"><a href="#C-表达式" class="headerlink" title="C_表达式"></a>C_表达式</h1><p><strong>表达式</strong>是用来计算某个值的公式，表达式可以用运算符进行连接。</p><p>C语言拥有异常丰富的运算符：算术运算符、赋值运算符、关系运算符、判等运算符、逻辑运算符、位运算符等等。</p><h2 id="算数运算符"><a href="#算数运算符" class="headerlink" title="算数运算符"></a>算数运算符</h2><p>算术运算符包含 <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>%</code> ，分别表示加，减，乘，除，取余。其中 <code>/</code> 和 <code>%</code> 需要注意：</p><ul><li><code>/</code> 的两个操作数都是整数，结果也是整数 (向零取整)。因此，<code>1/2</code> 的结果为 0 而不是 0.5。</li><li><code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>，可以用于浮点数，但 <code>%</code> 要求两个操作数都是整数。</li><li><code>%</code>取余运算的结果可能为负数， <code>i%j</code> 的符号总是和 <code>i</code> 的符号相同，比如 -9 % 7 的值为 -2。</li></ul><h3 id="运算符的优先级和结合性"><a href="#运算符的优先级和结合性" class="headerlink" title="运算符的优先级和结合性"></a>运算符的优先级和结合性</h3><p>当表达式包含多个运算符时，C 语言采用<strong>优先级</strong>来解决歧义性问题。</p><p><img src="https://github.com/Barbecue-g/Imagehost/blob/master/Language/C/C_%E8%A1%A8%E8%BE%BE%E5%BC%8F/%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7.png?raw=true" alt="表达式优先级"></p><p><strong>优先级</strong>：<code>*</code> 的优先级高于 <code>+</code> </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">i + j * k 等价于 i + (j * k) </span><br></pre></td></tr></table></figure><p>当表达式中包含两个或者更多个具有相同优先级的运算符时，对比运算符的<strong>结合性</strong>进行运算。</p><p><strong>左结合</strong>：运算符是从左向右结合的(二元运算符大多是左结合的)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">i - j + k 等价于 (i - j) + k</span><br><span class="line">i * j / k 等价于 (i * j) / k</span><br></pre></td></tr></table></figure><p><strong>右结合</strong>：运算符是从右向左结合的(一元运算符大多是右结合的)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-+i 等价于 -(+i)</span><br></pre></td></tr></table></figure><h2 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h2><h3 id="简单赋值"><a href="#简单赋值" class="headerlink" title="简单赋值"></a>简单赋值</h3><p>表达式 <code>v = e</code> 的作用是：求出表达式 <code>e</code> 的值，并把其赋值给变量 <code>v</code>。如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">i = <span class="number">5</span>; <span class="comment">/* i is now 5 */</span></span><br><span class="line">j = i; <span class="comment">/* j is now 5 */</span></span><br><span class="line">k = <span class="number">10</span> * i + j; <span class="comment">/* k is now 55 */</span></span><br></pre></td></tr></table></figure><p>如果 <code>v</code> 和 <code>e</code> 的类型不同，在赋值过程中会把 <code>e</code> 的值转换成 <code>v</code> 的类型：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="type">float</span> f;</span><br><span class="line">i = <span class="number">72.99f</span>; <span class="comment">/* i is now 72 */</span></span><br><span class="line">f = <span class="number">136</span>; <span class="comment">/* f is now 136.0 */</span></span><br></pre></td></tr></table></figure><blockquote><p>注意：赋值表达式 <code>v = e</code> 也有值，它的值等于赋值运算后 <code>v</code> 的值。</p></blockquote><p>赋值运算符可以串联在一起，如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">i = j = k = 0;</span><br></pre></td></tr></table></figure><p>由于赋值运算符是<strong>右结合</strong>的，上述表达式等价于：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">i = (j = (k = 0));</span><br></pre></td></tr></table></figure><h3 id="复合赋值"><a href="#复合赋值" class="headerlink" title="复合赋值"></a>复合赋值</h3><p>利用变量原有的值去计算新的值。例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">i = i + <span class="number">2</span>;</span><br></pre></td></tr></table></figure><p>复合赋值运算符简写表达式：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">i += <span class="number">2</span>; <span class="comment">/* same as i = i + 2 */</span></span><br><span class="line">i -= <span class="number">2</span>; <span class="comment">/* same as i = i - 2 */</span></span><br><span class="line">i *= <span class="number">2</span>; <span class="comment">/* same as i = i * 2 */</span></span><br><span class="line">i /= <span class="number">2</span>; <span class="comment">/* same as i = i / 2 */</span></span><br><span class="line">i %= <span class="number">2</span>; <span class="comment">/* same as i = i % 2 */</span></span><br></pre></td></tr></table></figure><p>复合赋值运算符也是<strong>右结合</strong>的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">i += j += k;</span><br></pre></td></tr></table></figure><p>上面表达式等价于</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">i += (j += k);</span><br></pre></td></tr></table></figure><h2 id="自增运算符和自减运算符"><a href="#自增运算符和自减运算符" class="headerlink" title="自增运算符和自减运算符"></a>自增运算符和自减运算符</h2><p><strong>自增运算符</strong>：<code>++</code> ，<strong>自减运算符</strong>：<code>--</code></p><p><code>++</code>和<code>--</code>运算符既可以作为前缀运算符 (如 <code>++i</code> , <code>--i</code> )，也可以作为后缀运算符 (如 <code>i++</code> , <code>i--</code>)，不过表达式的值不同。</p><p>前缀表达式： <code>++i</code> 的值为<code>(i + 1)</code>，副作用是<code>i</code>自增</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">i = i + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> i;</span><br></pre></td></tr></table></figure><p>后缀表达式： <code>i++</code> 的值为<code>i</code>，副作用是<code>i</code>自增</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">j = i;</span><br><span class="line">i = i + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> j;</span><br></pre></td></tr></table></figure><blockquote><p>注意</p><ol><li><code>++i</code> 意味着 “立即自增i”；而 <code>i++</code> 意味着 “先用 i 的原始值，稍后再自增 i”。</li><li>后缀 <code>++</code> 和后缀 <code>--</code> 比正号、负号的优先级高；前缀 <code>++</code> 和前缀 <code>--</code> 与正号、负号的优先级相同。</li><li>运行速度从快到慢： <code>++i</code> &gt; <code>i++</code> &gt; <code>i+=1</code> &gt; <code>i=i+1</code></li></ol></blockquote><h2 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h2><p><strong>逻辑表达式</strong>：用<strong>关系运算符</strong>，<strong>判等运算符</strong>和<strong>逻辑运算符</strong>来构建。逻辑表达式的值为 <code>0</code> 或者 <code>1</code> (0表示false, 1表示true)。</p><p><strong>关系运算符</strong>：包含 <code>&lt;</code> , <code>&gt;</code> , <code>&lt;=</code> , <code>&gt;=</code> 。关系运算符的优先级低于算术运算符，并且是<strong>左结合</strong>的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">i + j &lt; k - 1 等价于 (i + j) &lt; (k - 1)</span><br></pre></td></tr></table></figure><blockquote><p>注意：表达式 <code>i &lt; j &lt; k</code> 是合法的，但 <code>i &lt; j &lt; k</code> 等价于 <code>(i &lt; j) &lt; k</code> ，该表达式首先检测 <code>i</code> 是否小于 <code>j</code>，然后用比较后产生的结果 (0 或者 1) 和 <code>k</code> 进行比较。若要测试 <code>j</code> 是否位于 <code>i</code> 和 <code>k</code> 之间，应该使用：<code>i &lt; j &amp;&amp; j &lt; k</code>。</p></blockquote><h2 id="判等运算符"><a href="#判等运算符" class="headerlink" title="判等运算符"></a>判等运算符</h2><p><strong>判等运算符</strong>：包含 <code>==</code>, <code>!=</code> 。判等运算符的优先级低于关系运算符，是<strong>左结合</strong>的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">i &lt; j == j &lt; k 等价于 (i &lt; j) == (j &lt; k)</span><br></pre></td></tr></table></figure><h2 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h2><p><strong>逻辑运算符</strong>：包含 <code>&amp;&amp;</code> , <code>||</code> , <code>!</code> 。逻辑运算符把任何零值当作 <code>false</code>，任何非零值当作 <code>true</code>。</p><p><strong>注意</strong>： <code>&amp;&amp;</code> 和 <code>||</code> 会对操作数进行 “短路” 计算，操作符会首先计算左操作数的值，然后计算右操作数。</p><p>如果整个表达式的值可以由左操作数的值推导出来，将不会计算右操作数的值。如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(i != <span class="number">0</span>) &amp;&amp; (j / i &gt; <span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>短路计算的好处是显而易见的，没有短路计算，上面的表达式会出现除零错误。</p><p>运算符 <code>!</code> 的优先级和正负号的优先级是相同的，而且是<strong>右结合</strong>的； <code>&amp;&amp;</code> 和 <code>||</code> 的优先级低于关系运算符和判等运算符。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">i &lt; j &amp;&amp; k == m 等价于 (i &lt; j) &amp;&amp; (k == m)</span><br></pre></td></tr></table></figure><h2 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h2><p>位操作在编写系统程序 (包括编译器和操作系统)、加密程序、图形程序以及性能要求非常高的程序时，非常有用。</p><h3 id="移位运算符"><a href="#移位运算符" class="headerlink" title="移位运算符"></a>移位运算符</h3><p>移位运算符可以通过将位向左或向右移动来变换整数的二进制表示。</p><p><strong>左移运算符</strong> <code>&lt;&lt;</code> ：如 <code>i &lt;&lt; j</code> ，将 <code>i</code> 的位<strong>左移</strong> <code>j</code> 位，在 <code>i</code> 的<strong>右边</strong>补 <code>0</code>。</p><p><strong>右移运算符</strong> <code>&gt;&gt;</code> ：如 <code>i &gt;&gt; j </code> ，将 <code>i</code> 的位<strong>右移</strong> <code>j</code> 位。 <code>i</code> 是<strong>无符号数</strong>或者<strong>非负值</strong>，则在<strong>左边</strong>补 <code>0</code> , <code>i</code> 是<strong>有符号负值</strong>，会在左边补  <code>1</code> 。</p><blockquote><p>Tips: 为了可移植性，最好仅对无符号数进行移位运算。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">short</span> i, j;</span><br><span class="line">i = <span class="number">13</span>; <span class="comment">// 0000 1101</span></span><br><span class="line">j = i &lt;&lt; <span class="number">2</span>; <span class="comment">// 0011 0100,</span></span><br><span class="line">j = i &gt;&gt; <span class="number">2</span>; <span class="comment">// 0000 0011</span></span><br></pre></td></tr></table></figure><p>对无符号整数左移 <code>j</code> 位，相当于乘以 <code>2^j</code> (不发生溢出)；对无符号整数右移 <code>j</code> 位，相当于除以 <code>2^j</code>。</p><h3 id="按位运算符"><a href="#按位运算符" class="headerlink" title="按位运算符"></a>按位运算符</h3><p>按位位运算符包含：按位取反，按位与，按位异或，按位或。其中按位取反是<strong>单目运算符</strong>，其余是<strong>双目运算符</strong>。</p><ul><li><p><code>~i</code> : 会对 <code>i</code> 的每一位进行取反操作，即 0 变成 1，1 变成 0。</p></li><li><p><code>i &amp; j</code> : 会对 <code>i</code> 和 <code>j</code> 的每一位进行逻辑与运算。</p></li><li><p><code>i | j</code> : 会对 <code>i</code> 和 <code>j</code> 的每一位进行逻辑或运算。</p></li><li><p><code>i ^ j</code> : 会对 <code>i</code> 和 <code>j</code> 的每一位进行异或运算，如果对应的位相同则为0，如果对应的位不同则结果为 1。</p></li></ul><blockquote><p>提示: 千万不要将按位<strong>运算符</strong> <code>&amp;</code> 和 <code>|</code> 与<strong>逻辑运算符</strong> <code>&amp;&amp;</code> 和 <code>||</code> 混淆。</p></blockquote><p>按位异或运算有良好的性质：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a ^ 0 = a;</span><br><span class="line">a ^ a = 0;</span><br><span class="line">a ^ b = b ^ a;</span><br><span class="line">(a ^ b) ^ c = a ^ (b ^ c);</span><br></pre></td></tr></table></figure><p>除了按位取反运算符外，其余位运算符都有对应的复合赋值运算符：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">i = <span class="number">21</span>;j = <span class="number">56</span>;</span><br><span class="line">i &lt;&lt;= <span class="number">2</span>;i &gt;&gt;= <span class="number">2</span>;</span><br><span class="line">i &amp;= j;</span><br><span class="line">i |= j;</span><br><span class="line">i ^= j;</span><br></pre></td></tr></table></figure><h3 id="常见操作"><a href="#常见操作" class="headerlink" title="常见操作"></a>常见操作</h3><ol><li><p>请判断一个整数是否为奇数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">isOdd</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> n &amp; <span class="number">0x1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>如何判断一个非 0 整数是否为2的幂(1, 2, 4, 8, 16, …)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">isPowerOf2</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> (n &amp; n - <span class="number">1</span>) == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>给定一个值不为0的整数，请找出值为1的最低有效位 (last set bit)。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">lastSetBit</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> n &amp; -n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>给定两个不同的整数 a 和 b，请交换它们两个的值 (要求不使用中间临时变量)。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = a ^ b;</span><br><span class="line">b = a ^ b;</span><br><span class="line">a = a ^ b;</span><br></pre></td></tr></table></figure></li><li><p>给一个 非空整数数组 nums，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">singleNumber</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize)</span> &#123;</span><br><span class="line">    <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numsSize; i++) &#123;</span><br><span class="line">        result ^= nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>异或运算（^）的特性：</p><ol><li>任何数与 0 进行异或运算的结果仍然是原来的数：<code>a ^ 0 = a</code></li><li>任何数与自身进行异或运算的结果是0：<code>a ^ a = 0</code></li><li>异或运算满足交换律：<code>a ^ b = b ^ a</code></li><li>异或运算满足结合律：<code>(a ^ b) ^ c = a ^ (b ^ c)</code></li></ol><p>推断出如下结果：</p><ul><li>如果一个数出现两次，那么与它异或两次的结果是0，即<code>a ^ a = 0</code>。</li><li>如果一个数出现一次，而其它所有数都出现两次，那么对所有数进行异或运算，相同的数会抵消，最终剩下的结果就是只出现一次的数。</li></ul><p>所以，通过对数组中的所有元素进行异或运算，最终得到的结果就是只出现一次的元素。</p></li><li><p>给一个整数数组 nums，其中恰好有两个元素只出现一次，其余所有元素均出现两次。 找出只出现一次的那两个元素。可以按任意顺序返回答案。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">findSingleNumbers</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize, <span class="type">int</span>* single1, <span class="type">int</span>* single2)</span> &#123;</span><br><span class="line">    <span class="comment">// Step 1: 对数组中的所有元素进行异或运算，得到两个只出现一次的元素的异或结果</span></span><br><span class="line">    <span class="type">int</span> xorResult = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numsSize; i++) &#123;</span><br><span class="line">        xorResult ^= nums[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Step 2: 找到异或结果中为 1 的某一位</span></span><br><span class="line">    <span class="type">int</span> diffBit = xorResult &amp; (-xorResult); <span class="comment">// 使用补码操作得到最低位的 1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Step 3: 根据第 k 位是否为 1，将数组分成两组，分别对这两组元素进行异或运算</span></span><br><span class="line">    *single1 = <span class="number">0</span>;</span><br><span class="line">    *single2 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numsSize; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] &amp; diffBit) &#123;</span><br><span class="line">            *single1 ^= nums[i];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            *single2 ^= nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体的步骤如下：</p><ol><li>对数组中的所有元素进行异或运算，得到的结果就是两个只出现一次的元素的异或结果。</li><li>找到这个异或结果中为 1 的某一位，这个位说明两个只出现一次的元素在这一位上是不同的。假设这一位是第 k 位。</li><li>根据第 k 位是否为 1，将数组分成两组，一组是第 k 位为 1 的元素，另一组是第 k 位为 0 的元素。</li><li>分别对这两组元素进行异或运算，得到的结果就是只出现一次的两个元素。</li></ol></li></ol><h2 id="条件运算符"><a href="#条件运算符" class="headerlink" title="条件运算符"></a>条件运算符</h2><p>条件运算符是一种特殊运算符，通常称为三元运算符。用于根据某个条件来选择两个值中的一个。语法如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">condition ? value1 : value2</span><br></pre></td></tr></table></figure><p>如果 condition 为真，则返回 value1，否则返回 value2。下面是一个简单的示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> y = <span class="number">20</span>;</span><br><span class="line">    <span class="type">int</span> max;</span><br><span class="line">    <span class="comment">// 使用条件运算符选择最大值</span></span><br><span class="line">    max = (x &gt; y) ? x : y;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;最大值是: %d&quot;</span>, max);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>条件运算符的优点在于简洁性和表达能力，但是过度使用条件运算符会导致代码可读性降低。</p><p>当使用条件运算符时，注意：</p><ol><li><strong>运算符结合性</strong>：条件运算符是右结合的，意味着表达式 <code>a ? b : c ? d : e</code> 相当于 <code>a ? b : (c ? d : e)</code>。</li><li><strong>类型转换</strong>：条件运算符会进行类型转换以保证两个操作数具有相同的类型。两个操作数的类型不同，较低类型的操作数将被提升到较高类型，然后再进行运算。</li><li><strong>求值顺序</strong>：条件运算符保证了先评估 condition，然后根据 condition 的结果来评估 value1 或 value2。但是并没有规定 value1 和 value2 的求值顺序，因此在表达式 <code>(condition ? func1() : func2())</code> 中，<code>func1()</code> 和 <code>func2()</code> 可能会在条件求值之前都被调用，也可能只调用一个。</li><li><strong>嵌套使用</strong>：条件运算符可以嵌套使用，但是要注意保持代码的清晰度。过度嵌套会导致代码难以理解。</li><li><strong>返回值</strong>：条件运算符本身也是一个表达式，它的返回值可以被赋给变量，也可以作为另一个表达式的一部分使用。</li></ol>]]></content>
      
      
      <categories>
          
          <category> C </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C_语句</title>
      <link href="/Language/C/C_%E8%AF%AD%E5%8F%A5"/>
      <url>/Language/C/C_%E8%AF%AD%E5%8F%A5</url>
      
        <content type="html"><![CDATA[<h1 id="C-语句"><a href="#C-语句" class="headerlink" title="C_语句"></a>C_语句</h1><p>在C语言中，语句可以分为以下几种类型：</p><ol><li><strong>标签语句</strong>：可以通过标签来标记一个语句。C语言中有三种类型的标签：简单标识符后跟冒号（用于goto语句的目标）、<code>case</code>和<code>default</code>标签（用于<code>switch</code>语句中）。</li><li><strong>复合语句</strong>：也称为块语句，是将多个语句和声明用大括号<code>&#123;</code> <code>&#125;</code>括起来，形成一个单独的语句块。函数体也是一种复合语句。</li><li><strong>表达式语句</strong>：由一个可选的表达式后跟分号<code>;</code>构成。如果存在表达式，则该语句可能有值。没有表达式的情况下，语句通常被称为空语句。</li><li><strong>选择语句</strong>：包括<code>if</code>语句和<code>switch</code>语句，用于根据表达式的值选择执行不同的语句块。</li><li><strong>迭代语句</strong>：包括<code>while</code>、<code>do-while</code>和<code>for</code>语句，用于重复执行某段代码直到满足特定条件。</li><li><strong>跳转语句</strong>：包括<code>goto</code>、<code>break</code>、<code>continue</code>和<code>return</code>语句，用于无条件地改变程序的控制流。</li></ol><h2 id="选择语句"><a href="#选择语句" class="headerlink" title="选择语句"></a>选择语句</h2><h3 id="布尔值"><a href="#布尔值" class="headerlink" title="布尔值"></a>布尔值</h3><p>最初的c语言缺少布尔类型。在 C99 中，定义了 <code>_Bool</code> 类型， <code>_Bool</code> 类型的变量只能赋值为 <code>0</code> 或 <code>1</code>。往 <code>_Bool</code> 类型中存储非零值，会导致该变量赋值为 <code>1</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">_Bool</span> flag = <span class="number">5</span>; <span class="comment">/* flag is assigned 1 */</span></span><br></pre></td></tr></table></figure><p>C99 中还提供了一个新的头文件 <code>stdbool.h</code>，该头文件定义了 <code>bool</code> 宏，用它来表示<code>_Bool</code> ；该头文件还定义了 <code>true</code> 和 <code>false</code> 两个宏，它们分别代表 <code>1</code> 和 <code>0</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line">...</span><br><span class="line"><span class="type">bool</span> flag = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure><h3 id="if语句"><a href="#if语句" class="headerlink" title="if语句"></a><code>if</code>语句</h3><p><code>if</code>语句：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (expr) &#123;statement;&#125;</span><br></pre></td></tr></table></figure><p><code>if</code> 语句 <code>else</code> 子句：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (expr)</span><br><span class="line">&#123;statement;&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;statement;&#125;</span><br></pre></td></tr></table></figure><p>级联式 <code>if</code> 语句：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (expr)</span><br><span class="line">    statement</span><br><span class="line"><span class="keyword">else</span> <span class="title function_">if</span> <span class="params">(expr)</span></span><br><span class="line">    statement</span><br><span class="line">...</span><br><span class="line"><span class="keyword">else</span> <span class="title function_">if</span> <span class="params">(expr)</span></span><br><span class="line">    statement</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    statement</span><br></pre></td></tr></table></figure><p>悬空 <code>else</code> 问题：</p><p>  <code>else</code> 子句应该属于离它最近的，且还没有和其它 <code>else</code> 匹配的 <code>if</code> 语句。为了使 <code>else</code> 子句属于外层的 <code>if</code> 语句，需用花括号将内层的 <code>if</code> 语句括起：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (y != <span class="number">0</span>) </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (x != <span class="number">0</span>)</span><br><span class="line">result = x / y;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Error: y is equal to 0\n&quot;</span>);</span><br></pre></td></tr></table></figure><h3 id="条件表达式"><a href="#条件表达式" class="headerlink" title="条件表达式"></a>条件表达式</h3><p>C 语言的一种特殊的运算符——<strong>条件运算符</strong>，条件运算符由 <code>?</code> 和 <code>:</code> 组成，其格式如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">expr1 ? expr2 : expr3</span><br></pre></td></tr></table></figure><p>条件运算符是 C 语言中唯一一个<strong>三目运算符</strong>。</p><p>条件表达式的求值步骤是：首先计算 <code>expr1</code> 的值，如果该值不为 <code>0</code>，则计算 <code>expr2</code> 的值，并且把 <code>expr2</code> 的值当作整个表达式的值；如果 <code>expr1</code> 的值为 <code>0</code>，那么计算 <code>expr3</code>的值，并把 <code>expr3</code> 的值当作整个表达式的值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i, j, k;</span><br><span class="line">i = <span class="number">1</span>;</span><br><span class="line">j = <span class="number">2</span>;</span><br><span class="line">k = i &gt; j ? i : j;</span><br><span class="line">k = i &gt; j ? i++ : j++;</span><br><span class="line">k = (i &gt;= <span class="number">0</span> ? i : <span class="number">0</span>) + j;</span><br></pre></td></tr></table></figure><p>最后一条语句的圆括号是必须的，<strong>三目运算符</strong>的优先级只比<strong>赋值运算符</strong>的优先级高一点。</p><h3 id="switch语句"><a href="#switch语句" class="headerlink" title="switch语句"></a><code>switch</code>语句</h3><p> <code>switch</code> 语句的执行速度比 <code>if</code> 语句快。 <code>switch</code> 语句比级联式 <code>if</code> 语句更容易阅读。</p><p> <code>switch</code> 语句：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (expr) &#123;</span><br><span class="line"><span class="keyword">case</span> constant-expr:</span><br><span class="line">statements;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">case</span> constant-expr:</span><br><span class="line">statements;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">statements;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> <code>switch</code> 语句的组成成分：</p><p><strong>控制表达式</strong>： <code>switch</code> 后边表达式的值必须是<strong>整数类型</strong>。字符类型也当作整数来处理， <code>switch</code> 语句也可以对字符类型进行判定。但不能判定<strong>浮点数</strong>和<strong>字符串</strong>（浮点数存在精度问题，字符串会增加编译器的实现复杂性）。</p><p><strong>分支标号</strong>：<code>case</code> 后边必须跟常量表达式（在编译期间求值的表达式），并且常量表达式的值必须是整数、字符类型。</p><p><strong>语句</strong>：每个<code>case</code>标签后可以跟任意数量的语句(不需要用大括号括起来)，通常每组语句的最后会有一个<code>break</code>语句，用于跳出<code>switch</code>语句的执行。</p><blockquote><p>Tips：</p><ol><li>C 语言不允许有重复的分支标号，但对分支的顺序没有要求，特别是 <code>default</code> 分支不一定要放到最后。</li><li><code>switch</code> 语句不要求一定要有 <code>default</code> 分支。</li><li>当 <code>default</code> 不存在，而且控制表达式的值和任何一个分支标号都不匹配，控制会直接传递给 <code>switch</code> 后面的语句。</li></ol></blockquote><p><font color=#0099ff><code>case</code>穿透：一个分支的最后没有 <code>break</code> 语句，控制会从一个分支继续到下一个分支。</font></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (grade) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Excellent &quot;</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Good &quot;</span>);</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Average &quot;</span>);</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Poor &quot;</span>);</span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Failing &quot;</span>);</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Illegal grade&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果<code>grade</code>的值为 <code>3</code>，会显示：<code>Good Average Poor Illegal grade</code>。</p><h2 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h2><p>每个循环语句都有一个<strong>控制表达式</strong>。每次执行循环体时，都要对控制表达式求值。如果表达式为真，那么继续执行循环语句；否则执行循环语句的下一条语句。</p><h3 id="while语句"><a href="#while语句" class="headerlink" title="while语句"></a><code>while</code>语句</h3><p> <code>while</code> 语句：控制表达式是在每次执行循环体之前进行判定。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (expr) </span><br><span class="line">&#123;statement&#125;</span><br></pre></td></tr></table></figure><p>无限循环：控制表达式 <code>expr</code> 的值始终非零, <code>while</code> 语句将永远执行下去。</p><h3 id="do-while语句"><a href="#do-while语句" class="headerlink" title="do...while语句"></a><code>do...while</code>语句</h3><p> <code>do...while</code> 语句：控制表达式是在每次执行完循环体之后进行判定。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> </span><br><span class="line">&#123;statement&#125; </span><br><span class="line"><span class="keyword">while</span> (expr);</span><br></pre></td></tr></table></figure><p> <code>do...while</code> 语句和 <code>while</code> 语句的唯一区别：<code>do...while</code> 语句的循环体至少会执行一次，而 <code>while</code> 语句在控制表达式的值初始为 <code>0</code> 时，一次都不会执行。</p><h3 id="for语句"><a href="#for语句" class="headerlink" title="for语句"></a><code>for</code>语句</h3><p> <code>for</code> 语句：非常适合递增或递减计数变量的循环</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (expr1; expr2; expr3) </span><br><span class="line">&#123;statement&#125;</span><br></pre></td></tr></table></figure><ol><li><code>expr1</code> 是循环开始执行前的初始化步骤，只执行一次</li><li><code>expr2</code> 是控制循环的控制表达式</li><li><code>expr3</code> 是每次循环中最后被执行的一个操作。</li></ol><p>省略 <code>for</code> 语句中的的表达式：</p><ol><li>省略 <code>expr1</code> ，在执行循环前没有初始化的操作。</li><li>省略 <code>expr2</code>，<code>expr2</code>的值默认为真，无限循环。</li><li>省略 <code>expr3</code>，循环体需要确保 <code>expr2</code> 的值最终会变成 <code>0</code> 。</li><li>同时省略 <code>expr1</code> 和 <code>expr3</code> 时， <code>for</code> 语句和 <code>while</code> 语句一样。</li></ol><p> <code>for</code> 语句的第一个表达式可以替换为声明一个或多个用于循环的变量：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">   ...</span><br></pre></td></tr></table></figure><p>变量 <code>i</code> 不需要在该语句前进行声明。如果变量 <code>i</code> 在之前已经进行了声明，这个语句将创建一个新的 <code>i</code>，且该变量只能在循环内使用。（ <code>for</code> 语句声明的变量在循环外是不可见。）</p><h3 id="逗号表达式"><a href="#逗号表达式" class="headerlink" title="逗号表达式"></a>逗号表达式</h3><p>逗号表达式允许在一个语句中同时执行多个表达式，并以逗号分隔。逗号表达式的值是最后一个表达式的值。逗号表达式的格式如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">expr1, expr2, ..., exprn</span><br></pre></td></tr></table></figure><p>逗号表达式的求值：逗号表达式是左结合的，逗号表达式从左到右依次执行，每个表达式都会被依次计算并丢弃其值，最终的结果是最后一个表达式的值。</p><p><strong>作用</strong>：</p><ul><li>在<code>for</code>循环中初始化和更新多个变量。</li><li>在一个语句中执行多个操作，例如执行一系列函数调用或变量赋值，并只保留最后一个表达式的值。</li></ul><h2 id="跳转语句"><a href="#跳转语句" class="headerlink" title="跳转语句"></a>跳转语句</h2><p>C语言提供了四种跳转语句：<code>break</code>、<code>continue</code>、<code>goto</code>和<code>return</code>。</p><h3 id="break-语句"><a href="#break-语句" class="headerlink" title="break 语句"></a><code>break</code> 语句</h3><p><code>break</code> 可以跳出 <code>switch</code> , <code>while</code> , <code>do...while</code> 和 <code>for</code> 语句。当语句嵌套时，<code>break</code> 只能跳出包含 <code>break</code> 语句的<strong>最内层</strong>嵌套。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (...) &#123;</span><br><span class="line">    <span class="keyword">switch</span> (...) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="continue-语句"><a href="#continue-语句" class="headerlink" title="continue 语句"></a><code>continue </code>语句</h3><p><code>continue</code>语句与<code>break</code>语句对比：</p><ol><li><p><code>break</code> 语句会把控制转移到整个循环的后面，而 <code>continue</code> 会将控制转移到<strong>循环体的末尾</strong>。</p></li><li><p><code>break</code> 语句会跳出循环，而 <code>continue</code> 语句仍然留在循环体内。</p></li><li><p><code>break</code> 语句可以用于 <code>switch</code> 语句和循环，而<code>continue</code> 只能用于循环。</p></li><li><p>在<code>for</code>循环中，执行<code>continue</code>后会跳到循环的<strong>更新表达式</strong>；在<code>while</code>和<code>do-while</code>循环中，执行<code>continue</code>后会跳到循环的条件判断。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">2</span>) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;i=%d\n&quot;</span>, i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出：i=0 i=1 i=3 i=4</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="goto-语句"><a href="#goto-语句" class="headerlink" title="goto 语句"></a><code>goto</code> 语句</h3><p><code>goto</code>语句可以跳转到函数中任何有<strong>标号</strong>的语句处。唯一限制只能在<font color=#0099ff><strong>函数内</strong></font>进行跳转。</p><p>标号是放置在语句开始处的标识符：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">identifier: </span><br><span class="line">statement</span><br></pre></td></tr></table></figure><p>goto语句的格式如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">goto</span> identifier;</span><br></pre></td></tr></table></figure><p>使用<code>goto</code>可以实现从深层嵌套结构中跳出，但过多使用会使程序结构混乱，不易理解和维护。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (error) <span class="keyword">goto</span> error_handler;</span><br><span class="line"><span class="comment">// 正常执行的代码</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">error_handler:</span><br><span class="line"><span class="comment">// 错误处理代码</span></span><br></pre></td></tr></table></figure><h3 id="return-语句"><a href="#return-语句" class="headerlink" title="return 语句"></a><code>return</code> 语句</h3><p> <code>return</code>语句用于结束函数的执行，并将控制权返回给函数的调用者。如果函数声明了返回类型，<code>return</code>语句还可以返回一个值。</p><p> <code>return</code>可以在函数的任何位置使用，一旦执行，函数的剩余部分将不会被执行。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo</title>
      <link href="/Tools/Hexo/Hexo"/>
      <url>/Tools/Hexo/Hexo</url>
      
        <content type="html"><![CDATA[<h1 id="README"><a href="#README" class="headerlink" title="README"></a>README</h1><p>本文章仅用于记录 <code>Hexo</code> 的部分命令与配置</p><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</span><br></pre></td></tr></table></figure><h2 id="Post-Front-matter-配置"><a href="#Post-Front-matter-配置" class="headerlink" title="Post Front-matter 配置"></a>Post Front-matter 配置</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: Hexo   #页面标题</span><br><span class="line">date: 2023-08-16 9:00:00    #页面创建时间</span><br><span class="line">updated: 2024-10-26 23:56:00#页面更新时间</span><br><span class="line">description: 本文章仅用于记录Post Front-matter配置   #描述页面</span><br><span class="line">#type:  HTTP    #标签、分类和友情链接三个页面需要配置</span><br><span class="line">categories: Hexo#文章分类</span><br><span class="line">tags:  Hexo    #文章标签</span><br><span class="line">top_img: &quot;&quot;  #页面顶部图片</span><br><span class="line">cover: &quot;&quot;    #文章封面,文章缩略图(如果没有设置top_img,文章页顶部将显示缩略图，可设为false/图片地址/留空)</span><br><span class="line">keywords:  Redis #页面关键字</span><br><span class="line">comments:  true #显示页面评论模块(默认 true)</span><br><span class="line">top_group_index: 1#首页右上角展示6篇文章的排序顺序，越小越前</span><br><span class="line"></span><br><span class="line"># 文章版权</span><br><span class="line">copyright: true    #显示文章版权模块(默认为设置中post_copyright的enable配置)</span><br><span class="line">copyright_author: Barbecue  #文章版权模块的文章作者</span><br><span class="line">copyright_author_href: https://barbecue-g.github.io #文章版权模块的文章作者链接</span><br><span class="line">copyright_url: https://barbecue-g.github.io/    #文章版权模块的文章连结链接</span><br><span class="line">copyright_info: 此文章版权归Barbeuce所有，如有转载，请注明明来自原作者  #文章版权模块的版权声明文字</span><br><span class="line"></span><br><span class="line"># 侧边栏</span><br><span class="line">toc: true   #单独设置是否有目录</span><br><span class="line">toc_number: false    #单独设置是否展示章节数</span><br><span class="line">aside: true #显示侧边栏 (默认 true)</span><br><span class="line">---</span><br></pre></td></tr></table></figure><h2 id="报错"><a href="#报错" class="headerlink" title="报错"></a>报错</h2><p><code>Error: Spawn failed</code></p><ol><li><p>进入站点根目录</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> E:/hexo</span><br></pre></td></tr></table></figure></li><li><p>删除git提交内容文件夹</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">rm</span> -rf .deploy_git/</span><br></pre></td></tr></table></figure></li><li><p>执行</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global core.autocrlf <span class="literal">false</span></span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> Tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git</title>
      <link href="/Tools/Git/git"/>
      <url>/Tools/Git/git</url>
      
        <content type="html"><![CDATA[<h1 id="GIT"><a href="#GIT" class="headerlink" title="GIT"></a>GIT</h1><h2 id="Git使用"><a href="#Git使用" class="headerlink" title="Git使用"></a>Git使用</h2><p>查看git状态和后续git建议</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git status</span><br></pre></td></tr></table></figure><p>将untracked状态到staged状态</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add</span><br></pre></td></tr></table></figure><p>将staged状态到untracked状态</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git restore --staged</span><br></pre></td></tr></table></figure><p>将所提交内容融入分支（unmodify）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m &quot; &quot;</span><br></pre></td></tr></table></figure><p>“ “中是备注信息</p><p>查看所有分支</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log --oneline --all </span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log --oneline --all --graph</span><br></pre></td></tr></table></figure><p>查看分支</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -v</span><br></pre></td></tr></table></figure><p> 切换分支</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout 主动方</span><br></pre></td></tr></table></figure><p>合并分支</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge 被动方</span><br></pre></td></tr></table></figure><p>将仓库的git拉下来修改后提交上去</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git pull origin master</span><br><span class="line"></span><br><span class="line">git fetch origin master</span><br><span class="line">git merge origin/master</span><br></pre></td></tr></table></figure><h2 id="安装和配置git"><a href="#安装和配置git" class="headerlink" title="安装和配置git"></a>安装和配置git</h2><h3 id="1-安装"><a href="#1-安装" class="headerlink" title="1.安装"></a>1.安装</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install git</span><br></pre></td></tr></table></figure><h3 id="2-检查配置"><a href="#2-检查配置" class="headerlink" title="2. 检查配置"></a>2. 检查配置</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --list</span><br></pre></td></tr></table></figure><h3 id="3-设置用户名称与邮件地址"><a href="#3-设置用户名称与邮件地址" class="headerlink" title="3. 设置用户名称与邮件地址"></a>3. 设置用户名称与邮件地址</h3><p>每一个 Git 的提交都会使用这些信息，并且它会写入到你的每一次提交中，不可更改</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &quot;Barbecue&quot;</span><br><span class="line">git config --global user.email Barbecue@qq.com</span><br></pre></td></tr></table></figure><h3 id="4-配置默认文本编辑器"><a href="#4-配置默认文本编辑器" class="headerlink" title="4. 配置默认文本编辑器"></a>4. 配置默认文本编辑器</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global core.editor vim</span><br></pre></td></tr></table></figure><h3 id="5-配置密钥"><a href="#5-配置密钥" class="headerlink" title="5. 配置密钥"></a>5. 配置密钥</h3><p>输入命令生成密钥</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen</span><br></pre></td></tr></table></figure><p>进入文件夹</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd ~/.ssh/</span><br></pre></td></tr></table></figure><p>找到公钥匙、私匙</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ll</span><br></pre></td></tr></table></figure><p><code>id_rsa</code>——私匙</p><p><code>id_rsa.pub</code>——公钥</p><p>复制公钥到git个人账号的ssh密钥中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat id_rsa.pub</span><br></pre></td></tr></table></figure><h2 id="git命令快速使用"><a href="#git命令快速使用" class="headerlink" title="git命令快速使用"></a>git命令快速使用</h2><p>cd<br>(文件夹地址)<br>git init<br>(新建git文件夹)<br>git –version<br>(查看git版本)<br>git config –global user.name “(name)”<br>(开发者名字)<br>git config –global user.email “(email)”<br>(开发者email)<br>git config –list<br>(查看开发者信息)<br>git status<br>(查看当前状态)<br>git add .<br>(将档案加入索引)<br>git commit -m “修改的内容”<br>(将索引提交到档案库)<br>git log<br>(观察commit的历史记录)<br>git clone (拷贝地址)<br>(下载云端库)<br>git push origin master<br>(上传到云端库)<br>ssh-keygen -t rsa -C “<a href="mailto:&#x32;&#50;&#x31;&#x30;&#x30;&#49;&#54;&#x33;&#48;&#x33;&#64;&#113;&#113;&#46;&#99;&#111;&#109;">&#x32;&#50;&#x31;&#x30;&#x30;&#49;&#54;&#x33;&#48;&#x33;&#64;&#113;&#113;&#46;&#99;&#111;&#109;</a>“<br>(生成ssh公钥)</p><h2 id="清除git历史提交记录"><a href="#清除git历史提交记录" class="headerlink" title="清除git历史提交记录"></a>清除git历史提交记录</h2><p>解决Git提交次数过多，清除历史提交记录的方法有几种，这里提供一种常用的方法，通过创建一个新的孤儿分支（orphan branch），将当前的代码状态保存到这个新分支上，然后用这个新分支替换主分支，从而达到清除历史提交记录的目的。请按照以下步骤操作：</p><ol><li><p><strong>创建一个新的孤儿分支</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout --orphan latest_branch</span><br></pre></td></tr></table></figure><p>这一步会创建一个新的分支<code>latest_branch</code>，这个分支上不包含任何历史提交记录。</p></li><li><p><strong>添加所有文件到新分支</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add -A</span><br></pre></td></tr></table></figure><p>这一步会将你的项目中的所有文件添加到暂存区，准备进行提交。</p></li><li><p><strong>提交更改到新分支</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -am <span class="string">&quot;commit message&quot;</span></span><br></pre></td></tr></table></figure><p>用一条提交信息替代之前的所有提交记录。</p></li><li><p><strong>删除主分支</strong>（默认分支通常是<code>main</code>或<code>master</code>，根据你的情况选择）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -D master</span><br></pre></td></tr></table></figure><p>这一步会永久删除主分支。</p></li><li><p><strong>将当前分支重命名为主分支</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -m master</span><br></pre></td></tr></table></figure><p>这一步将<code>latest_branch</code>重命名为<code>master</code>。</p></li><li><p><strong>强制更新远程仓库</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push -f origin master</span><br></pre></td></tr></table></figure><p>这一步会将本地的变更强制推送到远程仓库，替换远程仓库的历史记录。</p></li></ol><p>请注意，这种方法会彻底删除所有的历史提交记录，只保留当前的代码状态。在执行这些操作之前，建议备份你的仓库，以防万一需要恢复历史记录。</p><h2 id="不保存分支的历史提交记录"><a href="#不保存分支的历史提交记录" class="headerlink" title="不保存分支的历史提交记录"></a>不保存分支的历史提交记录</h2><p>一个分支想合并另外一个分支，但是不保存那个分支的历史提交记录，可以使用 <code>git merge</code> 命令的 <code>--squash</code> 选项。这个选项会将另一个分支的所有提交压缩成一个提交，并将其应用到当前分支，而不会保留原来分支的提交历史。</p><ol><li><p>首先确保你在你想要合并的目标分支上，比如说，假设你想将 <code>branch_to_merge</code> 合并到当前分支：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout master</span><br></pre></td></tr></table></figure></li><li><p>然后使用 <code>git merge</code> 命令并添加 <code>--squash</code> 选项合并另一个分支，比如 <code>branch_to_merge</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge --squash develop</span><br></pre></td></tr></table></figure></li><li><p>接着你需要提交这个新的合并提交：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m <span class="string">&quot;docs(all): Merge develop without preserving history&quot;</span></span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> Tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>代码提交规范</title>
      <link href="/Tools/Git/%E4%BB%A3%E7%A0%81%E6%8F%90%E4%BA%A4%E8%A7%84%E8%8C%83"/>
      <url>/Tools/Git/%E4%BB%A3%E7%A0%81%E6%8F%90%E4%BA%A4%E8%A7%84%E8%8C%83</url>
      
        <content type="html"><![CDATA[<h1 id="Conventional-Commits"><a href="#Conventional-Commits" class="headerlink" title="Conventional Commits"></a>Conventional Commits</h1><p>约定式提交规范是一种基于提交信息的轻量级约定。 它提供了一组简单规则来创建清晰的提交历史； 自动化生成 CHANGELOG。这更有利于编写自动化工具。 通过在提交信息中描述功能、修复和破坏性变更， 使这种惯例与 <a href="http://semver.org/lang/zh-CN">SemVer</a> 相互对应。</p><p>提交说明的结构如下所示：</p><p>原文：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;type&gt;[optional scope]: &lt;description&gt;</span><br><span class="line">[optional body]</span><br><span class="line">[optional footer(s)]</span><br></pre></td></tr></table></figure><p>译文：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;类型&gt;[可选 范围]: &lt;描述&gt;</span><br><span class="line">[可选 正文]</span><br><span class="line">[可选 脚注]</span><br></pre></td></tr></table></figure><blockquote><p>&lt;类型&gt;[可选 范围]:（一个空格）&lt;描述&gt;（多个提交内容以分号分割）</p></blockquote><h2 id="提交类型"><a href="#提交类型" class="headerlink" title="提交类型"></a>提交类型</h2><table><thead><tr><th>提交类型</th><th>标题</th><th>描述</th><th>表情符号</th><th>发布</th><th>包含在变更日志中</th></tr></thead><tbody><tr><td><code>feat</code></td><td>特征</td><td>一个新功能</td><td>✨</td><td><code>minor</code></td><td><code>true</code></td></tr><tr><td><code>fix</code></td><td>Bug修复</td><td>一个错误修复</td><td>🐛</td><td><code>patch</code></td><td><code>true</code></td></tr><tr><td><code>docs</code></td><td>文档</td><td>仅文档更改</td><td>📚</td><td><code>patch</code>如果<code>scope</code>是<code>readme</code></td><td><code>true</code></td></tr><tr><td><code>style</code></td><td>风格</td><td>不影响代码含义的更改（空格、格式、缺少分号等）</td><td>💎</td><td>-</td><td><code>true</code></td></tr><tr><td><code>refactor</code></td><td>代码重构</td><td>既不修复错误也不添加功能的代码更改</td><td>📦</td><td>-</td><td><code>true</code></td></tr><tr><td><code>perf</code></td><td>性能改进</td><td>提高性能的代码更改</td><td>🚀</td><td><code>patch</code></td><td><code>true</code></td></tr><tr><td><code>test</code></td><td>测试</td><td>添加缺失的测试或纠正现有测试</td><td>🚨</td><td>-</td><td><code>true</code></td></tr><tr><td><code>build</code></td><td>构建</td><td>影响构建系统或外部依赖项的更改（示例范围：gulp、broccoli、npm）</td><td>🛠</td><td><code>patch</code></td><td><code>true</code></td></tr><tr><td><code>ci</code></td><td>持续集成</td><td>对 CI 配置文件和脚本的更改（示例范围：Travis、Circle、BrowserStack、SauceLabs）</td><td>⚙️</td><td>-</td><td><code>true</code></td></tr><tr><td><code>chore</code></td><td>家务活</td><td>其他不修改 src 或测试文件的更改</td><td>♻️</td><td>-</td><td><code>true</code></td></tr><tr><td><code>revert</code></td><td>恢复</td><td>恢复之前的提交</td><td>🗑</td><td>-</td><td><code>true</code></td></tr></tbody></table><h2 id="提交别名"><a href="#提交别名" class="headerlink" title="提交别名"></a>提交别名</h2><p>别名允许拥有额外的提交类型（例如在<a href="https://github.com/commitizen/cz-cli">commitizen</a>等工具中），这些提交类型可以被格式化以遵循<a href="https://docs.google.com/document/d/1QrDFcIiPjSLDn3EL15IJygNPiHORgU1_OOAqWjiDU5Y/edit">AngularJS 提交消息约定</a>。</p><p>例如，<a href="https://github.com/commitizen/cz-cli">commitizen</a> CLI 可以提供选择<code>initial</code>，最终提交消息将是“feat：初始提交🎉”</p><table><thead><tr><th>提交类型</th><th>映射到</th><th>标题</th><th>描述</th><th>表情符号</th></tr></thead><tbody><tr><td><code>initial</code></td><td><code>feat</code></td><td>最初的</td><td>初始提交</td><td>🎉</td></tr><tr><td><code>dependencies</code></td><td><code>fix</code></td><td>依赖关系</td><td>更新依赖项</td><td>⬆️</td></tr><tr><td><code>peerDependencies</code></td><td><code>fix</code></td><td>对等依赖</td><td>更新对等依赖关系</td><td>⬆️</td></tr><tr><td><code>devDependencies</code></td><td><code>chore</code></td><td>开发依赖</td><td>更新开发依赖</td><td>⬆️</td></tr><tr><td><code>metadata</code></td><td><code>fix</code></td><td>元数据</td><td>更新元数据 (package.json)</td><td>📦</td></tr></tbody></table><h2 id="约定式提交规范"><a href="#约定式提交规范" class="headerlink" title="约定式提交规范"></a>约定式提交规范</h2><ol><li>每个提交都<strong>必须</strong>使用类型字段前缀，它由一个名词构成，诸如 <code>feat</code> 或 <code>fix</code> ， 其后接<strong>可选的</strong>范围字段，<strong>可选的</strong> <code>!</code>，以及<strong>必要的</strong>冒号（英文半角）和空格。</li><li>当一个提交为应用或类库实现了新功能时，<strong>必须</strong>使用 <code>feat</code> 类型。</li><li>当一个提交为应用修复了 bug 时，<strong>必须</strong>使用 <code>fix</code> 类型。</li><li>范围字段<strong>可以</strong>跟随在类型字段后面。范围<strong>必须</strong>是一个描述某部分代码的名词，并用圆括号包围，例如： <code>fix(parser):</code></li><li>描述字段<strong>必须</strong>直接跟在 &lt;类型&gt;(范围) 前缀的冒号和空格之后。 描述指的是对代码变更的简短总结，例如： <em>fix: array parsing issue when multiple spaces were contained in string</em> 。</li><li>在简短描述之后，<strong>可以</strong>编写较长的提交正文，为代码变更提供额外的上下文信息。正文<strong>必须</strong>起始于描述字段结束的一个空行后。</li><li>提交的正文内容自由编写，并<strong>可以</strong>使用空行分隔不同段落。</li><li>在正文结束的一个空行之后，<strong>可以</strong>编写一行或多行脚注。每行脚注都<strong>必须</strong>包含 一个令牌（token），后面紧跟 <code>:&lt;space&gt;</code> 或 <code>&lt;space&gt;#</code> 作为分隔符，后面再紧跟令牌的值（受 <a href="https://git-scm.com/docs/git-interpret-trailers">git trailer convention</a> 启发）。</li><li>脚注的令牌<strong>必须</strong>使用 <code>-</code> 作为连字符，比如 <code>Acked-by</code> (这样有助于 区分脚注和多行正文)。有一种例外情况就是 <code>BREAKING CHANGE</code>，它<strong>可以</strong>被认为是一个令牌。</li><li>脚注的值<strong>可以</strong>包含空格和换行，值的解析过程<strong>必须</strong>直到下一个脚注的令牌&#x2F;分隔符出现为止。</li><li>破坏性变更<strong>必须</strong>在提交信息中标记出来，要么在 &lt;类型&gt;(范围) 前缀中标记，要么作为脚注的一项。</li><li>包含在脚注中时，破坏性变更<strong>必须</strong>包含大写的文本 <code>BREAKING CHANGE</code>，后面紧跟着冒号、空格，然后是描述，例如： <em>BREAKING CHANGE: environment variables now take precedence over config files</em> 。</li><li>包含在 &lt;类型&gt;(范围) 前缀时，破坏性变更<strong>必须</strong>通过把 <code>!</code> 直接放在 <code>:</code> 前面标记出来。 如果使用了 <code>!</code>，那么脚注中<strong>可以</strong>不写 <code>BREAKING CHANGE:</code>， 同时提交信息的描述中<strong>应该</strong>用来描述破坏性变更。</li><li>在提交说明中，<strong>可以</strong>使用 <code>feat</code> 和 <code>fix</code> 之外的类型，比如：<em>docs: updated ref docs.</em> 。</li><li>工具的实现必须<strong>不区分</strong>大小写地解析构成约定式提交的信息单元，只有 <code>BREAKING CHANGE</code> <strong>必须</strong>是大写的。</li><li><code>BREAKING-CHANGE</code>作为脚注的令牌时<strong>必须</strong>是 <code>BREAKING CHANGE</code> 的同义词。</li></ol><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><ol><li>包含了描述并且脚注中有破坏性变更的提交说明</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">feat: allow provided config object to extend other configs</span><br><span class="line"></span><br><span class="line">BREAKING CHANGE: `extends` key in config file is now used for extending other config files</span><br></pre></td></tr></table></figure><ol start="2"><li>包含了 <code>!</code> 字符以提醒注意破坏性变更的提交说明</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">feat!: send an email to the customer when a product is shipped</span><br></pre></td></tr></table></figure><ol start="3"><li>包含了范围和破坏性变更 <code>!</code> 的提交說明</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">feat(api)!: send an email to the customer when a product is shipped</span><br></pre></td></tr></table></figure><ol start="4"><li>包含了 <code>!</code> 和 BREAKING CHANGE 脚注的提交说明</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">chore!: drop support for Node 6</span><br><span class="line"></span><br><span class="line">BREAKING CHANGE: use JavaScript features not available in Node 6.</span><br></pre></td></tr></table></figure><ol start="5"><li>不包含正文的提交说明</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docs: correct spelling of CHANGELOG</span><br></pre></td></tr></table></figure><ol start="6"><li>包含范围的提交说明</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">feat(lang): add polish language</span><br></pre></td></tr></table></figure><ol start="7"><li>包含多行正文和多行脚注的提交说明</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">fix: prevent racing of requests</span><br><span class="line"></span><br><span class="line">Introduce a request id and a reference to latest request. Dismiss</span><br><span class="line">incoming responses other than from latest request.</span><br><span class="line"></span><br><span class="line">Remove timeouts which were used to mitigate the racing issue but are</span><br><span class="line">obsolete now.</span><br><span class="line"></span><br><span class="line">Reviewed-by: Z</span><br><span class="line">Refs: #123</span><br></pre></td></tr></table></figure><h2 id="分支名规范"><a href="#分支名规范" class="headerlink" title="分支名规范"></a>分支名规范</h2><p>对于个人开发版本：</p><p>分支名格式：</p><blockquote><p>你的姓名&#x2F;特性关键字&#x2F;分支内容名（第一个字母小写，多个单词使用驼峰式）</p></blockquote><p><strong>新功能：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">yourName/feat/branchName</span><br><span class="line"></span><br><span class="line">例如</span><br><span class="line">zhangsan/feat/supportHttpLib</span><br></pre></td></tr></table></figure><p><strong>修复bug</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">yourName/fix/branchName</span><br><span class="line"></span><br><span class="line">例如</span><br><span class="line">zhangsan/fix/fixSelectServiceTime</span><br></pre></td></tr></table></figure><p><strong>发版的版本</strong>可以继续沿用1.2.0这种格式。</p><p><strong>特性关键字说明</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//既有feat，又有fix或者其他使用feat</span><br><span class="line">feat: 功能或者特性修改</span><br><span class="line">fix: 修复bug</span><br><span class="line">chore：非功能性修改，例如修正代码风格、修正错别字、重命名变量等</span><br><span class="line">docs:文档性更新</span><br><span class="line">test：增加测试。</span><br><span class="line">merge：代码合并。</span><br></pre></td></tr></table></figure><h2 id="其他手册"><a href="#其他手册" class="headerlink" title="其他手册"></a>其他手册</h2><p>约定式提交官网：<a href="https://www.conventionalcommits.org/zh-hans/">https://www.conventionalcommits.org/zh-hans/</a> </p><p>完整提交类型列表：<a href="https://github.com/pvdlg/conventional-changelog-metahub#commit-types">https://github.com/pvdlg/conventional-changelog-metahub#commit-types</a> </p><p>自动生成 CHANGELOG GitHub Action：<a href="https://github.com/marketplace/actions/changelog-from-conventional-commits">https://github.com/marketplace/actions/changelog-from-conventional-commits</a> </p><p>Conventional Changelog：<a href="https://github.com/conventional-changelog/standard-version">https://github.com/conventional-changelog/standard-version</a></p>]]></content>
      
      
      <categories>
          
          <category> Tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>soursetree</title>
      <link href="/Tools/Git/soursetree"/>
      <url>/Tools/Git/soursetree</url>
      
        <content type="html"><![CDATA[<h1 id="Soursetree"><a href="#Soursetree" class="headerlink" title="Soursetree"></a>Soursetree</h1><h1 id="代码拉取异常"><a href="#代码拉取异常" class="headerlink" title="代码拉取异常"></a>代码拉取异常</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git-ssh: connect to host github.com port 22: Connection timed out</span><br></pre></td></tr></table></figure><p>最近在更新了本地代码 node 版本后，提交代码时报错如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">`git pull project develop`</span><br><span class="line">`ssh: connect to host github.com port 22: Connection timed out`</span><br><span class="line">`fatal: Could not read from remote repository.</span><br></pre></td></tr></table></figure><p>本以为是网络的问题或者被墙了，在确认本地 git 可以访问和几次尝试后依旧报这个错，查了各种资料，最后参考 git 官网给的解决办法（<a href="https://links.jianshu.com/go?to=https://help.github.com/en/github/authenticating-to-github/using-ssh-over-the-https-port">https://help.github.com/en/github/authenticating-to-github/using-ssh-over-the-https-port</a>），使用 ssh 443端口</p><ol><li>先测试可用性</li></ol><p><code>ssh -T -p 443 git@ssh.github.com</code><br>如果提示如下说明可用</p><p><img src="https://upload-images.jianshu.io/upload_images/17080267-d7044850bfda0c00.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/900/format/webp" alt="one.jpg"></p><ol start="2"><li>然后编辑 <code>~/.ssh/config</code> 文件，如果没有config文件的话就直接 <code>vim ~/.ssh/config</code>加入以下内容</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Host github.com</span><br><span class="line">  Hostname ssh.github.com</span><br><span class="line">  Port 443</span><br><span class="line">  User git</span><br></pre></td></tr></table></figure><ol start="3"><li>再次测试</li></ol><p><code>ssh -T git@github.com</code><br>提示如下就说明成功了</p><p><img src="https://upload-images.jianshu.io/upload_images/17080267-b51a508fcee41f6b.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/904/format/webp" alt="two.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> Tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nginx</title>
      <link href="/Tools/Nginx/Nginx"/>
      <url>/Tools/Nginx/Nginx</url>
      
        <content type="html"><![CDATA[<h1 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h1><h2 id="一、Nginx的特点和功能"><a href="#一、Nginx的特点和功能" class="headerlink" title="一、Nginx的特点和功能"></a>一、Nginx的特点和功能</h2><h3 id="1-Nginx的特点"><a href="#1-Nginx的特点" class="headerlink" title="1.Nginx的特点"></a>1.Nginx的特点</h3><ol><li>高并发、高性能——基于事件驱动的模型</li><li>可扩展性好，支持模块化开发（插件开发）</li><li>可靠性高——4个9（99.99%）（阿里云 12个9）</li><li>热部署：动态加载配置文件（<strong>新替代旧的worker进程</strong>）</li></ol><h3 id="2-Nginx的功能"><a href="#2-Nginx的功能" class="headerlink" title="2. Nginx的功能"></a>2. Nginx的功能</h3><ol><li>访问静态资源：存储在服务器本地的文件（<code>*.html</code>、<code>*.jpeg/*.png</code>、<code>*.mp4/*.flv</code>)</li><li>API服务：通过路径的方式，提供计算服务（<code>/s？wd=123</code>、<code>/barbecue/s?</code>)</li><li>反向代理：在客户端和服务器之间充当中间层，将客户端的请求转发给后端的多个服务器，并将服务器的响应返回给客户端。</li><li>负载均衡：当一个网络或服务器系统面临大量的请求和流量时，负载均衡能够将这些请求分发到不同的服务器上，以避免单一服务器过载而导致性能下降或系统崩溃。</li></ol><h3 id="3-Apache与Nginx的对比"><a href="#3-Apache与Nginx的对比" class="headerlink" title="3. Apache与Nginx的对比"></a>3. Apache与Nginx的对比</h3><ul><li><p>Apache</p><p>Apache是基于进程的设计：每来一个连接，就会fork子进程进行处理</p><p>问题：无法处理大并发的情况 </p></li><li><p>Nginx</p><p>Nginx是基于事件驱动的设计：Linux: epoll IO多路复用机制</p><p>单线程就可以处理大量连接的操作：客户端在与服务器进行交互的过程中，将业务拆分成不同的阶段来进行处理</p><p>1G内存可以处理10W的连接</p></li></ul><h2 id="二、Nginx安装"><a href="#二、Nginx安装" class="headerlink" title="二、Nginx安装"></a>二、Nginx安装</h2><p>Nginx的安装有很多种方法，我们这里选择的是从源码安装Nginx。</p><ol><li>首先，需要先安装依赖的3个动态库。可以选择从源代码安装，也可以从包管理器中下载安装：</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install libz-dev #安装zlib库 处理压缩的事宜 </span><br><span class="line">sudo apt install libpcre3-dev #安装pcre库 处理正则表达式 </span><br><span class="line">sudo apt install libssl-dev #安装openssl库 处理SSL连接</span><br></pre></td></tr></table></figure><ol start="2"><li>从官方网站上获取源代码的压缩包：</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl -O https://nginx.org/download/nginx-1.23.3.tar.gz#下载</span><br><span class="line">tar xvfz nginx-1.23.3.tar.gz#解压</span><br></pre></td></tr></table></figure><ol start="3"><li>安装</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cd nginx-1.23.3.tar.gz # cd到源代码目录</span><br><span class="line">./configure # 生成makefile文件 </span><br><span class="line">make</span><br><span class="line">sudo make install # 将生成的文件移动到系统的合适目录下</span><br></pre></td></tr></table></figure><ol start="4"><li>启动</li></ol><p>在<code>/usr/local/nginx</code>下的<code>sbin</code>的<code>nginx</code>:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./sbin/nginx - c conf/nginx.conf</span><br></pre></td></tr></table></figure><blockquote><p>采用这种最简单的方式安装Nginx之后会只安装了最基本的模块，如果需要安装其他模块，则需要重新配置和install。</p><p>默认情况下，Nginx的默认目录是 <code>/usr/local/nginx/</code> ，可执行程序是<code> /usr/local/nginx/sbin/nginx</code> ，配置文件是 <code>/usr/local/nginx/conf/nginx.conf</code> 。</p></blockquote><h2 id="三、Nginx相关命令"><a href="#三、Nginx相关命令" class="headerlink" title="三、Nginx相关命令"></a>三、Nginx相关命令</h2><p>下面是一些相关的命令，注意应当使用<code>特权用户</code>启动<code>nginx</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/usr/local/nginx/sbin/nginx # 默认方式启动 </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">参数：</span> </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-h 查看帮助</span> </span><br><span class="line">-c x.conf # 指定配置文件x.conf启动 </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-p /opt/nginx 指定工作目录是/opt/nginx</span> </span><br><span class="line">-s stop # 强制停止nginx </span><br><span class="line">-s quit # 优雅停止nginx（等待当前任务结束） </span><br><span class="line">-s reload # 重启nginx </span><br><span class="line">-s reopen # 重新打开日志文件 </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 如果启动Nginx的时候使用了-c/-p，那么使用-s的时候也必须加上</span></span> </span><br><span class="line">-t # 检查默认配置文件 </span><br><span class="line">-T # 检查默认配置文件并输出 </span><br><span class="line">-t -c x.conf # 检查x.conf </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-v/-V 显示版本信息</span></span><br></pre></td></tr></table></figure><ul><li>快速关闭： 在还有连接没有服务完毕的情况下，直接关闭掉的</li><li>优雅关闭：在还有连接没有服务完毕的情况下，先处理完毕之后， 再关闭服务器 </li><li>热部署：在不中断现有服务的情况下，动态地更新或替换Nginx服务器的配置或代码。</li></ul><p>若要增加一些额外的模块或者是修改默认的安装位置，可以使用下面定制安装的命令。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">configure命令的选项</span> </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">./configure --<span class="built_in">help</span> 查看帮助</span> </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">--prefix=/opt/nginx 修改安装位置</span> </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">--with-pcre=/path/to/pcre-8.33 指定pcre8.33的源码路径为/path/to/pcre-8.33</span> </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">--with-xxx_module 增加xxx模块</span> </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">--without-xxx_module 去掉默认的xx模块</span> </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">--with-debug 在日志中打印调试信息</span> </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">--with-ld-opt=OPTIONS 在gcc编译时补充OPTIONS选项，通常用于链接库文件</span> </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">--add_module=PATH 增加第3方模块</span> </span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">make modules <span class="comment"># 只编译变动的模块</span></span></span><br></pre></td></tr></table></figure><h2 id="四、Nginx配置文件"><a href="#四、Nginx配置文件" class="headerlink" title="四、Nginx配置文件"></a>四、Nginx配置文件</h2><h3 id="1-配置文件位置"><a href="#1-配置文件位置" class="headerlink" title="1. 配置文件位置"></a>1. 配置文件位置</h3><p>默认情况下：配置文件是 <code>/usr/local/nginx/conf/nginx.conf</code> 。但是可以在执行时候用<code>-c</code>指定配置文件x.conf启动 </p><h3 id="2-配置文件的语法特性"><a href="#2-配置文件的语法特性" class="headerlink" title="2. 配置文件的语法特性"></a>2. 配置文件的语法特性</h3><p>配置文件是<strong>上下文</strong>的集合。上下文是一个包含很多<strong>指令</strong>的块，不同的上下文负责指定不同部分的功能。常见上下文包括：main、http、server、upstream、location 和mail等等。上下文之间是不能重叠的，此外也不存在所谓的”全局”服务器配置文件。配置文件的语法尽量向C风格看齐，特别是使用花括号来描述作用域，从实现一个简明的描述上下文之间嵌套关系的表示方法。Nginx支持丰富的指令。其中大部分指令是比较简单且无副作用的，但是有少数指令的使用就需要对Nginx的深入理解了——比如经常使用的高级指令rewrite。</p><p>Nginx的配置文件有着这样的特性：</p><ul><li>使用#单行注释；</li><li>指令用分号结尾，多个参数用空格分隔，如果参数本身有空格，可以使用引号，指令形式<code>key value(s)</code>；</li><li>使用单引号和双引号界定字符串，使用反斜杠转义；</li><li>用大括号括住的范围称为一个指令块，指令块也可以称为上下文(context) ， 指令块内部可以设置多条指令，并且无需分号结尾（类似于C里面的语句块）；</li><li>有些指令只能出现在特定的上下文当中；</li><li>指令块内部可以是指令，也允许嵌套内部块，；</li><li><code>include</code>指令可以包含其他配置文件，支持通配符<code>*</code>；</li><li><code>$</code>符号开头的代表的是变量，变量是有<code>nginx</code>提供的</li></ul><h3 id="3-使用示例的配置文件"><a href="#3-使用示例的配置文件" class="headerlink" title="3. 使用示例的配置文件"></a>3. 使用示例的配置文件</h3><p>当Nginx配置完成以后，Nginx默认提供了一个默认的配置文件，路径是 <code>/usr/local/nginx/conf/nginx.conf</code> ，把所有的注释去掉，通过这个配置文件启动的Nginx的功能就非常的简单，就是提供一个 <code>index.html </code>的<code>HTML</code>文件返回给客户端。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">worker_processes</span> <span class="number">1</span>;</span><br><span class="line"><span class="section">events</span> &#123; </span><br><span class="line">  <span class="attribute">worker_connections</span> <span class="number">1024</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="section">http</span> &#123;</span><br><span class="line">  <span class="attribute">include</span> mime.types;</span><br><span class="line">  <span class="attribute">default_type</span> application/octet-stream;</span><br><span class="line">  <span class="attribute">sendfile</span> <span class="literal">on</span>; </span><br><span class="line">  <span class="attribute">keepalive_timeout</span> <span class="number">65</span>; </span><br><span class="line">  <span class="section">server</span> </span><br><span class="line">  &#123; </span><br><span class="line">    <span class="attribute">listen</span> <span class="number">80</span>; </span><br><span class="line">    <span class="attribute">server_name</span> localhost; </span><br><span class="line">    <span class="section">location</span> / &#123; </span><br><span class="line">      <span class="attribute">root</span> html; </span><br><span class="line">                <span class="attribute">index</span> index.html index.htm; </span><br><span class="line">               &#125;</span><br><span class="line">    <span class="attribute">error_page</span> <span class="number">500</span> <span class="number">502</span> <span class="number">503</span> <span class="number">504</span> /50x.html;</span><br><span class="line">    <span class="section">location</span> = /50x.html </span><br><span class="line">    &#123; </span><br><span class="line">      <span class="attribute">root</span> html; </span><br><span class="line">    &#125; </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>main</code>上下文： 全局位置的指令位于main上下文</li><li><code>http</code>上下文： 制定了HTTP服务器相关的属性</li><li><code>server</code>上下文：指定了一个虚拟服务器</li><li><code>location</code>上下文： 为不同的路径设置不同的服务</li></ul><p>下面我们来详细解析一下这个配置文件：</p><ul><li><p>在全局上下文当中，存在一个<code>worker_processs</code>指令、一个<code>events</code>指令块和一个<code>http</code>指令块；</p></li><li><p><code>worker_process</code>指令指定了工作进程个数为<code>1</code>；</p></li><li><p><code>events</code>指令块说明了每个工作进程同时能支持的最大连接数是<code>1024</code>；</p></li><li><p><code>http</code>指令块首先引入了同目录的另一个文件<code>mime.types</code>；</p></li><li><p>然后<code>http</code>指令块设置一些属性，比如默认的响应类型、是否调用<code>sendfile</code>函数传输文件以及复用<code>tcp</code>连接的超时时限；</p></li><li><p><code>http</code>块上下文当中存在一个<code>server</code>块，这个<code>server</code>块描述一个虚拟服务端</p><ul><li><code>server</code>监听了<code>80</code>端口；</li><li><code>server</code>名字是<code>localhost</code>；</li><li>当有<code>URL</code>的路径部分匹配 <code>/</code> 时，找到服务端的<code>html</code>目录，访问其中的<code>index.html</code>文件；</li><li>HTTP的响应是500、502、503或者是504时，将URL的路径部分改写成 <code>/50x.html</code> ；</li><li>当有URL的路径部分匹配 <code>/50x.html</code> 时，找到服务端的html目录，访问其中的<code>50x.html</code>文件；</li></ul></li></ul><p>启动这个进程：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/local/nginx/sbin/nginx</span><br></pre></td></tr></table></figure><p>然后使用浏览器输入服务端的IP地址即可显示Nginx的欢迎页。</p><h3 id="4-main上下文的指令"><a href="#4-main上下文的指令" class="headerlink" title="4. main上下文的指令"></a>4. main上下文的指令</h3><ol><li><p><code>user</code>指令</p><p><code>worker_process</code>在工作时，以<code>nobody</code>用户运行的，需要将其改成<code>root</code>用户</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">user</span> root;<span class="comment">#放在最前面</span></span><br></pre></td></tr></table></figure></li><li><p><code>work_processes</code>指令用来配置<code>worker</code>进程的数量，一般来说这个数值和CPU核心数以及业务的计算密集程度有关。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">worker_processes</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure></li><li><p><code>events</code>块用来配置事件模块的属性。它可以配置<code>worker</code>进程的一些属性，比如最大连接数、是否启用<code>accept</code>互斥锁来避免惊群、是否启用异步IO等等。一般来说其属性不需要做任何的修改。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">events</span> &#123;</span><br><span class="line">    <span class="attribute">worker_connections</span>  <span class="number">1024</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>events</code>指令块说明了每个工作进程同时能支持的最大连接数是<code>1024</code>；</p></li><li><p>日志系统</p></li></ol><ul><li><p>全局上下文指令是core模块的<code>pid</code></p><p>pid指令描述了pid文件的路径，pid文件里面存储一个进程的pid，这样用户在使用命令发送信号的就能找到目标进程。默认的pid文件是<code>logs/nginx.pid</code>。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">pid</span> logs/nginx.pid;<span class="comment">#不同配置文件设定不同的nginx.pid(eg：nginx1.pid、nginx2.pid)</span></span><br></pre></td></tr></table></figure><blockquote><p>提问🙋：1个配置文件是否可以启动多个nginx服务器呢？</p><p>答：因为同一个配置文件的端口号是相同的，只有不同的配置文件中设置不同的端口，才可以同时启动多个 nginx服务器</p></blockquote><p><font color=#0099ff>多个配置文件启动多个nginx服务器</font></p><blockquote><p>nginx使用命令行发送信号的原理： </p><p>当nginx服务器启动时，会默认在logs目录之下产生一个<strong>nginx.pid</strong>文件，该 文件中存储的就是master进程的pid。当使用命令行 -s 去发送信号时，会先读取nginx.pid文件，获取master进程 的pid，之后再发送信号。</p></blockquote><p>有了pid指令指向不同的文件之后，就可以通过<code>-s</code>选项来关闭各自不同的nginx服务器。</p></li><li><p>全局上下文指令式core模块的<code>error_log</code></p><p>error_log指定了错误日志文件的路径和log记录的级别。一般生产环境选择默认的error级别即可。error_log这个指令是可以出现不同的上下文当中，如果块的内部和外部使用了同一个error_log指令，则采用就近原则生效。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">error_log</span> logs/<span class="literal">error</span>.log <span class="literal">error</span>;</span><br></pre></td></tr></table></figure></li></ul><h3 id="5-http上下文的指令"><a href="#5-http上下文的指令" class="headerlink" title="5. http上下文的指令"></a>5. http上下文的指令</h3><p><code>http</code>指令块是整个Nginx配置当中最重要的一个模块，它影响了从请求建立、接收请求、生成响应、过滤响应等HTTP服务端的各个步骤。</p><ol><li><p>指令<code>log_format</code>，需要值得注意的是，它是属于http模块的子模块<code>http_log</code>模块的。<code>log_format</code>首先为格式起了一个名字，然后的格式参数是一个字符串，用来表示记录到日志文件当中的内容，在这个格式参数当中可以引用变量。下面就是Nginx示例当中提供的例子。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">log_format</span> main <span class="string">&#x27;<span class="variable">$remote_addr</span> - <span class="variable">$remote_user</span> [<span class="variable">$time_local</span>] &quot;<span class="variable">$request</span>&quot; &#x27;</span></span><br><span class="line"><span class="string">&#x27;<span class="variable">$status</span> <span class="variable">$body_bytes_sent</span> &quot;<span class="variable">$http_referer</span>&quot; &#x27;</span></span><br><span class="line">                <span class="string">&#x27;&quot;<span class="variable">$http_user_agent</span>&quot; &quot;<span class="variable">$http_x_forwarded_for</span>&quot;&#x27;</span>;</span><br></pre></td></tr></table></figure><p>可以使用同属于<code>http_log</code>模块的<code>access_log</code>指令来指定日志文件的路径。(最好是让每一个配置文件使用不同的路径。)</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">access_log</span> logs/access_log main;</span><br></pre></td></tr></table></figure><p><code>access_log</code>用于指定记录访问日志的位置和格式。访问日志记录了每个客户端请求服务器的详细信息，包括请求的时间、客户端IP地址、请求的HTTP方法、URI、HTTP状态码等。这些日志对于监控服务器的流量、分析用户行为、排查问题以及进行性能优化都非常有用。</p><p>这里是日志内容的示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1 - - [17/May/2022:17:11:22 +0800] &quot;GET / HTTP/1.1&quot; 200 612 &quot;-&quot; &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/101.0.4951.64 Safari/537.36 Edg/101.0.1210.47&quot;</span><br></pre></td></tr></table></figure></li><li><p>Nginx示例当中提供的例子</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">http</span> &#123;</span><br><span class="line">    <span class="attribute">include</span>       mime.types;<span class="comment">#包含另外一个文件中的信息</span></span><br><span class="line">    <span class="attribute">default_type</span>  application/octet-stream;</span><br><span class="line">    <span class="attribute">sendfile</span>        <span class="literal">on</span>;<span class="comment">#零拷贝</span></span><br><span class="line">    <span class="attribute">keepalive_timeout</span>  <span class="number">65</span>;<span class="comment">#超时时间</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><code>mime.types</code>指定类型</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">types &#123;</span><br><span class="line">    text/html                                        html htm shtml;</span><br><span class="line">    text/css                                         css;</span><br><span class="line">    text/xml                                         xml;</span><br><span class="line">    image/gif                                        gif;</span><br><span class="line">    image/jpeg                                       jpeg jpg;</span><br><span class="line">    application/javascript                           js;</span><br><span class="line">    application/atom+xml                             atom;</span><br><span class="line">    application/rss+xml                              rss;</span><br><span class="line">    #等等</span><br></pre></td></tr></table></figure></li></ol><h3 id="6-server上下文的指令"><a href="#6-server上下文的指令" class="headerlink" title="6. server上下文的指令"></a>6. server上下文的指令</h3><p><code>server</code>块出现在<code>http</code>上下文当中，它描述一个nginx将要提供的虚拟服务端——这里虚拟的含义是指，客户端在感觉上会把不同的<code>server</code>看成是不同的服务端，而实际上在服务端操作系统上只存在一份进程。</p><ol><li><p><code>server</code>块的<code>listen</code>指令。这个指令描述了该虚拟服务端将要监听的端口号，<code>listen</code>指令还支持监听<code>unix</code>域<code>socketpair</code>。不同的<code>server</code>块应该选择监听不同的端口号。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123; </span><br><span class="line"><span class="attribute">listen</span> <span class="number">80</span>; <span class="comment">#监听端口</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>server</code>块的<code>server_name</code>指令。这个指令设置了虚拟服务端的名字，这样的话，在配置文件当中，用户就可以使用多个server监听同一个端口，当用户请求接入的时候，会根据请求的URL域名的不同选择不同的虚拟服务端。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123; </span><br><span class="line"><span class="attribute">listen</span> <span class="number">80</span>; <span class="comment">#监听端口</span></span><br><span class="line"><span class="attribute">server_name</span> test.org;<span class="comment">#设置了虚拟服务端的名字</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改域名映射在本地<code>/etc/hosts</code>文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1 test.org </span><br><span class="line">127.0.0.1 test1.org</span><br></pre></td></tr></table></figure></li><li><p>示例</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">http</span> &#123;</span><br><span class="line"><span class="attribute">include</span> mime.types; </span><br><span class="line"><span class="attribute">default_type</span> application/octet-stream;</span><br><span class="line">  <span class="attribute">sendfile</span> <span class="literal">on</span>; <span class="attribute">keepalive_timeout</span> <span class="number">65</span>;</span><br><span class="line">  <span class="section">server</span> </span><br><span class="line">  &#123; </span><br><span class="line">    <span class="attribute">listen</span> <span class="number">80</span>; </span><br><span class="line">    <span class="attribute">server_name</span> test.org; </span><br><span class="line">    <span class="section">location</span> / </span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attribute">return</span> <span class="number">200</span> <span class="string">&quot;hello&quot;</span>; </span><br><span class="line">    &#125; </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="section">server</span> </span><br><span class="line">  &#123; </span><br><span class="line">    <span class="attribute">listen</span> <span class="number">80</span>; </span><br><span class="line">    <span class="attribute">server_name</span> test1.org; </span><br><span class="line">    <span class="section">location</span> / </span><br><span class="line">    &#123; </span><br><span class="line">      <span class="attribute">return</span> <span class="number">200</span> <span class="string">&quot;world&quot;</span>; </span><br><span class="line">    &#125; </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>随后使用curl命令就可以进行调试了。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl test.org </span><br><span class="line">curl test1.org</span><br></pre></td></tr></table></figure></li></ol><h3 id="7-location上下文的指令"><a href="#7-location上下文的指令" class="headerlink" title="7. location上下文的指令"></a>7. location上下文的指令</h3><p><code>location</code>配置块出现在<code>server</code>上下文中，它可以根据URL的路径部分，匹配一个合适的location，并执行块内的指令。从这个角度来看，locaiton部分是Nginx请求处理的终点站。</p><p><code>location</code>的路径的5种不同写法,具体如下：</p><ol><li><p>location uri {} 不带符号的前缀匹配</p><p><font color=#0099ff>在域名之后可以不添加路径信息， 此时会自动匹配之后根路径的情况 </font></p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">location</span> / &#123;</span><br><span class="line">        <span class="attribute">return</span> <span class="number">200</span> <span class="string">&quot;/\n&quot;</span>;<span class="comment">#IP默认</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="section">location</span> /a &#123;</span><br><span class="line">        <span class="attribute">return</span> <span class="number">200</span> <span class="string">&quot;/a\n&quot;</span>;<span class="comment">#IP/a</span></span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="section">location</span> /ab &#123;</span><br><span class="line">        <span class="attribute">return</span> <span class="number">200</span> <span class="string">&quot;/ab\n&quot;</span>;<span class="comment">#IP/abIP/abCd</span></span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="section">location</span> /abc &#123;</span><br><span class="line">        <span class="attribute">return</span> <span class="number">200</span> <span class="string">&quot;/abc\n&quot;</span>;<span class="comment">#IP/abcIP/abcd</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>匹配路径有重复的情况下，是会自动 根据<strong>最长匹配原则</strong>进行匹配</p></li><li><p>location ~ uri {} 正则匹配，大小写敏感 </p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">location</span> / &#123;</span><br><span class="line">        <span class="attribute">return</span> <span class="number">200</span> <span class="string">&quot;/\n&quot;</span>;<span class="comment">#IP默认</span></span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="section">location</span> /a &#123;</span><br><span class="line">        <span class="attribute">return</span> <span class="number">200</span> <span class="string">&quot;/a\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="section">location</span> /ab &#123;</span><br><span class="line">        <span class="attribute">return</span> <span class="number">200</span> <span class="string">&quot;/ab\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="section">location</span> /abc &#123;</span><br><span class="line">        <span class="attribute">return</span> <span class="number">200</span> <span class="string">&quot;/abc\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="section">location</span> <span class="regexp">~ /[a-z]+</span> &#123;</span><br><span class="line">        <span class="attribute">return</span> <span class="number">200</span> <span class="string">&quot; ~ /[a-z]+\n&quot;</span>;<span class="comment">#IP/a#IP/ab#IP/abc#IP/abcd</span></span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="section">location</span> <span class="regexp">~ /ab</span> &#123;</span><br><span class="line">        <span class="attribute">return</span> <span class="number">200</span> <span class="string">&quot; ~ /ab\n&quot;</span>;<span class="comment">#IP/ab#IP/abc#IP/abcd</span></span><br><span class="line">    &#125;<span class="comment">#但此时~ /[a-z]+在前面，则优先匹配~ /[a-z]+</span></span><br></pre></td></tr></table></figure><ul><li><p>明当有多组正则匹配时， 还依赖于其配置文件中的顺序，优先匹配靠前的正则匹配</p></li><li><p>正则匹配的优先级高于不带符号的前缀匹配</p></li></ul></li><li><p>location ~* uri {} 正则匹配，忽略大小写 </p><p>与上面大致相同，只是忽略大小写。</p><p><a href="https://www.runoob.com/regexp/regexp-tutorial.html">正则表达式教程</a></p></li><li><p>location ^~ uri {} 带符号的前缀匹配 </p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">location</span> / &#123;</span><br><span class="line">        <span class="attribute">return</span> <span class="number">200</span> <span class="string">&quot;/\n&quot;</span>;<span class="comment">#IP默认</span></span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="section">location</span> /a &#123;</span><br><span class="line">        <span class="attribute">return</span> <span class="number">200</span> <span class="string">&quot;/a\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="section">location</span> /abc &#123;</span><br><span class="line">        <span class="attribute">return</span> <span class="number">200</span> <span class="string">&quot;/ab\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="section">location</span> <span class="regexp">~ /[a-z]+</span> &#123;</span><br><span class="line">        <span class="attribute">return</span> <span class="number">200</span> <span class="string">&quot; ~ /[a-z]+\n&quot;</span>;<span class="comment">#IP/a#IP/abc#IP/abcd</span></span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="section">location</span> <span class="regexp">~ /ab</span> &#123;</span><br><span class="line">        <span class="attribute">return</span> <span class="number">200</span> <span class="string">&quot; ~ /ab\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="section">location</span><span class="regexp"> ^~</span> /ab &#123;</span><br><span class="line">        <span class="attribute">return</span> <span class="number">200</span> <span class="string">&quot;^~ /ab\n&quot;</span>;<span class="comment">#IP/ab</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>当不带符号的前缀匹配与带符号的前缀匹配形式是相同时，无法同时存在，配置文件会报错</li><li>带符号的前缀匹配优先级高于正则匹配的</li><li><font color=#0099ff>注意</font>：对于前缀匹配而言， 不管是带符号 的，还是不带符号的，都是先采用最长匹配原则进行匹配，之后得到一个结果A，再根据A的结果与正则进行比较。上例中<code>IP/abc</code>时，<code>/abc</code>和<code>^~ /ab</code>采取最长匹配原则进行匹配，得到<code>/abc</code>,此时的优先级不带符号的前缀匹配<code>/abc</code>小于正则匹配的<code>~ /[a-z]+</code>。所以结果是<code>~ /[a-z]+</code>。</li></ul></li><li><p>location &#x3D; uri {} 完全匹配</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">location</span> / &#123;</span><br><span class="line">        <span class="attribute">return</span> <span class="number">200</span> <span class="string">&quot;/\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="section">location</span> /a &#123;</span><br><span class="line">        <span class="attribute">return</span> <span class="number">200</span> <span class="string">&quot;/a\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="section">location</span> /ab &#123;</span><br><span class="line">        <span class="attribute">return</span> <span class="number">200</span> <span class="string">&quot;/ab\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="section">location</span> <span class="regexp">~ /[a-z]+</span> &#123;</span><br><span class="line">        <span class="attribute">return</span> <span class="number">200</span> <span class="string">&quot; ~ /[a-z]+\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="section">location</span> <span class="regexp">~ /ab</span> &#123;</span><br><span class="line">        <span class="attribute">return</span> <span class="number">200</span> <span class="string">&quot; ~ /ab\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="section">location</span><span class="regexp"> ^~</span> /abc &#123;</span><br><span class="line">        <span class="attribute">return</span> <span class="number">200</span> <span class="string">&quot;^~ /abc\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="section">location</span> = /abc &#123;</span><br><span class="line">        <span class="attribute">return</span> <span class="number">200</span> <span class="string">&quot;= /abc \n&quot;</span>;<span class="comment">#IP/abc</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li><strong>完全匹配</strong>优先级最高</li></ul></li></ol><blockquote><p>优先级：完全匹配&gt;带符号的前缀匹配&gt;正则匹配&gt;不带符号的前缀匹配</p><p>注意：对于前缀匹配而言， 不管是带符号 的，还是不带符号的，都是先采用最长匹配原则进行匹配，之后得到一个结果A，再根据A的结果与正则进行比较。</p></blockquote><h2 id="五、Nginx部分功能实现"><a href="#五、Nginx部分功能实现" class="headerlink" title="五、Nginx部分功能实现"></a>五、Nginx部分功能实现</h2><h3 id="1-Nginx部署静态资源"><a href="#1-Nginx部署静态资源" class="headerlink" title="1. Nginx部署静态资源"></a>1. Nginx部署静态资源</h3><p>使用file配置块可以根据不同的uri为用户响应的不同的文件。有些文件，比如HTML、png、svg之类的文件，浏览器可以直接在窗口中渲染显示，其他类型的文件访问时会直接下载到客户端机器上。我们把向用户直接提供网页资源的服务端称为静态资源服务器。</p><p>静态资源： <code>.html</code>、<code>.css</code>、<code>.gif</code>、<code>.js</code>(需要指定其在服务器上的路径信息(目录) )</p><p>root：设置服务器上所在的根目录</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#root path; </span></span><br><span class="line"><span class="comment">#设置文档的路径起始，path是服务端主机上的本地文件路径 </span></span><br><span class="line"><span class="comment">#path可以写绝对地址，也可以写相对地址（当前工作目录由configure程序决定，一般是/usr/local/nginx） </span></span><br><span class="line"><span class="section">location</span> /image/&#123; </span><br><span class="line">  <span class="attribute">root</span> dir/; </span><br><span class="line">  <span class="comment">#如果uri是ip:port/image/abc.txt 实际对应的服务端主机的文件如下</span></span><br><span class="line"><span class="comment">#/usr/local/nginx/dir/image/abc.txt </span></span><br><span class="line">  <span class="comment"># 路径是root的路径加上端口后的拼接路径</span></span><br><span class="line">    <span class="comment">#如果出现了文件未找到的问题，可以查阅error.log </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-部署cppreference参考文档"><a href="#2-部署cppreference参考文档" class="headerlink" title="2. 部署cppreference参考文档"></a>2. 部署cppreference参考文档</h3><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">user</span> root;</span><br><span class="line"><span class="attribute">worker_processes</span>  <span class="number">1</span>;</span><br><span class="line"><span class="attribute">error_log</span>  logs/<span class="literal">error</span>1.log;</span><br><span class="line"><span class="section">events</span> &#123;</span><br><span class="line">    <span class="attribute">worker_connections</span>  <span class="number">1024</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="section">http</span> &#123;</span><br><span class="line">    <span class="attribute">include</span>       mime.types;</span><br><span class="line">    <span class="attribute">default_type</span>  application/octet-stream;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">log_format</span>  main  <span class="string">&#x27;<span class="variable">$remote_addr</span> - <span class="variable">$remote_user</span> [<span class="variable">$time_local</span>] &quot;<span class="variable">$request</span>&quot; &#x27;</span></span><br><span class="line">                      <span class="string">&#x27;<span class="variable">$status</span> <span class="variable">$body_bytes_sent</span> &quot;<span class="variable">$http_referer</span>&quot; &#x27;</span></span><br><span class="line">                      <span class="string">&#x27;&quot;<span class="variable">$http_user_agent</span>&quot; &quot;<span class="variable">$http_x_forwarded_for</span>&quot;&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">access_log</span>  logs/access1.log  main;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">sendfile</span>        <span class="literal">on</span>;</span><br><span class="line">    <span class="attribute">keepalive_timeout</span>  <span class="number">65</span>;</span><br><span class="line">    <span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span>       <span class="number">80</span>;</span><br><span class="line">        <span class="attribute">server_name</span>  localhost;</span><br><span class="line"></span><br><span class="line">        <span class="section">location</span> /en &#123;</span><br><span class="line">            <span class="comment">#root   html;# 相对路径的用法</span></span><br><span class="line">            <span class="attribute">root</span> /home/lwh/documents/cppreference;</span><br><span class="line">            <span class="attribute">index</span> index.html;<span class="comment">#找到对应的静态资源</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="section">location</span> /common &#123;</span><br><span class="line">            <span class="comment">#root   html;# 相对路径的用法</span></span><br><span class="line">            <span class="attribute">root</span> /home/lwh/documents/cppreference;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-隐藏路径信息"><a href="#3-隐藏路径信息" class="headerlink" title="3. 隐藏路径信息"></a>3. 隐藏路径信息</h3><p>alias</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># alias path; </span></span><br><span class="line"><span class="comment">#实现和root类似的效果 </span></span><br><span class="line"><span class="comment">#alias会把location部分替换成path</span></span><br><span class="line"><span class="comment">#root限制了uri必须按照的主机路径格式进行访问，而alias则不必 </span></span><br><span class="line"><span class="section">location</span> /image/&#123; </span><br><span class="line">  <span class="attribute">alias</span> dir/; </span><br><span class="line">  <span class="comment">#如果uri是ip:port/image/abc.txt 实际对应的服务端主机的文件如下：</span></span><br><span class="line">  <span class="comment"># /usr/local/nginx/dir/abc.txt </span></span><br><span class="line">  <span class="comment"># 路径是alias的路径加上端口后的，去除location相同后的拼接路径</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-开启压缩功能"><a href="#4-开启压缩功能" class="headerlink" title="4. 开启压缩功能"></a>4. 开启压缩功能</h3><p><code>gzip</code>:在http的上下文中</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">gzip</span> <span class="literal">on</span>; </span><br><span class="line"><span class="comment"># 开启gzip压缩 </span></span><br><span class="line"><span class="attribute">gzip_min_length</span> <span class="number">100</span>; </span><br><span class="line"><span class="comment"># 低于100个字节响应体将不会被压缩 </span></span><br><span class="line"><span class="attribute">gzip_comp_level</span> <span class="number">4</span>; </span><br><span class="line"><span class="comment"># 设定gzip压缩的级别(1-9)，级别越高压缩比率越低，速率越慢 </span></span><br><span class="line"><span class="attribute">gzip_types</span> text/plain text/css; </span><br><span class="line"><span class="attribute">gzip_types</span> text/css application/javascript;</span><br><span class="line"><span class="comment"># 设定某个MIME类型的响应体一定会被压缩，text/html一定会被压缩</span></span><br></pre></td></tr></table></figure><h2 id="六、反向代理"><a href="#六、反向代理" class="headerlink" title="六、反向代理"></a>六、反向代理</h2><p>在Web应用的设计过程，有的时候并不适合直接让客户端和服务端之间相连，而是增加一些中间服务器用于转发请求和响应。如果代理服务器的设计是为了将某个客户端的请求按需从多个服务器当中分配一个的话，那么这个代理服务器就是<strong>反向代理</strong>服务器。</p><p><img src="https://cdn.jsdelivr.net/gh/Barbecue-g/imagehost/Tools/Nginx/%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86.png?raw=true" alt="Nginx"></p><p>企业内部的Nginx反向代理和服务器对用户来说都是透明的。</p><p><code>proxy</code>服务器要实现转发客户端的 请求操作，因此要使用另一个指令<code>proxy_pass</code></p><h3 id="1-proxy-pass配置"><a href="#1-proxy-pass配置" class="headerlink" title="1. proxy_pass配置"></a>1. <code>proxy_pass</code>配置</h3><p>反向代理最重要的proxy_pass指令，位于location上下文，用于指定将接收的请求按照其URI参数进行转发</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">proxy_pass</span> URL; </span><br><span class="line"><span class="comment"># 将当前请求反向代理到URL参数指定的服务器上面 </span></span><br><span class="line"><span class="comment"># URL可以是协议名(http/https)+主机名或IP地址+端口 或者是 UNIX句柄 + 路径 </span></span><br><span class="line"><span class="attribute">proxy_pass</span> http://localhost:8000/uri/;</span><br><span class="line"><span class="attribute">proxy_pass</span> http://unix:/tmp/backend.socket:/uri/;</span><br></pre></td></tr></table></figure><p>反向代理还有一些其他的指令可以使用。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">proxy_set_header</span> field value; </span><br><span class="line"><span class="comment"># 修改或者增加请求首部之后再转发 默认情况下只转发Host和Connection=close </span></span><br><span class="line"><span class="attribute">proxy_method</span> method;</span><br><span class="line"><span class="comment"># 修改向服务端的方法</span></span><br><span class="line"><span class="attribute">proxy_hide_header</span> field; </span><br><span class="line"><span class="comment"># 隐藏服务端返回响应的首部字段 </span></span><br><span class="line"><span class="attribute">proxy_pass_header</span> field;</span><br><span class="line"><span class="comment"># 显示服务端返回响应的首部字符，如Date，Server之类的 </span></span><br><span class="line"><span class="attribute">proxy_redirect</span> <span class="literal">redirect</span> replacement|default; </span><br><span class="line"><span class="comment"># 当上游服务器反馈的响应是重定向或者刷新请求，proxy_redirect可以重设HTTP头部的location或者refresh字段</span></span><br><span class="line"><span class="attribute">proxy_set_header</span> Host <span class="variable">$host</span>;</span><br><span class="line"><span class="comment">#在代理过程中保持正确的主机名信息。</span></span><br><span class="line"><span class="attribute">proxy_set_header</span> X-Real-IP <span class="variable">$remote_addr</span>;</span><br><span class="line"><span class="comment">#设置转发客户端的真实IP地址</span></span><br><span class="line"><span class="attribute">proxy_set_header</span> X-Forwarded_For <span class="variable">$proxy_add_x_forwarded_for</span>;</span><br><span class="line"><span class="comment">#设置转发上一台服务器的IP地址</span></span><br></pre></td></tr></table></figure><h3 id="2-upstream的配置"><a href="#2-upstream的配置" class="headerlink" title="2. upstream的配置"></a>2. <code>upstream</code>的配置</h3><ul><li><code>upstream</code>块位于<strong>HTTP上下文</strong>，它定义了一个<strong>上游服务器的集群</strong>，以便<code>proxy_pass</code>使用。</li></ul><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">upstream</span> name &#123;...&#125; </span><br><span class="line"><span class="comment">#下面是一个例子 </span></span><br><span class="line"><span class="section">upstream</span> backend&#123; </span><br><span class="line">  <span class="attribute">server</span> backend1.example.com weight=<span class="number">5</span>; </span><br><span class="line">  <span class="attribute">server</span> <span class="number">127.0.0.1:8080</span> max_fails=<span class="number">3</span> fail_timeout=<span class="number">30s</span>; </span><br><span class="line">  <span class="attribute">server</span> unix:/tmp/backend3; </span><br><span class="line">  <span class="attribute">server</span> backup1.example.com backup; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>server</code>指令，出现在<code>upstream</code>上下文，指定一个上游服务器的名字，可以用域名、ip端口或者是UNIX句柄。</li></ul><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">server</span> address [parameters]; </span><br><span class="line"><span class="comment">#parameters可以是下列参数 </span></span><br><span class="line"><span class="comment">#weight=number server的权重，默认是1 </span></span><br><span class="line"><span class="comment">#max_conns=number 限制被代理的服务器的同时连接数，默认0表示无限制</span></span><br><span class="line"><span class="comment">#max_fails=number fail_timeout=3 限制失败次数和超市时间 #backup 表示这个服务器是备胎</span></span><br></pre></td></tr></table></figure><h3 id="3-示例测试"><a href="#3-示例测试" class="headerlink" title="3. 示例测试"></a>3. 示例测试</h3><p>配合上预先定义好的upstream配置块，使用proxy_pass可以以服务器集群为目标进行转发，并且可以根据一定的策略进行选择。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">http&#123; </span><br><span class="line">  <span class="section">upstream</span> backend &#123;</span><br><span class="line">    <span class="attribute">server</span> <span class="number">127.0.0.1:1234</span> weight=<span class="number">1</span>;</span><br><span class="line">    <span class="attribute">server</span> <span class="number">127.0.0.1:1235</span> weight=<span class="number">2</span>; </span><br><span class="line">    <span class="comment"># 设置服务器集群时，如果是nginx的虚拟服务端，需要listen不同的端口，否则无法按策略选择集群 内主机</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="section">server</span> &#123; </span><br><span class="line">    <span class="attribute">listen</span> <span class="number">1234</span>; </span><br><span class="line">    <span class="attribute">server_name</span> test1.cc;</span><br><span class="line">    <span class="section">location</span> /&#123; </span><br><span class="line">      <span class="attribute">echo</span> <span class="string">&#x27;test1 <span class="variable">$uri</span>&#x27;</span>; </span><br><span class="line">    &#125; </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="section">server</span> &#123; </span><br><span class="line">    <span class="attribute">listen</span> <span class="number">1235</span>; </span><br><span class="line">    <span class="attribute">server_name</span> test2.cc; </span><br><span class="line">    <span class="section">location</span> /&#123;</span><br><span class="line">      <span class="attribute">echo</span> <span class="string">&#x27;test2 <span class="variable">$uri</span>&#x27;</span>;</span><br><span class="line">    &#125; </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">80</span>; </span><br><span class="line">    <span class="attribute">server_name</span> localhost; </span><br><span class="line">    <span class="section">location</span> /&#123; </span><br><span class="line">      <span class="attribute">proxy_pass</span> http://backend; <span class="comment">#这里写upstream的名称</span></span><br><span class="line">      <span class="comment"># 多次输入curl http://localhost/abc 转发到的服务器不同</span></span><br><span class="line">    &#125; </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>使用proxy_pass时，URI的变化是由location的匹配情况决定的。当客户端的请求URI根据location的情况进入proxy_pass的时候，客户端URI中匹配location的部分，会被proxy_pass的参数替换。</p></blockquote><blockquote><p>如果location使用了正则表达式，proxy_pass的参数不应该包含路径部分。</p></blockquote><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">location</span> /abc&#123;</span><br><span class="line">  <span class="attribute">proxy_pass</span> http://example.com/xyz; </span><br><span class="line">  <span class="comment"># test.com/abc --&gt; example.com/xyz </span></span><br><span class="line">  <span class="comment"># test.com/abcdef --&gt; example.com/xyzdef</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="七、负载均衡"><a href="#七、负载均衡" class="headerlink" title="七、负载均衡"></a>七、负载均衡</h2><p>当单个业务服务端不能承载大量请求时，可以采用多机器部署的方法来解决问题。当用户请求接入的时候，反向代理会从多个业务后端当中选择一个合适的服务端，如果请求分配得比较合理，就可以做到让多个不同机器能分配到合理的负载——在这里，反向代理就完成了<strong>负载均衡</strong>的工作。</p><p>常见变量</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 可以查阅nginx.org/en/docs/http/ngx_http_upstream_module.html#variables </span></span><br><span class="line">$<span class="attribute">upstream_addr</span> <span class="comment">#上游服务器的ip地址和端口 </span></span><br><span class="line"><span class="variable">$upstream_cache_status</span> <span class="comment">#缓存状态 </span></span><br><span class="line"><span class="variable">$upstream_status</span> <span class="comment">#响应的状态码</span></span><br></pre></td></tr></table></figure><h3 id=""><a href="#" class="headerlink" title=""></a></h3><h2 id="八、引入第三方模块"><a href="#八、引入第三方模块" class="headerlink" title="八、引入第三方模块"></a>八、引入第三方模块</h2><h3 id="1-下载echo-nginx-module-master"><a href="#1-下载echo-nginx-module-master" class="headerlink" title="1. 下载echo-nginx-module-master"></a>1. 下载<a href="https://github.com/openresty/echo-nginx-module">echo-nginx-module-master</a></h3><h3 id="2-解压"><a href="#2-解压" class="headerlink" title="2. 解压"></a>2. 解压</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unzip echo-nginx-module-master.zip </span><br></pre></td></tr></table></figure><h3 id="3-回到nginx的源码目录"><a href="#3-回到nginx的源码目录" class="headerlink" title="3. 回到nginx的源码目录"></a>3. 回到nginx的源码目录</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd nginx-1.23.3</span><br></pre></td></tr></table></figure><h3 id="4-执行configure命令（生成Makefile文件）"><a href="#4-执行configure命令（生成Makefile文件）" class="headerlink" title="4. 执行configure命令（生成Makefile文件）"></a>4. 执行configure命令（生成Makefile文件）</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./configure --add-dynamic-module=../echo-nginx-module-master</span><br></pre></td></tr></table></figure><blockquote><p>注意：记得添加编译选项<code>--add-dynamic-module</code>，如果有多个动态库，请在后面联合编译</p></blockquote><h3 id="5-执行make命令"><a href="#5-执行make命令" class="headerlink" title="5. 执行make命令"></a>5. 执行make命令</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make modules</span><br></pre></td></tr></table></figure><h3 id="6-执行安装命令-拷贝操作"><a href="#6-执行安装命令-拷贝操作" class="headerlink" title="6. 执行安装命令(拷贝操作)"></a>6. 执行安装命令(拷贝操作)</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo make install</span><br></pre></td></tr></table></figure><h3 id="7-使用第三方模块"><a href="#7-使用第三方模块" class="headerlink" title="7. 使用第三方模块"></a>7. 使用第三方模块</h3><p>在配置文件中main上下文中，加载第三方库文件(<code>.so</code>)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">load_module modules/ngx_http_echo_module.so;</span><br></pre></td></tr></table></figure><p>echo-nginx-module-master在配置文件的使用</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">location</span> /</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attribute">echo</span> <span class="string">&quot;hello,nginx&quot;</span>;<span class="comment">#返回值</span></span><br><span class="line">            <span class="attribute">echo</span> <span class="variable">$request</span>;<span class="comment">#请求报文的起始行</span></span><br><span class="line">            <span class="attribute">echo</span> <span class="variable">$remote_addr</span>;<span class="comment">#客户端的IP地址</span></span><br><span class="line">            <span class="attribute">echo</span> <span class="variable">$host</span>;           <span class="comment">#服务器的IP</span></span><br><span class="line">            <span class="attribute">echo</span> <span class="variable">$args</span>;<span class="comment">#所有的查询词</span></span><br><span class="line">            <span class="attribute">echo</span> <span class="variable">$is_args</span>;<span class="comment">#代表的是问号</span></span><br><span class="line">            <span class="attribute">echo</span> <span class="variable">$arg_key</span>;<span class="comment">#某个查询词的key</span></span><br><span class="line">            <span class="attribute">echo</span> <span class="variable">$arg_wd</span>;<span class="comment">#某个查询词的wd</span></span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h2 id="九、Nginx-rtmp搭建直播服务器"><a href="#九、Nginx-rtmp搭建直播服务器" class="headerlink" title="九、Nginx+rtmp搭建直播服务器"></a>九、Nginx+rtmp搭建直播服务器</h2><h3 id="1-安装rtmp"><a href="#1-安装rtmp" class="headerlink" title="1.安装rtmp"></a>1.安装<a href="https://github.com/arut/nginx-rtmp-module">rtmp</a></h3><ol><li><p>下载remp</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://github.com/arut/nginx-rtmp-module/archive/master.zip#下载</span><br></pre></td></tr></table></figure></li><li><p>解压</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unzip master.zip#解压</span><br></pre></td></tr></table></figure></li><li><p>进入解压后的nginx路径</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd nginx-1.23.3</span><br></pre></td></tr></table></figure></li><li><p>编译带上rtmp</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./configure --with-http_ssl_module --add-module=../nginx-rtmp-module-master</span><br></pre></td></tr></table></figure></li><li><p>安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">make</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure></li><li><p>启动nginx，检测nginx是否能成功运行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo /usr/local/nginx/sbin/nginx</span><br></pre></td></tr></table></figure></li></ol><h3 id="2-配置remp"><a href="#2-配置remp" class="headerlink" title="2. 配置remp"></a>2. 配置remp</h3><p>在<code>/usr/local/nginx/conf/nginx.conf</code>进行配置</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">rtmp</span> &#123;</span><br><span class="line">        <span class="section">server</span> &#123;</span><br><span class="line">                <span class="attribute">listen</span> <span class="number">1935</span>;</span><br><span class="line">                <span class="attribute">chunk_size</span> <span class="number">4096</span>;</span><br><span class="line"> </span><br><span class="line">                <span class="attribute">application</span> dir &#123;</span><br><span class="line">                        <span class="attribute">live</span> <span class="literal">on</span>;</span><br><span class="line">                        <span class="attribute">record</span> <span class="literal">off</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重启nginx服务器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo /usr/local/nginx/sbin/nginx -s stop</span><br><span class="line">sudo /usr/local/nginx/sbin/nginx</span><br></pre></td></tr></table></figure><h3 id="3-测试"><a href="#3-测试" class="headerlink" title="3. 测试"></a>3. 测试</h3><p>OBS推流，推流地址：<code>rtmp://IP:1935/appname/streamname</code>，本次配置使用的<code>appname</code>为<code>dir</code>，因此推流地址为：<code>rtmp://IP:1935/live/</code>。推流码自定如果为test，则VLC拉流测试需要加上推流码，拉流地址为：<code>rtmp://IP:1935/live/test</code></p>]]></content>
      
      
      <categories>
          
          <category> Tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>正则表达式</title>
      <link href="/Other/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F"/>
      <url>/Other/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F</url>
      
        <content type="html"><![CDATA[<h1 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h1><h2 id="正则表达式简介"><a href="#正则表达式简介" class="headerlink" title="正则表达式简介"></a>正则表达式简介</h2><p>正则表达式(<code>Regular Expression</code>)是一种文本模式，包括普通字符（例如，a 到 z 之间的字母）和特殊字符（称为”元字符”），可以用来描述和匹配字符串的特定模式。</p><p>正则表达式是一种用于模式匹配和搜索文本的工具，提供了一种灵活且强大的方式来查找、替换、验证和提取文本数据，可以应用于各种编程语言和文本处理工具中。</p><p>简单示例：</p><p>我们在写用户注册表单时，只允许用户名包含***字符、数字、下划线和连接字符-***，并设置用户名的长度，我们就可以使用以下正则表达式来设定。</p><figure class="highlight plaintext"><figcaption><span>Expression</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^[a-zA-Z0-9_-]&#123;3,15&#125;$</span><br></pre></td></tr></table></figure><ul><li><code>^</code> 表示匹配字符串的开头。</li><li><code>[a-zA-Z0-9_-]</code> 表示字符集，包含小写字母、大写字母、数字、下划线和连接字符 **-**。</li><li><code>&#123;3,15&#125;</code> 表示前面的字符集最少出现 3 次，最多出现 15 次，从而限制了用户名的长度在 3 到 15 个字符之间。</li><li><code>$</code> 表示匹配字符串的结尾。</li></ul><h2 id="正则表达式的模式"><a href="#正则表达式的模式" class="headerlink" title="正则表达式的模式"></a>正则表达式的模式</h2><p>正则表达式的模式可以包括以下内容：</p><ul><li>字面值字符：例如字母、数字、空格等，可以直接匹配它们自身。</li><li>特殊字符：例如点号 <code>.</code>、星号 <code>*</code>、加号 <code>+</code>、问号 <code>?</code> 等，它们具有特殊的含义和功能。</li><li>字符类：用方括号 <code>[ ]</code> 包围的字符集合，用于匹配方括号内的任意一个字符。</li><li>元字符：例如 <code>\d</code>、<code>\w</code>、<code>\s</code> 等，用于匹配特定类型的字符，如数字、字母、空白字符等。</li><li>量词：例如 <code>&#123;n&#125;</code>、<code>&#123;n,&#125;</code>、<code>&#123;n,m&#125;</code> 等，用于指定匹配的次数或范围。</li><li>边界符号：例如 <code>^</code>、<code>$</code>、<code>\b</code>、<code>\B</code> 等，用于匹配字符串的开头、结尾或单词边界位置。</li></ul><h2 id="正则表达式简易使用"><a href="#正则表达式简易使用" class="headerlink" title="正则表达式简易使用"></a>正则表达式简易使用</h2><h3 id="字符匹配"><a href="#字符匹配" class="headerlink" title="字符匹配"></a>字符匹配</h3><ul><li>普通字符：普通字符按照字面意义进行匹配，例如匹配字母 “a” 将匹配到文本中的 “a” 字符。</li><li>元字符：元字符具有特殊的含义，例如 <code>\d</code> 匹配任意数字字符，<code>\w</code> 匹配任意字母数字字符，<code>.</code> 匹配任意字符（除了换行符）等。</li></ul><h3 id="量词"><a href="#量词" class="headerlink" title="量词"></a>量词</h3><ul><li><code>*</code>：匹配前面的模式零次或多次。</li><li><code>+</code>：匹配前面的模式一次或多次。</li><li><code>?</code>：匹配前面的模式零次或一次。</li><li><code>&#123;n&#125;</code>：匹配前面的模式恰好 n 次。</li><li><code>&#123;n,&#125;</code>：匹配前面的模式至少 n 次。</li><li><code>&#123;n,m&#125;</code>：匹配前面的模式至少 n 次且不超过 m 次。</li></ul><h3 id="字符类"><a href="#字符类" class="headerlink" title="字符类"></a>字符类</h3><ul><li><code>[ ]</code>：匹配括号内的任意一个字符。例如，<code>[abc]</code> 匹配字符 “a”、”b” 或 “c”。</li><li><code>[^ ]</code>：匹配除了括号内的字符以外的任意一个字符。例如，<code>[^abc]</code> 匹配除了字符 “a”、”b” 或 “c” 以外的任意字符。</li></ul><h3 id="边界匹配"><a href="#边界匹配" class="headerlink" title="边界匹配"></a>边界匹配</h3><ul><li><code>^</code>：匹配字符串的开头。</li><li><code>$</code>：匹配字符串的结尾。</li><li><code>\b</code>：匹配单词边界。</li><li><code>\B</code>：匹配非单词边界。</li></ul><h3 id="分组和捕获"><a href="#分组和捕获" class="headerlink" title="分组和捕获"></a>分组和捕获</h3><ul><li><code>( )</code>：用于分组和捕获子表达式。</li><li><code>(?: )</code>：用于分组但不捕获子表达式。</li></ul><h3 id="特殊字符"><a href="#特殊字符" class="headerlink" title="特殊字符"></a>特殊字符</h3><ul><li><code>\</code>：转义字符，用于匹配特殊字符本身。</li><li><code>.</code>：匹配任意字符（除了换行符）。</li><li><code>|</code>：用于指定多个模式的选择。</li></ul><h2 id="正则表达式语法"><a href="#正则表达式语法" class="headerlink" title="正则表达式语法"></a>正则表达式语法</h2><h3 id="普通字符"><a href="#普通字符" class="headerlink" title="普通字符"></a>普通字符</h3><p>普通字符包括没有显式指定为元字符的所有可打印和不可打印字符。这包括所有大写和小写字母、所有数字、所有标点符号和一些其他符号。</p><table><thead><tr><th align="left">字符</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>[ABC]</code></td><td align="left">匹配 <code>[...]</code> 中的所有字符，例如 <code>[aeiou]</code> 匹配字符串”google runoob taobao”中所有的 e o u a 字母。</td></tr><tr><td align="left"><code>[^ABC]</code></td><td align="left">匹配除了 <code>[...]</code> 中字符的所有字符，例如 <code>[^aeiou]</code> 匹配字符串”google runoob taobao”中除了 e o u a 字母的所有字符。</td></tr><tr><td align="left"><code>[A-Z]</code></td><td align="left"><code>[A-Z]</code> 表示一个区间，匹配所有大写字母，<code>[a-z]</code> 表示所有小写字母。</td></tr><tr><td align="left"><code>.</code></td><td align="left">匹配除换行符<code>\n</code>、<code>\r</code>之外的任何单个字符，相等于 <code>[^\n\r]</code>。<a href="%E5%9C%A8md%E6%96%87%E6%A1%A3%E4%B8%AD%60%5B%5Eabc%5D%60%E4%B8%BAabc%E7%9A%84%E5%BC%95%E7%94%A8%E6%B3%A8%E9%87%8A,%E5%8F%AF%E4%BB%A5%E8%B7%B3%E8%BD%AC">^\n\r</a></td></tr><tr><td align="left"><code>[\s\S]</code></td><td align="left">匹配所有。<code>\s</code> 是匹配所有空白符，包括换行，<code>\S</code> 非空白符，不包括换行。</td></tr><tr><td align="left"><code>\w</code></td><td align="left">匹配字母、数字、下划线。等价于 <code>[A-Za-z0-9_]</code></td></tr><tr><td align="left"><code>\d</code></td><td align="left">匹配任意一个阿拉伯数字（0 到 9）。等价于 <code>[0-9]</code></td></tr></tbody></table><h3 id="非打印字符"><a href="#非打印字符" class="headerlink" title="非打印字符"></a>非打印字符</h3><p>非打印字符也可以是正则表达式的组成部分。下表列出了表示非打印字符的转义序列：</p><table><thead><tr><th align="left">字符</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>\cx</code></td><td align="left">匹配由<code>x</code>指明的控制字符。例如， <code>\cM</code> 匹配一个 <code>Control-M </code>或<code>回车符</code>。x 的值必须为 A-Z 或 a-z 之一。否则，将 c 视为一个原义的 ‘c’ 字符。</td></tr><tr><td align="left"><code>\f</code></td><td align="left">匹配一个<code>换页符</code>。等价于 <code>\x0c</code> 和 <code>\cL</code> 。</td></tr><tr><td align="left"><code>\n</code></td><td align="left">匹配一个<code>换行符</code>。等价于 <code>\x0a</code> 和 <code>\cJ</code> 。</td></tr><tr><td align="left"><code>\r</code></td><td align="left">匹配一个<code>回车符</code>。等价于 <code>\x0d</code> 和 <code>\cM</code> 。</td></tr><tr><td align="left"><code>\s</code></td><td align="left">匹配任何<code>空白字符</code>，包括空格、制表符、换页符等等。等价于 <code>[ \f\n\r\t\v]</code> 。注意 Unicode 正则表达式会匹配全角空格符。</td></tr><tr><td align="left"><code>\S</code></td><td align="left">匹配任何<code>非空白字符</code>。等价于 <code>[^ \f\n\r\t\v]</code> 。</td></tr><tr><td align="left"><code>\t</code></td><td align="left">匹配一个<code>制表符</code>。等价于 <code>\x09</code> 和 <code>\cI</code>。</td></tr><tr><td align="left"><code>\v</code></td><td align="left">匹配一个<code>垂直制表符</code>。等价于 <code>\x0b</code> 和 <code>\cK</code>。</td></tr></tbody></table><h3 id="特殊字符-1"><a href="#特殊字符-1" class="headerlink" title="特殊字符"></a>特殊字符</h3><p>所谓特殊字符，就是一些有特殊含义的字符,如果要查找字符串中的 ***** 符号，则需要对 <code>*</code> 进行转义，即在其前加一个 <code>\</code> 。</p><p>许多元字符要求在试图匹配它们时特别对待。若要匹配这些特殊字符，必须首先使字符”转义”，即，将反斜杠字符<code>\</code> 放在它们前面。下表列出了正则表达式中的特殊字符：</p><table><thead><tr><th align="left">特别字符</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>$</code></td><td align="left">匹配输入字符串的结尾位置。如果设置了 RegExp 对象的 Multiline 属性，则 <code>$</code> 也匹配 <code>\n</code> 或 <code>\r</code> 。要匹配 <code>$</code> 字符本身，请使用 <code>\$</code>。</td></tr><tr><td align="left"><code>( )</code></td><td align="left">标记一个子表达式的开始和结束位置。子表达式可以获取供以后使用。要匹配这些字符，请使用 <code>\(</code> 和 <code>\)</code>。</td></tr><tr><td align="left"><code>*</code></td><td align="left">匹配前面的子表达式零次或多次。要匹配 <code>*</code> 字符，请使用 <code>\*</code>。</td></tr><tr><td align="left"><code>+</code></td><td align="left">匹配前面的子表达式一次或多次。要匹配 <code>+</code> 字符，请使用 <code>\+</code>。</td></tr><tr><td align="left"><code>.</code></td><td align="left">匹配除换行符 <code>\n</code> 之外的任何单字符。要匹配 <code>.</code> ，请使用 <code>\.</code> 。</td></tr><tr><td align="left"><code>[</code></td><td align="left">标记一个中括号表达式的开始。要匹配 <code>[</code>，请使用 <code>\[</code> 。</td></tr><tr><td align="left"><code>?</code></td><td align="left">匹配前面的子表达式零次或一次，或指明一个<em><strong>非贪婪限定符</strong></em>。要匹配 <code>?</code> 字符，请使用 <code>\?</code> 。</td></tr><tr><td align="left"><code>\</code></td><td align="left">将下一个字符标记为或特殊字符、或原义字符、或向后引用、或八进制转义符。例如， <code>n</code> 匹配字符 <code>n</code>。<code>\n</code> 匹配换行符。序列 <code>\\</code> 匹配 <code>\</code>，而 <code>\(</code> 则匹配 <code>(</code>。</td></tr><tr><td align="left"><code>^</code></td><td align="left">匹配输入字符串的开始位置，<strong>除非在方括号表达式中使用</strong>，当该符号在方括号表达式中使用时，表示<strong>不接受该方括号表达式中的字符集合</strong>。要匹配 <code>^</code> 字符本身，请使用 <code>\^</code> 。</td></tr><tr><td align="left"><code>&#123;</code></td><td align="left">标记限定符表达式的开始。要匹配 <code>&#123;</code>，请使用 <code>\&#123;</code> 。</td></tr><tr><td align="left">&#96;</td><td align="left">&#96;</td></tr></tbody></table><h3 id="限定符"><a href="#限定符" class="headerlink" title="限定符"></a>限定符</h3><p>限定符用来指定正则表达式的一个给定组件必须要出现多少次才能满足匹配。有 <code>*</code> 或 <code>+</code> 或 <code>?</code> 或 <code>&#123;n&#125;</code> 或 <code>&#123;n,&#125;</code> 或 <code>&#123;n,m&#125;</code> 共6种。</p><p>正则表达式的限定符有：</p><table><thead><tr><th align="left">字符</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">*</td><td align="left">匹配前面的子表达式<code>零次或多次</code>。例如，<strong>zo*</strong> 能匹配 <strong>“z”</strong> 以及 <strong>“zoo”<strong>。</strong></strong>* 等价于 **{0,}**。</td></tr><tr><td align="left">+</td><td align="left">匹配前面的子表达式<code>一次或多次</code>。例如，<strong>zo+</strong> 能匹配 <strong>“zo”</strong> 以及 “**zoo”**，但不能匹配 <strong>“z”<strong>。</strong>+</strong> 等价于 **{1,}**。</td></tr><tr><td align="left">?</td><td align="left">匹配前面的子表达式<code>零次或一次</code>。例如，<strong>do(es)?</strong> 可以匹配 <strong>“do”</strong> 、 **”does”**、 <strong>“doxy”</strong> 中的 <strong>“do”</strong> 和 <strong>“does”<strong>。</strong>?</strong> 等价于 **{0,1}**。</td></tr><tr><td align="left">{n}</td><td align="left">n 是一个非负整数。<code>匹配确定的n次</code>。例如，<strong>o{2}</strong> 不能匹配 <strong>“Bob”</strong> 中的 <strong>o</strong>，但是能匹配 <strong>“food”</strong> 中的两个 <strong>o</strong>。</td></tr><tr><td align="left">{n,}</td><td align="left">n 是一个非负整数。<code>至少匹配n 次</code>。例如，<strong>o{2,}</strong> 不能匹配 <strong>“Bob”</strong> 中的 <strong>o</strong>，但能匹配 <strong>“foooood”</strong> 中的所有 <strong>o</strong>。<strong>o{1,}</strong> 等价于 <strong>o+<strong>。</strong>o{0,}</strong> 则等价于 **o***。</td></tr><tr><td align="left">{n,m}</td><td align="left">m 和 n 均为非负整数，其中 n &lt;&#x3D; m。<code>最少匹配 n 次且最多匹配 m 次</code>。例如，<strong>o{1,3}</strong> 将匹配 <strong>“fooooood”</strong> 中的前三个 <strong>o</strong>。<strong>o{0,1}</strong> 等价于 **o?**。请注意在逗号和两个数之间不能有空格。</td></tr></tbody></table><blockquote><p>注意：</p><ol><li><p>限定符出现在范围表达式之后。因此，它应用于整个范围表达式。</p></li><li><p>通过在 <code>*</code>、<code>+</code> 或 <code>?</code> 限定符之后放置 <code>?</code> ，该表达式从**”贪婪”<strong>表达式转换为</strong>“非贪婪”**表达式或者最小匹配。</p></li></ol></blockquote><p><strong><code>*</code> 和 <code>+</code> 限定符都是贪婪的，因为它们会尽可能多的匹配文字，只有在它们的后面加上一个 ? 就可以实现非贪婪或最小匹配。</strong></p><p>例如，搜索 HTML 文档，以查找在 <strong>h1</strong> 标签内的内容。HTML 代码如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Barbecue<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><p><strong>贪婪：</strong>下面的表达式匹配从开始小于符号 (&lt;) 到关闭 h1 标记的大于符号 (&gt;) 之间的所有内容。</p><figure class="highlight plaintext"><figcaption><span>Expression</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;.*&gt;</span><br></pre></td></tr></table></figure><p>即匹配：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Barbecue<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>非贪婪：</strong>如果您只需要匹配开始和结束 h1 标签，下面的非贪婪表达式只匹配 <code>&lt;h1&gt;</code>。</p><figure class="highlight plaintext"><figcaption><span>Expression</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;.*?&gt;</span><br></pre></td></tr></table></figure><p>即匹配：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span></span><br></pre></td></tr></table></figure><p>也可以使用以下正则表达式来匹配 h1 标签，表达式则是：</p><figure class="highlight plaintext"><figcaption><span>Expression</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;\w+?&gt;</span><br></pre></td></tr></table></figure></li></ul><h3 id="定位符"><a href="#定位符" class="headerlink" title="定位符"></a>定位符</h3><p>定位符使您能够将正则表达式固定到行首或行尾。它们还使您能够创建这样的正则表达式，这些正则表达式出现在一个单词内、在一个单词的开头或者一个单词的结尾。</p><p>定位符用来描述字符串或单词的边界，<code>^</code> 和 <code>$</code> 分别指字符串的开始与结束， <code>\b</code> 描述单词的前或后边界， <code>\B</code> 表示非单词边界。</p><p>正则表达式的定位符有：</p><table><thead><tr><th align="left">字符</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">^</td><td align="left">匹配输入字符串开始的位置。如果设置了 RegExp 对象的 Multiline 属性，<code>^</code> 还会与 <code>\n</code> 或 <code>\r</code>  之后的位置匹配。</td></tr><tr><td align="left">$</td><td align="left">匹配输入字符串结尾的位置。如果设置了 RegExp 对象的 Multiline 属性，<code>$</code> 还会与 <code>\n</code> 或 <code>\r</code> 之前的位置匹配。</td></tr><tr><td align="left">\b</td><td align="left">匹配一个单词边界，即字与空格间的位置。表达式<code>\bCha</code>匹配单词 Chapter 的Cha，表达式<code>ter\b</code>匹配单词 Chapter 中的字符串 ter。但表达式<code>\bapt</code>不匹配 Chapter 中的字符串 apt。</td></tr><tr><td align="left">\B</td><td align="left">非单词边界匹配。表达式<code>\Bapt</code>匹配 Chapter 中的字符串 apt，但不匹配 aptitude 中的字符串 apt。</td></tr></tbody></table><blockquote><p><strong>注意</strong>：</p><ol><li>不能将限定符与定位符一起使用。由于在紧靠换行或者单词边界的前面或后面不能有一个以上位置，因此不允许诸如 <code>^*</code> 之类的表达式。</li><li>若要匹配一行文本开始处的文本，请在正则表达式的开始使用 <code>^</code> 字符。不要将 <code>^</code> 的这种用法与中括号表达式内的用法混淆。</li><li>若要匹配一行文本的结束处的文本，请在正则表达式的结束处使用 <code>$</code> 字符。</li><li><code>\b</code> 字符的位置是非常重要的。如果它位于要匹配的字符串的开始，它在单词的开始处查找匹配项。如果它位于字符串的结尾，它在单词的结尾处查找匹配项。</li><li><code>\B</code> 非单词边界运算符，不可以匹配单词的开头或结尾。</li></ol></blockquote><ul><li><strong>单词边界 \b</strong></li></ul><p>在正则表达式中，<strong>\b</strong> 是一个特殊的元字符，表示单词边界。它匹配一个单词的开始或结束的位置，而不匹配任何实际的字符。</p><p>具体来说，<strong>\b</strong> 匹配以下三种情况之一：</p><ul><li>单词的开头：如果 <code>\b</code> 出现在一个字母或数字之前，或者在字符串的开头，它会匹配一个单词的开始位置。</li><li>单词的结尾：如果 <code>\b</code> 出现在一个字母或数字之后，或者在字符串的末尾，它会匹配一个单词的结束位置。</li><li>单词的内部：如果 <code>\b</code> 出现在两个连续的字母或数字之间，它不会匹配任何内容，因为没有单词边界。</li></ul><p>以下是一些元字符 <strong>\b</strong> 的实例：</p><ul><li>正则表达式 <code>\bword\b</code> 匹配整个单词 “word”，但不匹配 “words” 或 “sword”。</li><li>正则表达式 <code>\b\d+\b</code> 匹配一个完整的数字，例如 “123”，但不匹配 “abc123”。</li><li>正则表达式 <code>\b[A-Z]+\b</code> 匹配一个完整的大写字母单词，例如 “HELLO”，但不匹配 “hello”。</li></ul><p>需要注意的是，<strong>\b</strong> 是一个零宽度断言，它不匹配实际的字符，只匹配位置，因此，当你想要匹配一个实际的字符时，不要使用 <strong>\b</strong>，而应该使用其他字符或字符组合。</p><ul><li><strong>非单词边界 \B</strong></li></ul><p>在正则表达式中，<strong>\B</strong> 是 <strong>\b</strong> 的反义符号，它表示非单词边界，即匹配不在单词边界处的位置。</p><p>具体来说，<strong>\B</strong> 匹配以下情况之一：</p><ul><li>单词的内部：如果 <code>\B</code> 出现在两个连续的字母或数字之间，它会匹配这两个字符之间的位置，表示它们不是单词的边界。</li><li>非单词的开头或结尾：如果 <code>\B</code> 出现在一个字母或数字之前或之后，它会匹配这个位置，表示它不是单词的开头或结尾。</li></ul><p>以下是一些元字符 <strong>\B</strong> 的实例：</p><ul><li>正则表达式 <code>\Bword\B</code> 匹配 “sword1” 中的 “word”，但不匹配 “password” 或 “words”。</li><li>正则表达式 <code>\B\d+\B</code> 匹配 “abc123def” 中的 “123”，但不匹配 “123” 或 “abc123xyz”。</li><li>正则表达式 <code>\B[A-Z]+\B</code> 匹配 “HELLO WORLD” 中的 “ELL” 和 “ORL”，但不匹配 “HELLO” 或 “WORLD”。</li></ul><p>需要注意的是，<strong>\B</strong> 也是一个零宽度断言，它不匹配实际的字符，只匹配位置，因此，当你想要匹配一个实际的字符时，不要使用 <strong>\b</strong>，而应该使用其他字符或字符组合。</p><h3 id="选择-未完成"><a href="#选择-未完成" class="headerlink" title="选择(未完成)"></a>选择(未完成)</h3><p>用圆括号 <code>()</code> 将所有选择项括起来，相邻的选择项之间用 <code>| </code>分隔。</p><p><code>()</code> 表示捕获分组，<code>()</code> 会把每个分组里的匹配的值保存起来， 多个匹配值可以通过数字 n 来查看(<strong>n</strong> 是一个数字，表示第 n 个捕获组的内容)。</p><p>但用圆括号会有一个副作用，使相关的匹配会被缓存，此时可用 <strong>?:</strong> 放在第一个选项前来消除这种副作用。其中<code> ?:</code> 是非捕获元之一，还有两个非捕获元是 <code>?=</code> 和 <code>?!</code>，这两个还有更多的含义，前者为正向预查，在任何开始匹配圆括号内的正则表达式模式的位置来匹配搜索字符串，后者为负向预查，在任何开始不匹配该正则表达式模式的位置来匹配搜索字符串。</p><p><em>更多内容可以参考：</em><a href="https://www.runoob.com/w3cnote/reg-lookahead-lookbehind.html">正则表达式的先行断言(lookahead)和后行断言(lookbehind)</a></p><h3 id="反向引用-未完成"><a href="#反向引用-未完成" class="headerlink" title="反向引用(未完成)"></a>反向引用(未完成)</h3><p>对一个正则表达式模式或部分模式两边添加圆括号将导致相关匹配存储到一个临时缓冲区中，所捕获的每个子匹配都按照在正则表达式模式中从左到右出现的顺序存储。缓冲区编号从 1 开始，最多可存储 99 个捕获的子表达式。每个缓冲区都可以使用 <strong>\n</strong> 访问，其中 n 为一个标识特定缓冲区的一位或两位十进制数。</p><p>可以使用非捕获元字符<code>?:</code>、<code>?=</code> 或 <code>?!</code> 来重写捕获，忽略对相关匹配的保存。</p><p>反向引用的最简单的、最有用的应用之一，是提供查找文本中两个相同的相邻单词的匹配项的能力。</p><h2 id="正则表达式-修饰符"><a href="#正则表达式-修饰符" class="headerlink" title="正则表达式 - 修饰符"></a>正则表达式 - 修饰符</h2><p>标记也称为修饰符，正则表达式的标记用于指定额外的匹配策略。</p><p>标记不写在正则表达式里，标记位于表达式之外，格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/pattern/flags</span><br></pre></td></tr></table></figure><p>下表列出了正则表达式常用的修饰符:</p><table><thead><tr><th>g</th><th>global - 全局匹配</th><th>查找字符串中所有的匹配项。</th></tr></thead><tbody><tr><td>i</td><td>ignore - 不区分大小写</td><td>将匹配设置为不区分大小写，搜索时不区分大小写， A 和 a 没有区别。</td></tr><tr><td>m</td><td>multi line - 多行匹配</td><td>将匹配多行，而不是整个字符串的开头和结尾。</td></tr><tr><td>s</td><td>特殊字符圆点 <strong>.</strong> 中包含换行符 <code>\n</code></td><td>默认情况下的圆点 <code>.</code> 是匹配除换行符 <code>\n</code> 之外的任何字符，加上 <code>s</code> 修饰符之后, <code>.</code> 中包含换行符 <code>\n</code>。</td></tr></tbody></table><p>例如搜索字符串:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BarBeCue Super barbecue landing barbecue</span><br><span class="line">Squirrel</span><br><span class="line">barbecue</span><br></pre></td></tr></table></figure><p>普通搜索：</p><figure class="highlight plaintext"><figcaption><span>Expression</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/barbecue/</span><br></pre></td></tr></table></figure><p>即匹配第一次匹配项：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">barbecue</span><br></pre></td></tr></table></figure><h3 id="g-修饰符"><a href="#g-修饰符" class="headerlink" title="g 修饰符"></a>g 修饰符</h3><p>g 修饰符可以查找字符串中所有的匹配项，g只匹配的第一次匹配的行：</p><figure class="highlight plaintext"><figcaption><span>Expression</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/barbecue/g</span><br></pre></td></tr></table></figure><p>即匹配第一次匹配到的行的匹配项：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">barbecue barbecue</span><br></pre></td></tr></table></figure><h3 id="i-修饰符"><a href="#i-修饰符" class="headerlink" title="i 修饰符"></a>i 修饰符</h3><p>i 修饰符为不区分大小写匹配，但是单i的情况下只能匹配一个，一般和g联用：</p><figure class="highlight plaintext"><figcaption><span>Expression</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/barbecue/gi</span><br></pre></td></tr></table></figure><p>即匹配第一次匹配到的行的匹配项：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BarBeCue barbecue barbecue</span><br></pre></td></tr></table></figure><h3 id="m-修饰符"><a href="#m-修饰符" class="headerlink" title="m 修饰符"></a>m 修饰符</h3><p>m 修饰符可以使 <code>^</code> 和 <code>$</code> 匹配一段文本中每行的开始和结束位置。但是单m的情况下只能匹配一个，一般和g联用。</p><figure class="highlight plaintext"><figcaption><span>Expression</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/^barbecue/gm</span><br></pre></td></tr></table></figure><p>g 只匹配第一行，添加 m 之后实现多行，即匹配：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">barbecue barbecue</span><br><span class="line">barbecue</span><br></pre></td></tr></table></figure><h3 id="s-修饰符"><a href="#s-修饰符" class="headerlink" title="s 修饰符"></a>s 修饰符</h3><p>默认情况下的圆点 <code>.</code> 是 匹配除换行符 <code>\n</code> 之外的任何字符，加上 <code>s</code> 之后, <code>.</code> 中包含换行符 <code>\n</code>。</p><ol><li><p>情况1，没有使用 <code>s</code> </p><figure class="highlight plaintext"><figcaption><span>Expression</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/Squirrel./</span><br></pre></td></tr></table></figure><p>无匹配，没有使用 <code>s</code>，无法匹配<code>\n</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">   </span><br></pre></td></tr></table></figure></li><li><p>情况2，使用 <code>s</code></p><figure class="highlight plaintext"><figcaption><span>Expression</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/Squirrel./s</span><br></pre></td></tr></table></figure><p>使用 <code>s</code>，匹配<code>\n</code> ，即匹配:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Squirrel\n</span><br></pre></td></tr></table></figure></li></ol><h2 id="正则表达式-元字符"><a href="#正则表达式-元字符" class="headerlink" title="正则表达式 - 元字符"></a>正则表达式 - 元字符</h2><p>下表包含了元字符的完整列表以及它们在正则表达式上下文中的行为：</p><table><thead><tr><th align="left">字符</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">\</td><td align="left">将下一个字符标记为一个特殊字符、或一个原义字符、或一个 向后引用、或一个八进制转义符。例如，’n’ 匹配字符 “n”。’\n’ 匹配一个换行符。序列 ‘\‘ 匹配 “&quot; 而 “(“ 则匹配 “(“。</td></tr><tr><td align="left">^</td><td align="left">匹配输入字符串的开始位置。如果设置了 RegExp 对象的 Multiline 属性，^ 也匹配 ‘\n’ 或 ‘\r’ 之后的位置。</td></tr><tr><td align="left">$</td><td align="left">匹配输入字符串的结束位置。如果设置了RegExp 对象的 Multiline 属性，$ 也匹配 ‘\n’ 或 ‘\r’ 之前的位置。</td></tr><tr><td align="left">*</td><td align="left">匹配前面的子表达式零次或多次。例如，zo* 能匹配 “z” 以及 “zoo”。* 等价于{0,}。</td></tr><tr><td align="left">+</td><td align="left">匹配前面的子表达式一次或多次。例如，’zo+’ 能匹配 “zo” 以及 “zoo”，但不能匹配 “z”。+ 等价于 {1,}。</td></tr><tr><td align="left">?</td><td align="left">匹配前面的子表达式零次或一次。例如，”do(es)?” 可以匹配 “do” 或 “does” 。? 等价于 {0,1}。</td></tr><tr><td align="left">{n}</td><td align="left">n 是一个非负整数。匹配确定的 n 次。例如，’o{2}’ 不能匹配 “Bob” 中的 ‘o’，但是能匹配 “food” 中的两个 o。</td></tr><tr><td align="left">{n,}</td><td align="left">n 是一个非负整数。至少匹配n 次。例如，’o{2,}’ 不能匹配 “Bob” 中的 ‘o’，但能匹配 “foooood” 中的所有 o。’o{1,}’ 等价于 ‘o+’。’o{0,}’ 则等价于 ‘o*’。</td></tr><tr><td align="left">{n,m}</td><td align="left">m 和 n 均为非负整数，其中n &lt;&#x3D; m。最少匹配 n 次且最多匹配 m 次。例如，”o{1,3}” 将匹配 “fooooood” 中的前三个 o。’o{0,1}’ 等价于 ‘o?’。请注意在逗号和两个数之间不能有空格。</td></tr><tr><td align="left">?</td><td align="left">当该字符紧跟在任何一个其他限制符 (*, +, ?, {n}, {n,}, {n,m}) 后面时，匹配模式是非贪婪的。非贪婪模式尽可能少的匹配所搜索的字符串，而默认的贪婪模式则尽可能多的匹配所搜索的字符串。例如，对于字符串 “oooo”，’o+?’ 将匹配单个 “o”，而 ‘o+’ 将匹配所有 ‘o’。</td></tr><tr><td align="left">.</td><td align="left">匹配除换行符（\n、\r）之外的任何单个字符。要匹配包括 ‘\n’ 在内的任何字符，请使用像”<strong>(.|\n)</strong>“的模式。</td></tr><tr><td align="left">(pattern)</td><td align="left">匹配 pattern 并获取这一匹配。所获取的匹配可以从产生的 Matches 集合得到，在VBScript 中使用 SubMatches 集合，在JScript 中则使用 $0…$9 属性。要匹配圆括号字符，请使用 ‘(‘ 或 ‘)‘。</td></tr><tr><td align="left">(?:pattern)</td><td align="left">匹配 pattern 但不获取匹配结果，也就是说这是一个非获取匹配，不进行存储供以后使用。这在使用 “或” 字符 (|) 来组合一个模式的各个部分是很有用。例如， ‘industr(?:y|ies) 就是一个比 ‘industry|industries’ 更简略的表达式。</td></tr><tr><td align="left">(?&#x3D;pattern)</td><td align="left">正向肯定预查（look ahead positive assert），在任何匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如，”Windows(?&#x3D;95|98|NT|2000)”能匹配”Windows2000”中的”Windows”，但不能匹配”Windows3.1”中的”Windows”。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。</td></tr><tr><td align="left">(?!pattern)</td><td align="left">正向否定预查(negative assert)，在任何不匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如”Windows(?!95|98|NT|2000)”能匹配”Windows3.1”中的”Windows”，但不能匹配”Windows2000”中的”Windows”。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。</td></tr><tr><td align="left">(?&lt;&#x3D;pattern)</td><td align="left">反向(look behind)肯定预查，与正向肯定预查类似，只是方向相反。例如，”&#96;(?&lt;&#x3D;95</td></tr><tr><td align="left">(?&lt;!pattern)</td><td align="left">反向否定预查，与正向否定预查类似，只是方向相反。例如”&#96;(?&lt;!95</td></tr><tr><td align="left">x|y</td><td align="left">匹配 x 或 y。例如，’z|food’ 能匹配 “z” 或 “food”。’(z|f)ood’ 则匹配 “zood” 或 “food”。</td></tr><tr><td align="left">[xyz]</td><td align="left">字符集合。匹配所包含的任意一个字符。例如， ‘[abc]’ 可以匹配 “plain” 中的 ‘a’。</td></tr><tr><td align="left">[^xyz]</td><td align="left">负值字符集合。匹配未包含的任意字符。例如， ‘[^abc]’ 可以匹配 “plain” 中的’p’、’l’、’i’、’n’。</td></tr><tr><td align="left">[a-z]</td><td align="left">字符范围。匹配指定范围内的任意字符。例如，’[a-z]’ 可以匹配 ‘a’ 到 ‘z’ 范围内的任意小写字母字符。</td></tr><tr><td align="left">[^a-z]</td><td align="left">负值字符范围。匹配任何不在指定范围内的任意字符。例如，’[^a-z]’ 可以匹配任何不在 ‘a’ 到 ‘z’ 范围内的任意字符。</td></tr><tr><td align="left">\b</td><td align="left">匹配一个单词边界，也就是指单词和空格间的位置。例如， ‘er\b’ 可以匹配”never” 中的 ‘er’，但不能匹配 “verb” 中的 ‘er’。</td></tr><tr><td align="left">\B</td><td align="left">匹配非单词边界。’er\B’ 能匹配 “verb” 中的 ‘er’，但不能匹配 “never” 中的 ‘er’。</td></tr><tr><td align="left">\cx</td><td align="left">匹配由 x 指明的控制字符。例如， \cM 匹配一个 Control-M 或回车符。x 的值必须为 A-Z 或 a-z 之一。否则，将 c 视为一个原义的 ‘c’ 字符。</td></tr><tr><td align="left">\d</td><td align="left">匹配一个数字字符。等价于 [0-9]。</td></tr><tr><td align="left">\D</td><td align="left">匹配一个非数字字符。等价于 [^0-9]。</td></tr><tr><td align="left">\f</td><td align="left">匹配一个换页符。等价于 \x0c 和 \cL。</td></tr><tr><td align="left">\n</td><td align="left">匹配一个换行符。等价于 \x0a 和 \cJ。</td></tr><tr><td align="left">\r</td><td align="left">匹配一个回车符。等价于 \x0d 和 \cM。</td></tr><tr><td align="left">\s</td><td align="left">匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \f\n\r\t\v]。</td></tr><tr><td align="left">\S</td><td align="left">匹配任何非空白字符。等价于 [^ \f\n\r\t\v]。</td></tr><tr><td align="left">\t</td><td align="left">匹配一个制表符。等价于 \x09 和 \cI。</td></tr><tr><td align="left">\v</td><td align="left">匹配一个垂直制表符。等价于 \x0b 和 \cK。</td></tr><tr><td align="left">\w</td><td align="left">匹配字母、数字、下划线。等价于’[A-Za-z0-9_]’。</td></tr><tr><td align="left">\W</td><td align="left">匹配非字母、数字、下划线。等价于 ‘[^A-Za-z0-9_]’。</td></tr><tr><td align="left">\xn</td><td align="left">匹配 n，其中 n 为十六进制转义值。十六进制转义值必须为确定的两个数字长。例如，’\x41’ 匹配 “A”。’\x041’ 则等价于 ‘\x04’ &amp; “1”。正则表达式中可以使用 ASCII 编码。</td></tr><tr><td align="left">\num</td><td align="left">匹配 num，其中 num 是一个正整数。对所获取的匹配的引用。例如，’(.)\1’ 匹配两个连续的相同字符。</td></tr><tr><td align="left">\n</td><td align="left">标识一个八进制转义值或一个向后引用。如果 \n 之前至少 n 个获取的子表达式，则 n 为向后引用。否则，如果 n 为八进制数字 (0-7)，则 n 为一个八进制转义值。</td></tr><tr><td align="left">\nm</td><td align="left">标识一个八进制转义值或一个向后引用。如果 \nm 之前至少有 nm 个获得子表达式，则 nm 为向后引用。如果 \nm 之前至少有 n 个获取，则 n 为一个后跟文字 m 的向后引用。如果前面的条件都不满足，若 n 和 m 均为八进制数字 (0-7)，则 \nm 将匹配八进制转义值 nm。</td></tr><tr><td align="left">\nml</td><td align="left">如果 n 为八进制数字 (0-3)，且 m 和 l 均为八进制数字 (0-7)，则匹配八进制转义值 nml。</td></tr><tr><td align="left">\un</td><td align="left">匹配 n，其中 n 是一个用四个十六进制数字表示的 Unicode 字符。例如， \u00A9 匹配版权符号 (?)。</td></tr></tbody></table><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>分析一个匹配邮箱的正则表达式：</p><figure class="highlight plaintext"><figcaption><span>Expression</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/\b[\w.%+-]+@[\w.-]+\.[a-zA-Z]&#123;2,6&#125;\b/g</span><br></pre></td></tr></table></figure><p>匹配以下文本</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">abcd Barbecue@gmail.com 1234</span><br></pre></td></tr></table></figure><p>以下的文本是获得的匹配的表达式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Barbecue@gmail.com</span><br></pre></td></tr></table></figure><p>匹配邮箱的正则表达式解析</p><p><img src="https://github.com/Barbecue-g/Imagehost/blob/master/Other/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/%E5%8C%B9%E9%85%8D%E9%82%AE%E7%AE%B1.png?raw=true" alt="匹配邮箱的正则表达式解析"></p><h2 id="正则表达式-运算符优先级"><a href="#正则表达式-运算符优先级" class="headerlink" title="正则表达式 - 运算符优先级"></a>正则表达式 - 运算符优先级</h2><p>正则表达式从左到右进行计算，并遵循优先级顺序，这与算术表达式非常类似。</p><p>相同优先级的从左到右进行运算，不同优先级的运算先高后低。下表从最高到最低说明了各种正则表达式运算符的优先级顺序：</p><table><thead><tr><th align="left">运算符</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>\</code></td><td align="left">转义符</td></tr><tr><td align="left"><code>()</code>, <code>(?:)</code>, <code>(?=)</code>, <code>[]</code></td><td align="left">圆括号和方括号</td></tr><tr><td align="left"><code>*</code>, <code>+</code>, <code>?</code>, <code>&#123;n&#125;</code>, <code>&#123;n,&#125;</code>, <code>&#123;n,m&#125;</code></td><td align="left">限定符</td></tr><tr><td align="left"><code>^</code>, <code>$</code>,<code> \任何元字符</code>、<code>任何字符</code></td><td align="left">定位点和序列（即：位置和顺序）</td></tr><tr><td align="left">&#96;</td><td align="left">&#96;</td></tr></tbody></table><p>以下是一些常见正则表达式运算符按照优先级从高到低的顺序：</p><ul><li><p><strong>转义符号：</strong> <code>\</code> 是用于转义其他特殊字符的转义符号。它具有最高的优先级。</p><p>示例：<code>\d</code>、<code>\.</code> 等，其中 <code>\d</code> 匹配数字，<code>\.</code> 匹配点号。</p></li><li><p><strong>括号：</strong> 圆括号 <code>()</code> 用于创建子表达式，具有高于其他运算符的优先级。</p><p>示例：<code>(abc)+</code> 匹配 “abc” 一次或多次。</p></li><li><p><strong>量词：</strong> 量词指定前面的元素可以重复的次数。</p><p>示例：<code>a*</code> 匹配零个或多个 “a”。</p></li><li><p><strong>字符类：</strong> 字符类使用方括号 <code>[]</code> 表示，用于匹配括号内的任意字符。</p><p>示例：<code>[aeiou]</code> 匹配任何一个元音字母。</p></li><li><p><strong>断言：</strong> 断言是用于检查字符串中特定位置的条件的元素。</p><p>示例：<code>^</code> 表示行的开头，<code>$</code> 表示行的结尾。</p></li><li><p><strong>连接：</strong> 连接在没有其他运算符的情况下表示字符之间的简单连接。</p><p>示例：<code>abc</code> 匹配 “abc”。</p></li><li><p><strong>管道：</strong> 管道符号 <code>|</code> 表示”或”关系，用于在多个模式之间选择一个。</p><p>示例：<code>cat|dog</code> 匹配 “cat” 或 “dog”。</p></li></ul><p>接下来我们看下以下正则表达式的优先级说明：</p><figure class="highlight plaintext"><figcaption><span>Expression</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\d&#123;2,3&#125;|[a-z]+(abc)*</span><br></pre></td></tr></table></figure><ul><li><code>\d&#123;2,3&#125;</code> 匹配两到三个数字。</li><li><code>|</code> 表示或。</li><li><code>[a-z]+</code> 匹配一个或多个小写字母。</li><li><code>(abc)*</code> 匹配零个或多个 “abc”。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 正则表达式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PicGo</title>
      <link href="/Tools/PicGo/PicGo"/>
      <url>/Tools/PicGo/PicGo</url>
      
        <content type="html"><![CDATA[<h1 id="PicGo使用教程"><a href="#PicGo使用教程" class="headerlink" title="PicGo使用教程"></a>PicGo使用教程</h1><h2 id="PicGo简介"><a href="#PicGo简介" class="headerlink" title="PicGo简介"></a>PicGo简介</h2><p><strong>一个用于快速上传图片并获取图片 URL 链接的工具</strong></p><p>PicGo官网：<a href="https://molunerfinn.com/PicGo">https://molunerfinn.com/PicGo</a></p><p>PicGo github：<a href="https://github.com/Molunerfinn/PicGo">https://github.com/Molunerfinn/PicGo</a></p><h2 id="Github-PicGo-Typora配置"><a href="#Github-PicGo-Typora配置" class="headerlink" title="Github+PicGo+Typora配置"></a>Github+PicGo+Typora配置</h2><h3 id="Github配置"><a href="#Github配置" class="headerlink" title="Github配置"></a>Github配置</h3><ol><li><p>创建一个公开的仓库</p><p><img src="https://github.com/Barbecue-g/Imagehost/blob/master/Tools/PicGo/%E5%88%9B%E5%BB%BA%E4%BB%93%E5%BA%93.jpg?raw=true" alt="创建仓库.jpg"></p></li><li><p>获取token（token只会出现一次，如果丢失后续得重新申请）</p><p><img src="https://github.com/Barbecue-g/Imagehost/blob/master/Tools/PicGo/%E6%89%BE%E5%88%B0settings.jpg?raw=true" alt="找到settings.jpg"></p><p><img src="https://github.com/Barbecue-g/Imagehost/blob/master/Tools/PicGo/%E6%89%BE%E5%88%B0Developer.jpg?raw=true" alt="找到Developer.jpg"></p><p><img src="https://github.com/Barbecue-g/Imagehost/blob/master/Tools/PicGo/%E8%8E%B7%E5%8F%96token.jpg?raw=true" alt="获取token.jpg"></p><p><img src="https://github.com/Barbecue-g/Imagehost/blob/master/Tools/PicGo/%E5%A4%8D%E5%88%B6token.jpg?raw=true" alt="复制token.jpg"></p></li></ol><h3 id="PicGo配置"><a href="#PicGo配置" class="headerlink" title="PicGo配置"></a>PicGo配置</h3><p><img src="https://github.com/Barbecue-g/Imagehost/blob/master/Tools/PicGo/PicGo.png?raw=true" alt="PicGo.png"></p><h3 id="Typora配置"><a href="#Typora配置" class="headerlink" title="Typora配置"></a>Typora配置</h3><p><img src="https://github.com/Barbecue-g/Imagehost/blob/master/Tools/PicGo/Typora%E9%85%8D%E7%BD%AE.png?raw=true" alt="Typora配置.png"></p>]]></content>
      
      
      <categories>
          
          <category> Tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PicGo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL的基本使用</title>
      <link href="/DataBase/MySQL/MySQL%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8"/>
      <url>/DataBase/MySQL/MySQL%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8</url>
      
        <content type="html"><![CDATA[<h1 id="MySQL基本使用"><a href="#MySQL基本使用" class="headerlink" title="MySQL基本使用"></a>MySQL基本使用</h1><p>使用前需安装库函数与引用头文件</p><p>库函数安装命令：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install libmysqlclient-dev</span><br></pre></td></tr></table></figure><p>头文件引用：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mysql/mysql.h&gt;</span> </span></span><br></pre></td></tr></table></figure><h2 id="1-连接"><a href="#1-连接" class="headerlink" title="1. 连接"></a>1. 连接</h2><p>初始化一个连接</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MYSQL * mysql = mysql_init(<span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure><h3 id="写类型指令："><a href="#写类型指令：" class="headerlink" title="写类型指令："></a>写类型指令：</h3><p><code>mysql_real_connect</code>函数的原型：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MYSQL *<span class="title function_">mysql_real_connect</span><span class="params">(MYSQL *mysql, <span class="type">const</span> <span class="type">char</span> *host, <span class="type">const</span> <span class="type">char</span> *user, <span class="type">const</span> <span class="type">char</span> *passwd, <span class="type">const</span> <span class="type">char</span> *db, <span class="type">unsigned</span> <span class="type">int</span> port, <span class="type">const</span> <span class="type">char</span> *unix_socket, <span class="type">unsigned</span> <span class="type">long</span> client_flag)</span>;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MYSQL *ret = mysql_real_connect(mysql,<span class="string">&quot;localhost&quot;</span>,<span class="string">&quot;root&quot;</span>,<span class="string">&quot;123&quot;</span>,<span class="string">&quot;table&quot;</span>,<span class="number">3306</span>,<span class="literal">NULL</span>,<span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>参数说明：</p><ul><li><code>mysql</code>：指向<code>MYSQL</code>结构的指针，用于保存连接相关的信息。</li><li><code>host</code>：要连接的MySQL服务器的主机名或IP地址。</li><li><code>user</code>：用于连接到MySQL服务器的用户名。</li><li><code>passwd</code>：连接MySQL服务器所需的密码。</li><li><code>db</code>：要连接的数据库名称。</li><li><code>port</code>：MySQL服务器的端口号。0为默认情况下，MySQL使用3306端口。</li><li><code>unix_socket</code>：Unix域套接字的路径。如果使用TCP&#x2F;IP连接，则为<code>NULL</code>。</li><li><code>client_flag</code>：客户端标志，用于设置连接的特定选项，例如加密、压缩等。</li></ul><p>检查报错</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(ret =<span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">&quot;mysql connect error:%s\n&quot;</span>,mysql_error(mysql));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>指令写入</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> qret = mysql_query(mysql,sql);</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if(ret =NULL)&#123;</span><br><span class="line">fprintf(stderr,&quot;SQL statement error:%s\n&quot;,mysql_error(mysql));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="读类型指令"><a href="#读类型指令" class="headerlink" title="读类型指令"></a>读类型指令</h3><p>基本步骤：</p><ol><li><p>执行查询语句：</p><p>使用<code>mysql_query</code>函数执行查询语句，并将结果存储在<code>MYSQL_RES</code>类型的变量中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MYSQL_RES *res;</span><br><span class="line">mysql_query(mysql, <span class="string">&quot;SELECT * FROM table_name&quot;</span>);</span><br><span class="line">res = mysql_store_result(mysql);</span><br></pre></td></tr></table></figure><p>上述示例中，<code>connection</code>是已经建立好的MySQL连接对象，”SELECT * FROM table_name”是查询语句，<code>mysql_query</code>用于执行查询，<code>mysql_store_result</code>用于将结果存储在<code>result</code>变量中。</p></li><li><p>处理结果集：</p><p>使用<code>mysql_num_fields</code>函数获取结果集中的字段数目，使用<code>mysql_fetch_row</code>函数逐行获取结果集的数据。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> num_fields = mysql_num_fields(res);</span><br><span class="line">MYSQL_ROW row;</span><br><span class="line"><span class="keyword">while</span> ((row = mysql_fetch_row(res)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; num_fields; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s\t&quot;</span>, row[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述示例中，<code>mysql_num_fields</code>用于获取结果集的字段数目，<code>mysql_fetch_row</code>用于逐行获取结果集中的数据。通过循环遍历每行数据，并在内部循环中逐个字段打印出来。</p></li><li><p>释放结果集：</p><p>使用<code>mysql_free_result</code>函数释放结果集的内存空间。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql_free_result(res);</span><br></pre></td></tr></table></figure><p>当您完成对结果集的使用后，应该使用<code>mysql_free_result</code>函数释放结果集所占用的内存空间。</p></li></ol><p>请注意，在使用<code>MYSQL_RES</code>时，需要先执行查询语句并获得结果集，然后通过逐行遍历和处理结果集中的数据。最后，务必释放结果集的内存空间以避免内存泄漏。</p><h2 id="2-增"><a href="#2-增" class="headerlink" title="2. 增"></a>2. 增</h2><p>创建一个新的数据库</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE DATABASE 数据库名;</span><br></pre></td></tr></table></figure><p>使用某个数据库，可以使用use语句</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">use mysql</span><br></pre></td></tr></table></figure><p>创建一张表</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE table_name (column_name column_type);</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> CREATE TABLE table_name (</span><br><span class="line">  id INT PRIMARY KEY AUTO_INCREMENT,</span><br><span class="line">  filename VARCHAR(256),</span><br><span class="line">  username VARCHAR(256),</span><br><span class="line">  pre_id INT,</span><br><span class="line">  filetype CHAR(1),</span><br><span class="line">  filepath VARCHAR(512),</span><br><span class="line">  isdelet INT,</span><br><span class="line">  md5 VARCHAR(1024),</span><br><span class="line">  UNIQUE KEY (username(256), filepath(512))</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>增加数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO table_name VALUES (value1, value2,...valueN);</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO table_name ( field1, field2,...fieldN )</span><br><span class="line">                       VALUES</span><br><span class="line">                       ( value1, value2,...valueN );</span><br></pre></td></tr></table></figure><p>增加列</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE 表名</span><br><span class="line">ADD 列名 数据类型 [列约束];</span><br></pre></td></tr></table></figure><h2 id="3-删"><a href="#3-删" class="headerlink" title="3. 删"></a>3. 删</h2><p>删除一个数据库</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">drop database &lt;数据库名&gt;;</span><br></pre></td></tr></table></figure><p>删除一个数据表</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DROP TABLE table_name ;</span><br></pre></td></tr></table></figure><p>数据表中删除数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DELETE FROM table_name [WHERE Clause];</span><br></pre></td></tr></table></figure><p>删除列</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE 表名</span><br><span class="line">DROP COLUMN 列名;</span><br></pre></td></tr></table></figure><h2 id="4-改"><a href="#4-改" class="headerlink" title="4. 改"></a>4. 改</h2><p>修改数据表数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">UPDATE 表名</span><br><span class="line">SET 列名1 = 新值1, 列名2 = 新值2, ...</span><br><span class="line">WHERE 条件;</span><br></pre></td></tr></table></figure><p>修改列</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE 表名</span><br><span class="line">MODIFY 列名 新数据类型 [新列约束];</span><br></pre></td></tr></table></figure><p>修改表</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE 旧表名</span><br><span class="line">RENAME TO 新表名;</span><br></pre></td></tr></table></figure><h2 id="5-查"><a href="#5-查" class="headerlink" title="5. 查"></a>5. 查</h2><p>筛选！！！</p><p>不等于：&lt;&gt;</p><p>时间可以比大小</p><p>逻辑运算：与<code>and</code>或<code>or</code><code>and</code>优先级高于<code>or</code></p><p>通配符：模糊匹配like中<code>%</code>匹配任意字符串<code>_</code>匹配单一字符</p><p>空值：is nullis not null</p><p>聚集函数：在select后的field1前面加函数如：<code>select max(field1)</code><code>select min(field1)</code><code>select avg(field1)</code></p><p>分组聚集：结果将按照<code>分组条件</code>分组 <code>group by 子句（分组聚集)</code>如<code>SELECT customer_id FROM orders GROUP BY sex</code></p><p>展示数据表格式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">desc table_name;</span><br><span class="line">describle table_name;</span><br></pre></td></tr></table></figure><p>查找语句<code>SELECT</code>语句用于从数据库表中检索数据，并将其作为结果集返回。以下是<code>SELECT</code>语句的一般语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SELECT 列名1, 列名2, ...</span><br><span class="line">FROM 表名</span><br><span class="line">WHERE 条件</span><br><span class="line">GROUP BY 列名</span><br><span class="line">HAVING 条件</span><br><span class="line">ORDER BY 列名 [ASC|DESC];</span><br></pre></td></tr></table></figure><p>具体步骤如下：</p><ol><li>使用<code>SELECT</code>关键字指定要检索的列名。使用通配符<code>*</code>选择所有列。</li><li>使用<code>FROM</code>关键字指定要从中检索数据的表名。对于多个表，可以使用<code>JOIN</code>操作符进行表连接。</li><li>可选：使用<code>WHERE</code>关键字指定筛选条件，限制要返回的行。如果省略<code>WHERE</code>子句，将返回表中的所有行。</li><li>可选：使用<code>GROUP BY</code>关键字按照指定的列对结果进行分组。<code>GROUP BY</code>通常与聚合函数（如<code>SUM</code>、<code>COUNT</code>、<code>AVG</code>等）一起使用。</li><li>可选：使用<code>HAVING</code>关键字指定分组后的筛选条件，<code>HAVING</code>子句用于对分组后的结果集进行筛选。</li><li>可选：使用<code>ORDER BY</code>关键字按照指定的列对结果进行排序，默认升序。可以附加<code>ASC</code>关键字表示升序（默认），或<code>DESC</code>关键字表示降序。</li></ol><p>排序：order by默认升序。后加<code>ASC</code>或<code>DESC</code>，表示升序或降序</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT field1, field2,...fieldN FROM table_name1, table_name2...</span><br><span class="line">[WHERE condition1 [AND [OR]] condition2.....</span><br><span class="line">ORDER BY condition1,condition2 DESC;</span><br></pre></td></tr></table></figure><p>内连接：将两个表的行连接查询</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT 列名</span><br><span class="line">FROM 表1</span><br><span class="line">INNER JOIN 表2 ON 表1.列 = 表2.列;</span><br></pre></td></tr></table></figure><h2 id="6-常见类型"><a href="#6-常见类型" class="headerlink" title="6. 常见类型"></a>6. 常见类型</h2><ol><li>整数类型（Integer Types）：<ul><li>TINYINT：1字节，范围为-128到127（有符号）或0到255（无符号）</li><li>SMALLINT：2字节，范围为-32768到32767（有符号）或0到65535（无符号）</li><li>MEDIUMINT：3字节，范围为-8388608到8388607（有符号）或0到16777215（无符号）</li><li>INT或INTEGER：4字节，范围为-2147483648到2147483647（有符号）或0到4294967295（无符号）</li><li>BIGINT：8字节，范围为-9223372036854775808到9223372036854775807（有符号）或0到18446744073709551615（无符号）</li></ul></li><li>浮点数类型（Floating-Point Types）：<ul><li>FLOAT(M, D)：4字节，单精度浮点数</li><li>DOUBLE(M, D)：8字节，双精度浮点数</li></ul></li><li>定点数类型（Fixed-Point Types）：<ul><li>DECIMAL(M, D)：存储精确小数，M表示总位数，D表示小数点后的位数</li></ul></li><li>字符串类型（String Types）：<ul><li>CHAR(M)：固定长度字符串，最多255个字符</li><li>VARCHAR(M)：可变长度字符串，最多65535个字符</li><li>TEXT：可变长度的大文本对象，最多65535个字符</li></ul></li><li>日期和时间类型（Date and Time Types）：<ul><li>DATE：日期，格式为’YYYY-MM-DD’</li><li>TIME：时间，格式为’HH:MM:SS’</li><li>DATETIME：日期和时间，格式为’YYYY-MM-DD HH:MM:SS’</li><li>TIMESTAMP：日期和时间，自1970年1月1日以来的秒数表示</li><li>YEAR：年份，范围为1901到2155</li></ul></li><li>布尔类型（Boolean Type）：<ul><li>BOOL或BOOLEAN：存储true或false</li></ul></li></ol><h2 id="7-常见约束"><a href="#7-常见约束" class="headerlink" title="7. 常见约束"></a>7. 常见约束</h2><ol><li><p>主键约束（Primary Key Constraint）：</p><ul><li><p>主键用于唯一标识表中的每一行数据，并确保数据的唯一性。</p></li><li><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE customers (</span><br><span class="line">  id INT PRIMARY KEY,</span><br><span class="line">  name VARCHAR(50),</span><br><span class="line">  email VARCHAR(100)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li></ul></li><li><p>非空约束（Not Null Constraint）：</p><ul><li><p>非空约束确保列中的值不能为空。</p></li><li><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE employees (</span><br><span class="line">  id INT,</span><br><span class="line">  name VARCHAR(50) NOT NULL,</span><br><span class="line">  age INT NOT NULL</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li></ul></li><li><p>唯一约束（Unique Constraint）：</p><ul><li><p>唯一约束确保列中的值在表中是唯一的，允许空值。</p></li><li><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE products (</span><br><span class="line">  id INT,</span><br><span class="line">  name VARCHAR(50),</span><br><span class="line">  code VARCHAR(10) UNIQUE</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>创建多列唯一约束：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE 表名 (</span><br><span class="line">    列1 数据类型,</span><br><span class="line">    列2 数据类型,</span><br><span class="line">    列3 数据类型,</span><br><span class="line">    CONSTRAINT 约束名 UNIQUE (列1, 列2, 列3)</span><br><span class="line">);</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE 表名</span><br><span class="line">ADD CONSTRAINT 约束名 UNIQUE (列1, 列2, ...);</span><br></pre></td></tr></table></figure></li></ul></li><li><p>外键约束（Foreign Key Constraint）：</p><ul><li><p>外键约束用于建立表之间的关联，确保引用表中的数据存在于被引用表中的列中。</p></li><li><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE orders (</span><br><span class="line">  id INT PRIMARY KEY,</span><br><span class="line">  customer_id INT,</span><br><span class="line">  total_amount DECIMAL(10, 2),</span><br><span class="line">  FOREIGN KEY (customer_id) REFERENCES customers(id)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li></ul></li><li><p>检查约束（Check Constraint）：</p><ul><li><p>检查约束用于定义列中的值必须满足的条件。</p></li><li><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE products (</span><br><span class="line">  id INT PRIMARY KEY,</span><br><span class="line">  name VARCHAR(50),</span><br><span class="line">  quantity INT,</span><br><span class="line">  price DECIMAL(10, 2),</span><br><span class="line">  CHECK (quantity &gt;= 0 AND price &gt;= 0)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li></ul></li><li><p>默认约束（Default Constraint）：</p><ul><li><p>默认约束用于为列指定默认值。</p></li><li><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE employees (</span><br><span class="line">  id INT PRIMARY KEY,</span><br><span class="line">  name VARCHAR(50),</span><br><span class="line">  age INT,</span><br><span class="line">  employment_date DATE DEFAULT CURRENT_DATE()</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li></ul></li></ol><h2 id="8-其他"><a href="#8-其他" class="headerlink" title="8. 其他"></a>8. 其他</h2><p>在数据库命令行中输入以下内容，显示数据库的版本</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select version(), current_date;</span><br></pre></td></tr></table></figure><p>show语句可以展示当前服务端已经存在的数据库</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show databases;</span><br></pre></td></tr></table></figure><p>show语句展示当前选择的数据库当中的所有表</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show tables;</span><br></pre></td></tr></table></figure><h1 id="MySQL数据库事务和索引"><a href="#MySQL数据库事务和索引" class="headerlink" title="MySQL数据库事务和索引"></a>MySQL数据库事务和索引</h1><h2 id="一、事务"><a href="#一、事务" class="headerlink" title="一、事务"></a>一、事务</h2><h3 id="1-概念"><a href="#1-概念" class="headerlink" title="1. 概念"></a>1. 概念</h3><p>构成单一逻辑工作单元的操作集合，即：一组命令的集合。</p><h3 id="2-事务的性质（ACID）"><a href="#2-事务的性质（ACID）" class="headerlink" title="2. 事务的性质（ACID）"></a>2. 事务的性质（ACID）</h3><ul><li>原子性(Atomicity)：原子性是指事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生。无论是操作系统崩溃，还是计算机停止运行，这项要求都要成立。即：<font color=#0099ff>事务中的操作为一个整体，要么都做，要么都不做。</font></li><li>一致性(Consistency)：事务作为一个原子性操作，它从一个一致性的数据库状态开始运行，事务结束时，数据库的状态必须再次是一致的。即：<font color=#0099ff>事务的执行的前后，数据的完整性保持一致。且事务执行前后数据的总和不变。</font></li><li>隔离性(Isolation)：尽管多个事务可能并发执行，但系统保证，对于任何一对事务Ti和Tj ,在Ti看来， Tj要么在Ti开始之前已经完成，要么在Ti完成之后才开始执行。因此，每个事务都感觉不到系统中有其他事务在并发地执行。即：<font color=#0099ff>一个事务内部的操作及使用的数据对并发的其他事务是隔离的，并发执行的各个事物之间不能互相干扰。隔离并不是100%隔离的，可能隔离一部分。</font></li><li>持久性(Durability)：一个事务成功完成后，它对数据库的改变必须是永久的，即使出现系统故障。即：<font color=#0099ff>指一个事物一旦提交，它对数据库中数据的改变就应该是永久性的。接下来的其他操作或故障不应该对其有任何影响。</font></li></ul><h3 id="3-事务的基本操作"><a href="#3-事务的基本操作" class="headerlink" title="3. 事务的基本操作"></a>3. 事务的基本操作</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#开启一个事务，标记事务的起点</span><br><span class="line">begin/start transaction;</span><br><span class="line"></span><br><span class="line">#提交事务,表示事务成功被执行。   也可以发生故障异常结束事务</span><br><span class="line">commit;</span><br><span class="line"></span><br><span class="line">#回滚 (默认回滚到事务开始的状态)</span><br><span class="line">rollback;</span><br><span class="line">rollback to sp2;#可以回滚到指定的回滚点</span><br><span class="line"></span><br><span class="line">#回滚点 （理解为快照）</span><br><span class="line">savepoint;</span><br></pre></td></tr></table></figure><p>查看表的中的字段</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show create table member;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `member` (</span><br><span class="line">  `id` int(11) NOT NULL AUTO_INCREMENT,</span><br><span class="line">  `name` varchar(20) DEFAULT NULL,</span><br><span class="line">  `age` int(11) DEFAULT NULL,</span><br><span class="line">  `math` float DEFAULT NULL,</span><br><span class="line">  `e_date` datetime DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (`id`),</span><br><span class="line">  UNIQUE KEY `name_unique_idx` (`name`),</span><br><span class="line">  KEY `name_math_idx` (`name`,`math`)</span><br><span class="line">) ENGINE=InnoDB AUTO_INCREMENT=7 DEFAULT CHARSET=latin1;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">desc member;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+--------+-------------+------+-----+---------+----------------+</span><br><span class="line">| Field  | Type        | Null | Key | Default | Extra          |</span><br><span class="line">+--------+-------------+------+-----+---------+----------------+</span><br><span class="line">| id     | int(11)     | NO   | PRI | NULL    | auto_increment |</span><br><span class="line">| name   | varchar(20) | YES  | UNI | NULL    |                |</span><br><span class="line">| age    | int(11)     | YES  |     | NULL    |                |</span><br><span class="line">| math   | float       | YES  |     | NULL    |                |</span><br><span class="line">| e_date | datetime    | YES  |     | NULL    |                |</span><br><span class="line">+--------+-------------+------+-----+---------+----------------+</span><br></pre></td></tr></table></figure><h2 id="二、并发产生的四个问题"><a href="#二、并发产生的四个问题" class="headerlink" title="二、并发产生的四个问题"></a>二、并发产生的四个问题</h2><h3 id="1-脏写"><a href="#1-脏写" class="headerlink" title="1.  脏写"></a>1.  脏写</h3><p>概念：多个事务并发<strong>写同一数据</strong>时，先执行的事务所写的数据会被后写的数据<strong>覆盖</strong></p><h3 id="2-脏读"><a href="#2-脏读" class="headerlink" title="2. 脏读"></a>2. 脏读</h3><p>概念：如果一个事务T1向数据库写数据，但该<strong>事务还没提交或终止</strong>，另一个事务T2就看到了事务T1写入数据库的数据。</p><h3 id="3-不可重复读"><a href="#3-不可重复读" class="headerlink" title="3. 不可重复读"></a>3. 不可重复读</h3><p>概念：一个事务有对同一个数据项的多次读取，但是在某前后两次读取之间，另一个事务<strong>更新该数据项</strong>，并且<strong>提交</strong>了。在后一次读取时，感知到了提交的更新</p><h3 id="4-幻读"><a href="#4-幻读" class="headerlink" title="4. 幻读"></a>4. 幻读</h3><p>概念：一个事务需要进行前后两次统计，在这两次统计期间，另一个事务插入了新的符合统计条件的记录，并且<strong>提交</strong>了。导致前后两次统计的数据不一致</p><blockquote><p>总结：<code>脏读</code>，就是读了一个<code>没有提交</code>的数据；<code>不可重复读</code>，前后两次读数据的时候，数据的<code>内容</code>发生了变化，此时该数据是已经<code>提交</code>到数据库中了；<code>幻读</code>，前后两次读数据的时候，数据的<code>条数</code>发生了变化，此时数据也是已经<code>提交</code>到数据库中了。</p></blockquote><h2 id="三、隔离级别"><a href="#三、隔离级别" class="headerlink" title="三、隔离级别"></a>三、隔离级别</h2><p>四个隔离级别：读未提交、读已提交、可重复读、可串行化。(隔离等级越来越高，并发程度越来越低。)</p><h3 id="1-读未提交-read-uncommitted"><a href="#1-读未提交-read-uncommitted" class="headerlink" title="1. 读未提交(read uncommitted)"></a>1. 读未提交(read uncommitted)</h3><p>在此隔离级别下面，避免了脏写现象，但是可以产生脏读、不可重复读与幻读现象。</p><h3 id="2-读已提交-read-committed"><a href="#2-读已提交-read-committed" class="headerlink" title="2. 读已提交(read committed)"></a>2. 读已提交(read committed)</h3><p>在此隔离级别下面，避免了脏写与脏读现象，但是可以产生不可重复读与幻读现象。</p><h3 id="3-可重复-repeatable-read"><a href="#3-可重复-repeatable-read" class="headerlink" title="3. 可重复(repeatable read)"></a>3. 可重复(repeatable read)</h3><p>可以避免脏写、脏读、不可重复读的现象。</p><p>该隔离级别是可以产生幻读现象的，但是演示方法不一样，可以借助主键进行演示，因为主键是唯一的，不能重复。</p><h3 id="4-可串行化-serializable"><a href="#4-可串行化-serializable" class="headerlink" title="4. 可串行化(serializable)"></a>4. 可串行化(serializable)</h3><p>可以避免所有的并发产生的问题，避免脏写、脏读、不可重复读、幻读。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#查看当前事务的隔离级别</span><br><span class="line">select @@session.transaction_isolation;</span><br><span class="line">select @@global.transaction_isolation;</span><br><span class="line">select @@tx_isolation;</span><br><span class="line"></span><br><span class="line">#查询当前隔离级别</span><br><span class="line">select @@session.transaction_isolation;</span><br><span class="line"></span><br><span class="line">#设置权限</span><br><span class="line">#set session transaction isolation level xxxxx</span><br><span class="line">#设置当前隔离级别为读未提交(A设置权限，则A访问他人时有限制)</span><br><span class="line">set session transaction isolation level read uncommitted;</span><br><span class="line"></span><br><span class="line">#设置当前隔离级别为读已提交(A设置权限，则A访问他人时有限制)</span><br><span class="line">set session transaction isolation level read committed;</span><br><span class="line"></span><br><span class="line">#设置当前隔离级别为可重复读(A设置权限，则A访问他人时有限制)</span><br><span class="line">set session transaction isolation level repeatable read;</span><br><span class="line"></span><br><span class="line">#设置当前隔离级别为可串行化(A设置权限，则A访问他人时有限制)</span><br><span class="line">set session transaction isolation level serializable;</span><br></pre></td></tr></table></figure><blockquote><p>总结：MySQL支持四种隔离级别，默认支持的是可重复读；Oracle只支持两种隔离级别，读已提交与可串行化，默认支持的是读已提交。隔离级别越高，串行程度越高，并发产生的问题越少。</p></blockquote><h2 id="四、索引"><a href="#四、索引" class="headerlink" title="四、索引"></a>四、索引</h2><h3 id="1-概念-1"><a href="#1-概念-1" class="headerlink" title="1. 概念"></a>1. 概念</h3><p>帮助MySQL<strong>高效</strong>获取数据的<strong>数据结构</strong></p><p>索引可以提升查询速率，索引是数据结构</p><h3 id="2-数据结构"><a href="#2-数据结构" class="headerlink" title="2. 数据结构"></a>2. 数据结构</h3><ul><li>顺序存储：会顺序扫描，从第一条一直扫描到满足条件的数据，时间复杂度是O(N)。</li><li>二分查找：查询数据的时候，时间复杂度O(logN),需要连续的大段空间。</li><li>二叉树：时间复杂度也是O(logN),树的高度会非常的高，每次查询的时候，都会进行磁盘IO，树的高度会影响查询的速率。</li><li>哈希：时间复杂度O(1),使用哈希的时候，数据是没有顺序的，但是往往在数据库中是需要进行范围查找的；如果哈希有哈希冲突，那么也会影响查询速度。</li><li>B树：多路平衡树，一个结点可以存放多个索引，那么就可以急剧降低树的高度，那么就可以减少磁盘IO的次数。B树的结点需要存放key值以及key对应的value值。</li><li>B+树：非叶子结点只存放key值，不存放value值，那么就可以让一个结点中数据的条数增加，进而可以减少树的高度。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like &#x27;innodb_page_size&#x27;; #每个大结点最大占用的空间大小</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">+------------------+-------+</span><br><span class="line">| Variable_name    | Value |</span><br><span class="line">+------------------+-------+</span><br><span class="line">| innodb_page_size | 16384 |</span><br><span class="line">+------------------+-------+</span><br><span class="line">1 row in set (0.05 sec)</span><br></pre></td></tr></table></figure><p>可以从时间复杂度、连续内存、磁盘IO的次数、范围查找几个维度。</p><p><font color=#0099ff><em><strong>MySQL底层使用的数据结构是B+树</strong></em></font>。</p><h3 id="3-B-树的特点"><a href="#3-B-树的特点" class="headerlink" title="3. B+树的特点"></a>3. B+树的特点</h3><ul><li>非叶子节点不存储data，只存储key</li><li>所有的叶子节点存储完整的一份key信息以及key对应的data</li><li>每一个父节点都出现在子节点中，是子节点的最大或者最小的元素</li><li>每个叶子节点都有一个指针，指向下一个节点，形成一个链表</li></ul>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/FrameWork/UE5/UE5"/>
      <url>/FrameWork/UE5/UE5</url>
      
        <content type="html"><![CDATA[<h1 id="Skynet"><a href="#Skynet" class="headerlink" title="Skynet"></a>Skynet</h1><p>占位</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Postman 汉化教程</title>
      <link href="/Tools/Postman/Postman%20%E6%B1%89%E5%8C%96%E6%95%99%E7%A8%8B"/>
      <url>/Tools/Postman/Postman%20%E6%B1%89%E5%8C%96%E6%95%99%E7%A8%8B</url>
      
        <content type="html"><![CDATA[<h1 id="Postman-汉化教程"><a href="#Postman-汉化教程" class="headerlink" title="Postman 汉化教程"></a>Postman 汉化教程</h1><h2 id="Postman-简介"><a href="#Postman-简介" class="headerlink" title="Postman 简介"></a>Postman 简介</h2><p>Postman 是一款非常流行的 API 调试工具，可以说是测试工程师、后端开发人员，基本上是人手必备。</p><h2 id="下载-安装-Postman"><a href="#下载-安装-Postman" class="headerlink" title="下载&amp;安装 Postman"></a>下载&amp;安装 Postman</h2><blockquote><p>注意：想要汉化 Postman， 就<strong>必须导入汉化补丁包，且补丁包的版本号需与 Postman 版本号一致才行</strong>，否则大概率无法汉化。所以，<strong>需先确认汉化补丁包的版本号，再下载对应版本的 Postman 使用</strong>。</p></blockquote><p>以下是9.12.2版本地址：</p><p>postman版本下载地址：<a href="https://www.filehorse.com/download-postman/68982/download/">https://www.filehorse.com/download-postman/68982/download/</a></p><p>githup汉化压缩包下载地址：<a href="https://github.com/hlmd/Postman-cn/releases">https://github.com/hlmd/Postman-cn/releases</a></p><h3 id="Windows-系统"><a href="#Windows-系统" class="headerlink" title="Windows 系统"></a>Windows 系统</h3><ol><li><p>下载好对应版本的汉化补丁包 <code>app.zip</code>;</p></li><li><p>进入到 Postman 安装目录下的 <code>/resources</code> 文件夹中：</p><blockquote><p>桌面找到 Postman 应用程序右键 -&gt; 打开文件所在位置，再进入 <code>app-*.*.*/resources</code> 目录下， 默认安装地址：<code>C:/Users/用户名/AppData/Local/Postman</code>， 示例：<code>C:/Users/用户名/AppData/Local/Postman/app-9.12.2/resources</code></p></blockquote></li><li><p><strong>复制 <code>app.zip</code> 到 <code>resources</code> 目录</strong>，将<code>app.zip</code><strong>解压到当前文件夹</strong>会生成一个<code>app</code>目录，如上图所示；</p></li><li><p><strong>重启 Postman</strong> 即可看到已经汉化成功~</p></li></ol><h3 id="Mac-系统"><a href="#Mac-系统" class="headerlink" title="Mac 系统"></a>Mac 系统</h3><ol><li><p>下载对应版本的 <code>app.zip</code>;</p></li><li><p><strong>解压</strong> <code>app.zip</code>；</p></li><li><p>进入 <code>访达/应用程序/Postman.app/Contents/Resources/</code>:</p><blockquote><p>进入<code>访达/应用程序</code>找到<code>Postman.app</code>右键查看包内容，再进入<code>Contents/Resources</code></p></blockquote></li><li><p>替换 <code>app</code> 文件夹</p><blockquote><p>如果目录下没有 <code>app</code> 文件夹，那么直接解压 <code>app.zip</code> 得到 <code>app</code> 文件夹即可 将<code>app.zip</code>解压出来的<code>app</code>文件夹复制到<code>Resources</code>目录，替换原本的<code>app</code>文件夹 可以先删除或重命名原本的<code>app</code>文件夹</p></blockquote></li><li><p>重启 Postman 就可以了~</p></li></ol><h3 id="Linux-系统"><a href="#Linux-系统" class="headerlink" title="Linux 系统"></a>Linux 系统</h3><ol><li><p>下载对应版本的 <code>app.zip</code>:</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 下方为Github地址 将版本号替换为对应版本号，例如：<span class="number">9</span>.<span class="number">12</span>.<span class="number">2</span></span><br><span class="line">wget https://github.com/hlmd/Postman-cn/releases/download/版本号/app.zip</span><br></pre></td></tr></table></figure></li><li><p><strong>解压&amp;&amp;替换<code>app</code>文件夹</strong>：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># Postman安装地址 自行替换</span><br><span class="line">unzip -o -d Postman安装地址/app/resources app.zip</span><br></pre></td></tr></table></figure></li></ol><h2 id="禁掉-Postman-自动更新"><a href="#禁掉-Postman-自动更新" class="headerlink" title="禁掉 Postman 自动更新"></a>禁掉 Postman 自动更新</h2><p>由于汉化补丁包版本号需要与 Postman 版本号对应的关系，如果更新了 Postman 会导致汉化失效，那么，如何禁掉 Postman 自动更新呢？</p><h3 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h3><p>Windows 删除安装目录的 update.exe 即可。</p><h3 id="Mac-Linux"><a href="#Mac-Linux" class="headerlink" title="Mac &#x2F; Linux"></a>Mac &#x2F; Linux</h3><p>将此解析加入你电脑的主机文件 hosts ：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0.0.0.0         dl.pstmn.io</span><br></pre></td></tr></table></figure><blockquote><p>注意：这是一项危险操作，将会使你的电脑无法与 Postman 下载服务器连接，当然这就可以使你的 Postman 应用程序不再更新, 如果想更新请将此解析注释或移除。</p></blockquote><h3 id="hosts-文件在哪里？"><a href="#hosts-文件在哪里？" class="headerlink" title="hosts 文件在哪里？"></a>hosts 文件在哪里？</h3><p>Windows：<code>C:/Windows/System32/drivers/etc/hosts</code></p><p>Linux &amp; Mac：<code>/etc/hosts</code></p>]]></content>
      
      
      <categories>
          
          <category> Tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Postman </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL配置</title>
      <link href="/DataBase/MySQL/MySQL%E9%85%8D%E7%BD%AE"/>
      <url>/DataBase/MySQL/MySQL%E9%85%8D%E7%BD%AE</url>
      
        <content type="html"><![CDATA[<h1 id="MySQL基本配置"><a href="#MySQL基本配置" class="headerlink" title="MySQL基本配置"></a>MySQL基本配置</h1><h2 id="一、MySQL-8-0-5-7的安装"><a href="#一、MySQL-8-0-5-7的安装" class="headerlink" title="一、MySQL 8.0&#x2F;5.7的安装"></a>一、MySQL 8.0&#x2F;5.7的安装</h2><p><font color=#0099ff> <em><strong>注意</strong></em>：Ubuntu 20以及以上的版本无需此操作 </font></p><p>下面的wget命令用于下载mysql-apt-config ，也可以从本地服务器当中下载到Linux中 </p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://dev.mysql.com/get/mysql-apt-config_0.<span class="number">8</span>.<span class="number">22</span>-<span class="number">1</span>_all.deb </span><br></pre></td></tr></table></figure><p>安装mysql-apt-config </p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo dpkg -i mysql-apt-config_0.<span class="number">8</span>.<span class="number">22</span>-<span class="number">1</span>_all.deb</span><br></pre></td></tr></table></figure><p>使用上下方向键移动选项和enter键选定选项，使得MySQL服务端的版本是8.0（或者是5.7）</p><h3 id="升级ubuntu的apt和安装mysql"><a href="#升级ubuntu的apt和安装mysql" class="headerlink" title="升级ubuntu的apt和安装mysql:"></a>升级ubuntu的apt和安装mysql:</h3><p>升级ubuntu的apt </p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update</span><br></pre></td></tr></table></figure><p>安装服务端和命令行客户端</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install mysql-server</span><br></pre></td></tr></table></figure><p>如果出现密码输入请输入密码</p><p>如果出现密码验证模式的选择，最好选择”Legacy Authentication Method”。</p><h2 id="二、用户登陆和密码修改"><a href="#二、用户登陆和密码修改" class="headerlink" title="二、用户登陆和密码修改"></a>二、用户登陆和密码修改</h2><p>使用下面的命令如果可以登录成功，说明安装成功，否则需要执行手动修改密码的过程：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 首先在命令行当中输入下列命令 </span><br><span class="line">mysql -u root -p </span><br><span class="line"># 随后输入刚才设置的密码（如果未设置密码需要手动修改登录密码）</span><br></pre></td></tr></table></figure><h3 id="手动修改登录密码"><a href="#手动修改登录密码" class="headerlink" title="手动修改登录密码:"></a>手动修改登录密码:</h3><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo su</span><br><span class="line">mysql</span><br></pre></td></tr></table></figure><p>在登录之后输入如下的命令可以修改root的访问方式<font color=#0099ff>(下面方法适用于5.7版本)</font>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">use mysql;</span><br><span class="line">update mysql.user set</span><br><span class="line">authentication_string=password(&#x27;你的密码&#x27;) where user=&#x27;root&#x27; and Host =&#x27;localhost&#x27;;</span><br><span class="line">update user set plugin=&quot;mysql_native_password&quot;;</span><br><span class="line">flush privileges;</span><br><span class="line">quit</span><br></pre></td></tr></table></figure><p><font color=#0099ff>下面方法适用于8.0版本:</font></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">use mysql;</span><br></pre></td></tr></table></figure><p><font color=#0099ff>下面的password换成你的密码:</font></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter user &#x27;root&#x27;@&#x27;localhost&#x27; identified with mysql_native_password by &#x27;password&#x27;;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flush privileges;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">quit</span><br></pre></td></tr></table></figure><p>连接到MySQL服务端</p><p>使用命令行客户端连接mysql服务端的命令如下：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -u root -p</span><br></pre></td></tr></table></figure><p>随后在提示符之后输入密码即可 ,登录成功会显示命令提示符 </p><p>mysql&gt; </p><h2 id="三、删除MySQL的方法"><a href="#三、删除MySQL的方法" class="headerlink" title="三、删除MySQL的方法"></a>三、删除MySQL的方法</h2><p>请不要自己随意卸载mysql，很容易导致无法再次安装。如需卸载，请参考下面的链接：</p><p><a href="https://blog.csdn.net/iehadoop/article/details/82961264">Ubuntu18.04彻底删除MySQL数据库青蛙组长的博客*-CSDN*博客ubuntu 删除mysql</a></p><h2 id="四、外网连接数据库"><a href="#四、外网连接数据库" class="headerlink" title="四、外网连接数据库"></a>四、外网连接数据库</h2><p>本教程只是Linux中的设置，具体软件的安装(navicat、DataGrip)请参考其他教程</p><p>在一台电脑上安装了MySQL服务器后，默认是不允许外网可以连接至该服务器上的MySQL的，不进行额外配置的话可能会出现如下两种连接错误的情况。</p><h3 id="解决问题一"><a href="#解决问题一" class="headerlink" title="解决问题一"></a>解决问题一</h3><p>首先使用如下命令查看3306端口绑定状态</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo netstat -an | grep <span class="number">3306</span></span><br></pre></td></tr></table></figure><p>3306端口是默认绑定在本地IP 127.0.0.1上的，所以外网无法访问该主机的3306端口。</p><p>打开MySQL的配置文件：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/mysql/mysql.conf.d/mysqld.cnf</span><br></pre></td></tr></table></figure><p>讲端口port &#x3D;3306解除注释：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">port            = 3306</span><br></pre></td></tr></table></figure><p>找到如下内容的一行并注释掉：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># bind-address          = 127.0.0.1</span><br></pre></td></tr></table></figure><p>将mysqlx-bind-address的网址改成0.0.0.0：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqlx-bind-address     = 0.0.0.0</span><br></pre></td></tr></table></figure><p>保存后重启MySQL服务</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl restart mysql</span><br></pre></td></tr></table></figure><p>使用如下命令查看端口绑定状态</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo netstat -an | grep 3306</span><br></pre></td></tr></table></figure><p>没有127.0.0.1就是正确的</p><h3 id="解决问题二"><a href="#解决问题二" class="headerlink" title="解决问题二"></a>解决问题二</h3><p>问题二是因为MySQL自带的权限控制限制了外网访问MySQL服务器，在Ubuntu主机上使用命令行连接至本地MySQL数据库</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo mysql -root -p</span><br></pre></td></tr></table></figure><p>输入密码</p><p>选择mysql数据库</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">use mysql</span><br></pre></td></tr></table></figure><p>查看user表信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select user,host from user;</span><br></pre></td></tr></table></figure><p>发现账户只允许localhost访问，所以外网无法访问。</p><p>新建一个用户进行连接</p><p>运行以下命令创建一个新用户：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE USER &#x27;username&#x27;@&#x27;%&#x27; IDENTIFIED BY &#x27;password&#x27;;</span><br></pre></td></tr></table></figure><p>将<code>username</code>替换为您要创建的用户名，将<code>password</code>替换为该用户的密码。<code>&#39;localhost&#39;</code>表示用户只能从本地主机连接到MySQL服务器。</p><p>因为要允许该用户从任何主机连接到MySQL服务器，所以将<code>&#39;localhost&#39;</code>替换为<code>&#39;%&#39;</code>了。</p><p>授予用户对所有数据库的全部权限：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GRANT ALL PRIVILEGES ON *.* TO &#x27;username&#x27;@&#x27;%&#x27;;</span><br></pre></td></tr></table></figure><p>运行以下命令使更改生效：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FLUSH PRIVILEGES;</span><br></pre></td></tr></table></figure><p>再查看表中的信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select user,host from user;</span><br></pre></td></tr></table></figure><p>如果想通过root用户进行连接</p><p>可以使用如下命令给外网访问授权</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">grant all privileges on *.* to &#x27;root&#x27;@&#x27;[允许的ip]&#x27; identified by &#x27;[密码]&#x27; with grant option;</span><br><span class="line">flush privileges;</span><br></pre></td></tr></table></figure><p>其中[允许的ip]如果设置为%的话则表示所有ip都可以访问，[密码]表示外网访问的密码是什么。比如我设置成所有ip都可访问，密码是root，则命令如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">grant all privileges on *.* to &#x27;root&#x27;@&#x27;%&#x27; identified by &#x27;root&#x27; with grant option;</span><br><span class="line">flush privileges;</span><br></pre></td></tr></table></figure><p>再查看表中的信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select user,host from user;</span><br></pre></td></tr></table></figure><p>经过以上操作后，就可以在可视化数据库软件连接的地方输入你的用户名和密码进行连接。</p><h2 id="五、住从配置"><a href="#五、住从配置" class="headerlink" title="五、住从配置"></a>五、住从配置</h2>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis的配置</title>
      <link href="/DataBase/Redis/Redis%E7%9A%84%E9%85%8D%E7%BD%AE"/>
      <url>/DataBase/Redis/Redis%E7%9A%84%E9%85%8D%E7%BD%AE</url>
      
        <content type="html"><![CDATA[<h1 id="Redis的基本配置"><a href="#Redis的基本配置" class="headerlink" title="Redis的基本配置"></a>Redis的基本配置</h1><p>请注意文章时间，如果过久将可能不适用</p><h2 id="一、安装"><a href="#一、安装" class="headerlink" title="一、安装"></a>一、安装</h2><h3 id="1-在-Linux-上安装-Redis"><a href="#1-在-Linux-上安装-Redis" class="headerlink" title="1. 在 Linux 上安装 Redis"></a>1. 在 Linux 上安装 Redis</h3><p>大多数主要 Linux 发行版都提供了 Redis 软件包。</p><h4 id="在-Ubuntu-Debian-上安装"><a href="#在-Ubuntu-Debian-上安装" class="headerlink" title="在 Ubuntu&#x2F;Debian 上安装"></a>在 Ubuntu&#x2F;Debian 上安装</h4><p>您可以从官方<code>packages.redis.io</code>APT 存储库安装 Redis 的最新稳定版本。</p><blockquote><p>先决条件</p><p>如果您正在运行一个非常小的发行版（例如 Docker 容器），您可能需要安装<code>lsb-release</code>,<code>curl</code>并且<code>gpg</code>首先：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="built_in">sudo</span> apt install lsb-release curl gpg</span><br></pre></td></tr></table></figure></blockquote><p>将存储库添加到索引<code>apt</code>，更新它，然后安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">curl -fsSL https://packages.redis.io/gpg | <span class="built_in">sudo</span> gpg --dearmor -o /usr/share/keyrings/redis-archive-keyring.gpg</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;deb [signed-by=/usr/share/keyrings/redis-archive-keyring.gpg] https://packages.redis.io/deb <span class="subst">$(lsb_release -cs)</span> main&quot;</span> | <span class="built_in">sudo</span> <span class="built_in">tee</span> /etc/apt/sources.list.d/redis.list</span><br><span class="line"><span class="built_in">sudo</span> apt-get update</span><br><span class="line"><span class="built_in">sudo</span> apt-get install redis</span><br></pre></td></tr></table></figure><h4 id="从-Snapcraft-安装"><a href="#从-Snapcraft-安装" class="headerlink" title="从 Snapcraft 安装"></a>从 Snapcraft 安装</h4><p><a href="https://snapcraft.io/store">Snapcraft 商店</a>提供了可以安装在支持 snap 的平台上的<a href="https://snapcraft.io/redis">Redis 软件包。</a>大多数主要 Linux 发行版都支持并提供 Snap。</p><p>要通过 snap 安装，请运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> snap install redis</span><br></pre></td></tr></table></figure><p>如果您的 Linux 当前尚未安装 snap，请按照<a href="https://snapcraft.io/docs/installing-snapd">安装 snapd</a>中所述的说明进行安装。</p><h3 id="2-在-macOS-上安装-Redis"><a href="#2-在-macOS-上安装-Redis" class="headerlink" title="2. 在 macOS 上安装 Redis"></a>2. 在 macOS 上安装 Redis</h3><p>使用 Homebrew 在 macOS 上安装并启动 Redis</p><p>Homebrew 是在 macOS 上安装 Redis 的最简单方法。如果您希望在 macOS 上从源文件构建 Redis，请参阅<a href="https://redis.io/docs/getting-started/installation/install-redis-from-source">从源安装 Redis</a>。</p><h4 id="先决条件"><a href="#先决条件" class="headerlink" title="先决条件"></a>先决条件</h4><p>首先，确保您已安装 Homebrew。从终端运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew --version</span><br></pre></td></tr></table></figure><p>如果此命令失败，您需要<a href="https://brew.sh/">按照 Homebrew 安装说明</a>进行操作。</p><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><p>从终端运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install redis</span><br></pre></td></tr></table></figure><p>这将在您的系统上安装 Redis。</p><h4 id="在前台启动和停止-Redis"><a href="#在前台启动和停止-Redis" class="headerlink" title="在前台启动和停止 Redis"></a>在前台启动和停止 Redis</h4><p>要测试 Redis 安装，您可以<code>redis-server</code>从命令行运行可执行文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-server</span><br></pre></td></tr></table></figure><p>如果成功，您将看到 Redis 的启动日志，并且 Redis 将在前台运行。</p><p>要停止 Redis，请输入<code>Ctrl-C</code>。</p><h4 id="使用-launchd-启动和停止-Redis"><a href="#使用-launchd-启动和停止-Redis" class="headerlink" title="使用 launchd 启动和停止 Redis"></a>使用 launchd 启动和停止 Redis</h4><p>作为在前台运行 Redis 的替代方案，您还可以使用<code>launchd</code>在后台启动进程：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew services start redis</span><br></pre></td></tr></table></figure><p>这将启动 Redis 并在登录时重新启动。<code>launchd</code>您可以通过运行以下命令来检查托管 Redis 的状态：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew services info redis</span><br></pre></td></tr></table></figure><p>如果服务正在运行，您将看到如下输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">redis (homebrew.mxcl.redis)</span><br><span class="line">Running: ✔</span><br><span class="line">Loaded: ✔</span><br><span class="line">User: miranda</span><br><span class="line">PID: 67975</span><br></pre></td></tr></table></figure><p>要停止该服务，请运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew services stop redis</span><br></pre></td></tr></table></figure><h4 id="连接到-Redis"><a href="#连接到-Redis" class="headerlink" title="连接到 Redis"></a>连接到 Redis</h4><p>Redis 运行后，您可以通过运行以下命令来测试它<code>redis-cli</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli</span><br></pre></td></tr></table></figure><p>这将打开 Redis REPL。尝试运行一些命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; lpush demos redis-macOS-demo</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; rpop demos</span><br><span class="line"><span class="string">&quot;redis-macOS-demo&quot;</span></span><br></pre></td></tr></table></figure><h3 id="3-从源安装-Redis"><a href="#3-从源安装-Redis" class="headerlink" title="3. 从源安装 Redis"></a>3. 从源安装 Redis</h3><p>从源代码编译并安装 Redis</p><p>您可以在各种平台和操作系统（包括 Linux 和 macOS）上从源代码编译和安装 Redis。除了 C 编译器和<code>libc</code>.</p><h4 id="下载源文件"><a href="#下载源文件" class="headerlink" title="下载源文件"></a>下载源文件</h4><p>Redis 源文件可从<a href="https://redis.io/download">下载</a>页面获取。<a href="https://github.com/redis/redis-hashes">您可以通过对照redis-hashes git 存储库</a>中的摘要检查这些下载的完整性，以验证这些下载的完整性。</p><p>要从 Redis 下载站点获取最新稳定版本 Redis 的源文件，请运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://download.redis.io/redis-stable.tar.gz</span><br></pre></td></tr></table></figure><h4 id="编译Redis"><a href="#编译Redis" class="headerlink" title="编译Redis"></a>编译Redis</h4><p>要编译 Redis，首先是 tarball，切换到根目录，然后运行<code>make</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tar -xzvf redis-stable.tar.gz</span><br><span class="line"><span class="built_in">cd</span> redis-stable</span><br><span class="line">make</span><br></pre></td></tr></table></figure><p>如果编译成功，您将在<code>src</code>目录中找到几个Redis二进制文件，包括：</p><ul><li><strong>redis-server</strong>：Redis 服务器本身</li><li><strong>redis-cli</strong>是与 Redis 交互的命令行界面实用程序。</li></ul><p>要在 中安装这些二进制文件<code>/usr/local/bin</code>，请运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make install</span><br></pre></td></tr></table></figure><h4 id="在前台启动和停止-Redis-1"><a href="#在前台启动和停止-Redis-1" class="headerlink" title="在前台启动和停止 Redis"></a>在前台启动和停止 Redis</h4><p>安装后，您可以通过运行来启动 Redis</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-server</span><br></pre></td></tr></table></figure><p>如果成功，您将看到 Redis 的启动日志，并且 Redis 将在前台运行。</p><p>要停止 Redis，请输入<code>Ctrl-C</code>。</p><h2 id="二、持久化配置"><a href="#二、持久化配置" class="headerlink" title="二、持久化配置"></a>二、持久化配置</h2><h2 id="三、主从配置"><a href="#三、主从配置" class="headerlink" title="三、主从配置"></a>三、主从配置</h2><h2 id="四、安装一些Redis库"><a href="#四、安装一些Redis库" class="headerlink" title="四、安装一些Redis库"></a>四、安装一些Redis库</h2><h3 id="1-安装hiredis"><a href="#1-安装hiredis" class="headerlink" title="1. 安装hiredis"></a>1. 安装<a href="https://github.com/redis/hiredis">hiredis</a></h3><p>通常，您可以使用 C++ 包管理器安装<em>hiredis</em>，这是最简单的方法，例如<code>sudo apt-get install libhiredis-dev</code>。但是，如果您想安装hiredis的最新代码或指定版本（例如异步支持需要hiredis v1.0.0或更高版本），您可以从源代码安装。</p><p>再次注意：请勿安装多个版本的 HIREDIS。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/redis/hiredis.git</span><br><span class="line"><span class="built_in">cd</span> hiredis</span><br><span class="line"><span class="built_in">sudo</span> make</span><br><span class="line"><span class="built_in">sudo</span> make install</span><br></pre></td></tr></table></figure><p>默认情况下，<em>hiredis</em>安装在*&#x2F;usr&#x2F;local<em>。如果要将</em>hiredis*安装在非默认位置，请使用以下命令指定安装路径。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">make PREFIX=/non/default/path</span><br><span class="line">make PREFIX=/non/default/path install</span><br></pre></td></tr></table></figure><h3 id="2-安装redis-plus-plus"><a href="#2-安装redis-plus-plus" class="headerlink" title="2. 安装redis-plus-plus"></a>2. 安装<a href="https://github.com/sewenew/redis-plus-plus#use-redis-plus-plus-in-your-project">redis-plus-plus</a></h3><p><em>redis-plus-plus</em>是使用<a href="https://cmake.org/">CMAKE</a>构建的。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/sewenew/redis-plus-plus.git</span><br><span class="line"><span class="built_in">cd</span> redis-plus-plus</span><br><span class="line"><span class="built_in">mkdir</span> build</span><br><span class="line"><span class="built_in">cd</span> build</span><br><span class="line"><span class="built_in">sudo</span> cmake ..</span><br><span class="line"><span class="built_in">sudo</span> make</span><br><span class="line"><span class="built_in">sudo</span> make install</span><br><span class="line"><span class="built_in">cd</span> ..</span><br></pre></td></tr></table></figure><p>如果<em>hiredis</em>安装在非默认位置，则应使用指定<em>hiredis</em><code>CMAKE_PREFIX_PATH</code>的安装路径。默认情况下，<em>redis-plus-plus</em>安装在*&#x2F;usr&#x2F;local<em>。但是，您可以使用在非默认位置安装</em>redis-plus-plus 。*<code>CMAKE_INSTALL_PREFIX</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmake -DCMAKE_PREFIX_PATH=/path/to/hiredis -DCMAKE_INSTALL_PREFIX=/path/to/install/redis-plus-plus ..</span><br></pre></td></tr></table></figure><p>从 1.3.0 版本开始，默认情况下，<em>redis-plus-plus</em>是按照标准构建的<code>-std=c++17</code>。这样我们就可以使用<a href="https://github.com/sewenew/redis-plus-plus#stringview">std::string_view</a>和<a href="https://github.com/sewenew/redis-plus-plus#optional">std::可选</a>功能。但是，它也可以使用<code>-std=c++11</code>或<code>-std=c++14</code>标准构建，在这种情况下，我们有自己的<code>std::string_view</code>和的简单实现<code>std::optional</code>。为了明确指定 C++ 标准，您可以使用以下 cmake 标志：<code>-DREDIS_PLUS_PLUS_CXX_STANDARD=11</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmake -DCMAKE_PREFIX_PATH=/path/to/hiredis -DCMAKE_INSTALL_PREFIX=/path/to/install/redis-plus-plus -DREDIS_PLUS_PLUS_CXX_STANDARD=11 ..</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：您应该使用相同的标准构建<em>redis-plus-plus</em>和您的应用程序，例如，如果您使用 C++17 标准构建<em>redis-plus-plus ，则还必须使用 C++17 标准构建应用程序代码。</em></p><p>编译<em>redis-plus-plus</em>时，还会编译一个测试程序，这可能需要一段时间。但是，您可以使用以下 cmake 选项禁用构建测试：<code>-DREDIS_PLUS_PLUS_BUILD_TEST=OFF</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmake -DCMAKE_PREFIX_PATH=/path/to/hiredis -DCMAKE_INSTALL_PREFIX=/path/to/install/redis-plus-plus -DREDIS_PLUS_PLUS_BUILD_TEST=OFF ..</span><br></pre></td></tr></table></figure><p>默认情况下，<em>redis-plus-plus</em>同时构建静态库和共享库。如果您只想构建其中一个，可以使用<code>-DREDIS_PLUS_PLUS_BUILD_STATIC=OFF</code>或禁用另一个<code>-DREDIS_PLUS_PLUS_BUILD_SHARED=OFF</code>。</p><p><em>redis-plus-plus</em>默认情况下使用选项构建静态库<code>-fPIC</code>，即位置无关代码。但是，您可以使用 禁用它<code>-DREDIS_PLUS_PLUS_BUILD_STATIC_WITH_PIC=OFF</code>。</p>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
